@startuml

!theme plain
top to bottom direction
skinparam linetype ortho

class AbstractApiCommand {
  # headers: Map<CharSequence, CharSequence>
  # tenantId: String
  # server: URL
  # apiToken: String
  # user: String
  - httpClientConfiguration: HttpClientConfiguration
  # apiUri(String): String
  # client(): DefaultHttpClient
  # requestOptions(MutableHttpRequest<T>): HttpRequest<T>
}
class AbstractClassDocumentation<T> {
  # docExamples: List<ExampleDoc>
  # propertiesSchema: Map<String, Object>
  # shortName: String
  # docDescription: String
  # docBody: String
  # defs: Map<String, Object>
  # deprecated: Boolean
  # beta: Boolean
  - log: Logger
  # inputs: Map<String, Object>
  - defsExclusions: List<String>
  # cls: String
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getPropertiesSchema(): Map<String, Object>
  + toString(): String
  + getDeprecated(): Boolean
  + getDefs(): Map<String, Object>
  + getInputs(): Map<String, Object>
  + getBeta(): Boolean
  + getCls(): String
  + getShortName(): String
  + getDocDescription(): String
  + getDocBody(): String
  + getDocExamples(): List<ExampleDoc>
  + getDefsExclusions(): List<String>
  # flatten(Map<String, Object>, List<String>, String): Map<String, Object>
  # flatten(Map<String, Object>, List<String>, Boolean): Map<String, Object>
  # required(Map<String, Object>): List<String>
  # flattenKey(String, String): String
  # properties(Map<String, Object>): Map<String, Object>
  # flatten(Map<String, Object>, List<String>): Map<String, Object>
  - isTypeToKeep(String): Boolean
}
class AbstractCommand {
  - startupHook: StartupHookInterface
  # pluginsPath: Path
  - versionProvider: VersionProvider
  - verbose: boolean[]
  - logLevel: LogLevel
  - endpointConfiguration: EndpointDefaultConfiguration
  - config: Path
  - internalLog: boolean
  - applicationContext: ApplicationContext
  - pluginRegistry: PluginRegistry
  - log: Logger
  # stdOut(String, Object[]): void
  # pluginRegistry(): PluginRegistry
  # stdErr(String, Object[]): void
  - startWebserver(): void
  - startLogger(): void
  - sendServerLog(): void
  + isFlowAutoLoadEnabled(): boolean
  + propertiesFromConfig(): Map<String, Object>
  + call(): Integer
  # shutdownHook(RunnableChecked<Exception>): void
  # loadExternalPlugins(): boolean
  - message(String, Object[]): String
}
class AbstractDate {
  - FORMATTERS: Map<String, DateTimeFormatter>
  - STYLES: Map<String, FormatStyle>
  - formatter(String): DateTimeFormatter
  # format(Object, Map<String, Object>, EvaluationContext): String
  # zoneId(String): ZoneId
  + getArgumentNames(): List<String>
  # convert(Object, ZoneId, String): ZonedDateTime
}
class AbstractExecScript {
  # env: Map<String, String>
  # failFast: Boolean
  # beforeCommands: List<String>
  # warningOnStdErr: Boolean
  - namespaceFiles: NamespaceFiles
  # targetOS: TargetOS
  # runner: RunnerType
  - outputFiles: List<String>
  - inputFiles: Object
  # interpreter: List<String>
  # docker: DockerOptions
  # taskRunner: TaskRunner
  - outputDirectory: Boolean
  + getRunner(): RunnerType
  + equals(Object): boolean
  + getDocker(): DockerOptions
  - $default$failFast(): Boolean
  + getOutputDirectory(): Boolean
  + toString(): String
  # canEqual(Object): boolean
  - $default$warningOnStdErr(): Boolean
  + getInputFiles(): Object
  + hashCode(): int
  + getTaskRunner(): TaskRunner
  + getBeforeCommands(): List<String>
  + getOutputFiles(): List<String>
  + getEnv(): Map<String, String>
  + getWarningOnStdErr(): Boolean
  - $default$taskRunner(): TaskRunner
  + getFailFast(): Boolean
  + getTargetOS(): TargetOS
  + getInterpreter(): List<String>
  + getNamespaceFiles(): NamespaceFiles
  - $default$interpreter(): List<String>
  - $default$targetOS(): TargetOS
  + kill(): void
  # commands(RunContext): CommandsWrapper
  # getExitOnErrorCommands(): List<String>
  # getBeforeCommandsWithOptions(): List<String>
  # mayAddExitOnErrorCommands(List<String>): List<String>
  + getContainerImage(): String
  # injectDefaults(DockerOptions): DockerOptions
}
class AbstractExecutionRepositoryTest {
  + NAMESPACE: String
  + FLOW: String
  # executionRepository: ExecutionRepositoryInterface
  ~ spyTaskRun(TaskRun, Type): TaskRun
  # executionsCount(): void
  # inject(): void
  # inject(String): void
  # findWithSort(): void
  ~ randomDuration(Type): State
  # find(): void
  # lastExecutions(): void
  # findTaskRun(): void
  # update(): void
  + builder(Type, String, String): ExecutionBuilder
  # taskRunsDailyStatistics(): void
  # mappingConflict(): void
  + builder(Type, String): ExecutionBuilder
  # dailyStatistics(): void
  # delete(): void
  # dailyGroupByFlowStatistics(): void
  # findTriggerExecutionId(): void
  # purge(): void
  # findById(): void
}
class AbstractExecutionServiceTest {
  ~ logRepository: LogRepositoryInterface
  ~ executionRepository: ExecutionRepositoryInterface
  ~ storageInterface: StorageInterface
  ~ runContextFactory: RunContextFactory
  ~ executionService: ExecutionService
  ~ purge(): void
}
class AbstractFlow {
  ~ inputs: List<Input<?>>
  ~ id: String
  ~ disabled: boolean
  ~ deleted: boolean
  ~ namespace: String
  ~ tenantId: String
  ~ revision: Integer
  + getNamespace(): String
  + getId(): String
  + getRevision(): Integer
  + getInputs(): List<Input<?>>
  + isDisabled(): boolean
  + getTenantId(): String
  - $default$disabled(): boolean
  - $default$deleted(): boolean
  + isDeleted(): boolean
}
class AbstractFlowRepositoryTest {
  # executionRepository: ExecutionRepositoryInterface
  # flowRepository: FlowRepositoryInterface
  - repositoryLoader: LocalFlowRepositoryLoader
  # pluginDefaultService: PluginDefaultService
  - triggerQueue: QueueInterface<Trigger>
  ~ findByNamespaceWithSource(): void
  ~ delete(): void
  # init(): void
  ~ findByIdWithoutAcl(): void
  ~ findAll(): void
  - builder(): FlowBuilder<?, ?>
  ~ findWithSource(): void
  ~ findAllForAllTenants(): void
  ~ findByNamespacePrefix(): void
  ~ updateConflict(): void
  ~ findByExecution(): void
  ~ saveNoRevision(): void
  ~ save(): void
  # lastRevision(): void
  - deleteFlow(Flow): void
  ~ removeTrigger(): void
  ~ findByExecutionNoRevision(): void
  - builder(String, String): FlowBuilder<?, ?>
  ~ findAllWithSourceForAllTenants(): void
  ~ findAllWithSource(): void
  ~ findByIdWithSource(): void
  # revision(): void
  # find(): void
  ~ removeTriggerDelete(): void
  ~ findById(): void
  ~ findDistinctNamespace(): void
  ~ findByNamespace(): void
  ~ templateDisabled(): void
}
class AbstractFlowTopologyRepositoryTest {
  - flowTopologyRepository: FlowTopologyRepositoryInterface
  # createSimpleFlowTopology(String, String): FlowTopology
  ~ suite(): void
}
class AbstractGraph {
  # error: boolean
  # uid: String
  # type: String
  + getUid(): String
  + getType(): String
  + isError(): boolean
  + toString(): String
  + setUid(String): void
  + setError(boolean): void
  + equals(Object): boolean
  + updateErrorWithChildren(boolean): void
  + forExecution(): AbstractGraph
  + getLabel(): String
  + updateUidWithChildren(String): void
}
class AbstractGraphTask {
  - values: List<String>
  - task: TaskInterface
  - relationType: RelationType
  - taskRun: TaskRun
  + getUid(): String
  + getTask(): TaskInterface
  + getTaskRun(): TaskRun
  + getValues(): List<String>
  + getRelationType(): RelationType
  + toString(): String
  + setTask(TaskInterface): void
  + getLabel(): String
  + forExecution(): AbstractGraph
}
class AbstractGraphTrigger {
  - triggerDeclaration: TriggerInterface
  - trigger: Trigger
  + getTriggerDeclaration(): TriggerInterface
  + getTrigger(): Trigger
  + toString(): String
  + setTriggerDeclaration(TriggerInterface): void
  + getUid(): String
  + forExecution(): AbstractGraph
}
class AbstractHttp {
  # method: HttpMethod
  # sslOptions: SslOptions
  # body: String
  # formData: Map<String, Object>
  # contentType: String
  # headers: Map<CharSequence, CharSequence>
  # uri: String
  # options: RequestOptions
  # canEqual(Object): boolean
  + getSslOptions(): SslOptions
  + equals(Object): boolean
  + hashCode(): int
  + toString(): String
  + getUri(): String
  + getMethod(): HttpMethod
  + getOptions(): RequestOptions
  + getBody(): String
  + getFormData(): Map<String, Object>
  + getContentType(): String
  + getHeaders(): Map<CharSequence, CharSequence>
  - $default$method(): HttpMethod
  # streamingClient(RunContext, HttpMethod): ReactorStreamingHttpClient
  # configuration(RunContext, HttpMethod): DefaultHttpClientConfiguration
  # client(RunContext, HttpMethod): HttpClient
  # request(RunContext): HttpRequest
  # tags(HttpRequest<String>, HttpResponse<String>): String[]
}
class AbstractIndent {
  + getArgumentNames(): List<String>
  # getLineSeparator(String): String
  # abstractApply(Object, Map<String, Object>, PebbleTemplate, EvaluationContext, int, String): Object
  # prefix(Map<String, Object>): String
}
class AbstractJdbcDeserializationIssuesTest {
  - runner: StandAloneRunner
  - jdbcTableConfigs: JdbcTableConfigs
  - jdbcTestUtils: JdbcTestUtils
  - dslContextWrapper: JooqDSLContextWrapper
  - deserializationIssuesCaseTest: DeserializationIssuesCaseTest
  ~ init(): void
  ~ flowDeserializationIssue(): void
  ~ workerTaskDeserializationIssue(): void
  ~ workerTriggerDeserializationIssue(): void
  - sendToQueue(QueueMessage): void
  # fields(QueueMessage): Map<Field<Object>, Object>
}
class AbstractJdbcExecutionDelayStorage {
  # jdbcRepository: AbstractJdbcRepository<ExecutionDelay>
  + save(ExecutionDelay): void
  + get(Consumer<ExecutionDelay>): void
}
class AbstractJdbcExecutionQueuedStorage {
  # jdbcRepository: AbstractJdbcRepository<ExecutionQueued>
  + getAllForAllTenants(): List<ExecutionQueued>
  + pop(String, String, String, Consumer<Execution>): void
  + save(ExecutionQueued): void
}
class AbstractJdbcExecutionRepository {
  - applicationContext: ApplicationContext
  # jdbcRepository: AbstractJdbcRepository<Execution>
  - NAMESPACE_FIELD: Field<String>
  - namespaceUtils: NamespaceUtils
  - executionQueue: QueueInterface<Execution>
  - eventPublisher: ApplicationEventPublisher<CrudEvent<Execution>>
  # executorStateStorage: AbstractJdbcExecutorStateStorage
  - FETCH_SIZE: int
  - START_DATE_FIELD: Field<Object>
  - STATE_CURRENT_FIELD: Field<String>
  - dailyStatisticsQuery(Condition, List<Field<?>>, String?, List<FlowScope>?, String?, String?, List<FlowFilter>, ZonedDateTime?, ZonedDateTime?, GroupType?, List<Type>?): Results
  + findByFlowId(String, String, String, Pageable): ArrayListTotal<Execution>
  + lastExecutions(String?, List<FlowFilter>): List<Execution>
  + findById(String, String, boolean): Optional<Execution>
  + dailyStatisticsForAllTenants(String?, String?, String?, ZonedDateTime?, ZonedDateTime?, GroupType?, boolean): List<DailyExecutionStatistics>
  + dailyStatistics(String?, String?, List<FlowScope>?, String?, String?, ZonedDateTime?, ZonedDateTime?, GroupType?, List<Type>?, boolean): List<DailyExecutionStatistics>
  + executionCounts(String?, List<Flow>, List<Type>?, ZonedDateTime?, ZonedDateTime?): List<ExecutionCount>
  + sortMapping(): Function<String, String>
  + maxTaskRunSetting(): Integer
  + purge(Execution): Integer
  - dailyStatisticsQueryMapRecord(Result<Record>, ZonedDateTime, ZonedDateTime, GroupType?): List<DailyExecutionStatistics>
  - dailyStatisticsQueryForAllTenants(List<Field<?>>, String?, String?, String?, List<FlowFilter>, ZonedDateTime?, ZonedDateTime?, GroupType?, List<Type>?): Results
  - dailyStatisticsQuery(List<Field<?>>, String?, String?, List<FlowScope>?, String?, String?, List<FlowFilter>, ZonedDateTime?, ZonedDateTime?, GroupType?, List<Type>?): Results
  + find(String?, String?, List<FlowScope>?, String?, String?, ZonedDateTime?, ZonedDateTime?, List<Type>?, Map<String, String>?, String?, ChildFilter?, boolean): Flux<Execution>
  # findCondition(String, Map<String, String>): Condition
  - executionQueue(): QueueInterface<Execution>
  + save(DSLContext, Execution): Execution
  # statesFilter(List<Type>): Condition
  + find(Pageable, String?, String?, List<FlowScope>?, String?, String?, ZonedDateTime?, ZonedDateTime?, List<Type>?, Map<String, String>?, String?, ChildFilter?): ArrayListTotal<Execution>
  + lock(String, Function<Pair<Execution, ExecutorState>, Pair<Executor, ExecutorState>>): Executor
  - dailyExecutionStatisticsMap(Instant, List<ExecutionStatistics>, String): DailyExecutionStatistics
  + update(Execution): Execution
  - findSelect(DSLContext, String?, String?, List<FlowScope>?, String?, String?, ZonedDateTime?, ZonedDateTime?, List<Type>?, Map<String, String>?, String?, ChildFilter?, boolean): SelectConditionStep<Record1<Object>>
  + findAllByTriggerExecutionId(String, String): Flux<Execution>
  + findTaskRun(Pageable, String?, String?, String?, String?, ZonedDateTime?, ZonedDateTime?, List<Type>?, Map<String, String>?, String?, ChildFilter?): ArrayListTotal<TaskRun>
  + dailyGroupByFlowStatistics(String?, String?, String?, String?, List<FlowFilter>?, ZonedDateTime?, ZonedDateTime?, boolean): Map<String, Map<String, List<DailyExecutionStatistics>>>
  - fillDate(List<DailyExecutionStatistics>, ZonedDateTime, ZonedDateTime, ChronoUnit, String, String): List<DailyExecutionStatistics>
  - filteringQuery(SelectConditionStep<T>, List<FlowScope>?, String?, String?, List<FlowFilter>?, String?, Map<String, String>?, String?, ChildFilter?): SelectConditionStep<T>
  + delete(Execution): Execution
  + isTaskRunEnabled(): Boolean
  - fillDate(List<DailyExecutionStatistics>, ZonedDateTime, ZonedDateTime): List<DailyExecutionStatistics>
  + executionCountsGroupedByNamespace(String?, String?, ZonedDateTime?, ZonedDateTime?): Map<String, ExecutionCountStatistics>
  + save(Execution): Execution
}
class AbstractJdbcExecutionRepositoryTest {
  ~ jdbcTestUtils: JdbcTestUtils
  # init(): void
}
class AbstractJdbcExecutorStateStorage {
  # jdbcRepository: AbstractJdbcRepository<ExecutorState>
  + delete(Execution): void
  + get(DSLContext, Execution): ExecutorState
  + save(DSLContext, ExecutorState): void
}
class AbstractJdbcFlowRepository {
  - flowQueue: QueueInterface<Flow>
  # jdbcRepository: AbstractJdbcRepository<Flow>
  - eventPublisher: ApplicationEventPublisher<CrudEvent<Flow>>
  - NAMESPACE_FIELD: Field<String>
  - log: Logger
  - namespaceUtils: NamespaceUtils
  - triggerQueue: QueueInterface<Trigger>
  - modelValidator: ModelValidator
  # defaultExecutionFilter(String): Condition
  + create(Flow, String, Flow): FlowWithSource
  + lastRevision(String, String, String): Integer
  + countForNamespace(String, String?): int
  - findByNamespacePrefixSelect(String): SelectConditionStep<Record1<Object>>
  + findRevisions(String, String, String): List<FlowWithSource>
  + findWithSource(String?, String?, List<FlowScope>?, String?, Map<String, String>?): List<FlowWithSource>
  + findSourceCode(Pageable, String?, String?, String?): ArrayListTotal<SearchResult<Flow>>
  + findDistinctNamespace(String): List<String>
  # revisionDefaultFilter(String): Condition
  + findAllWithSource(String): List<FlowWithSource>
  + findByNamespaceWithSource(String, String): List<FlowWithSource>
  + findByNamespaceExecutable(String, String): List<FlowForExecution>
  # noAclDefaultFilter(String): Condition
  + findById(String, String, String, Optional<Integer>, Boolean): Optional<Flow>
  - fullTextSelect(String, DSLContext, List<Field<Object>>): SelectConditionStep<R>
  + findByIdWithoutAcl(String, String, String, Optional<Integer>): Optional<Flow>
  - findByNamespaceSelect(String): SelectConditionStep<Record1<Object>>
  + find(Pageable, String?, String?, List<FlowScope>?, String?, Map<String, String>?): ArrayListTotal<Flow>
  # fromLastRevision(boolean): Table<Record>
  + findAllWithSourceForAllTenants(): List<FlowWithSource>
  # findCondition(String, Map<String, String>): Condition
  + update(Flow, Flow, String, Flow): FlowWithSource
  + count(String): int
  # findSourceCodeCondition(String): Condition
  + findAll(String): List<Flow>
  + findDistinctNamespaceExecutable(String): List<String>
  + findByIdWithSource(String, String, String, Optional<Integer>, Boolean): Optional<FlowWithSource>
  + findByNamespacePrefix(String, String): List<Flow>
  + findByNamespace(String, String): List<Flow>
  - save(Flow, CrudEventType, String): FlowWithSource
  + findAllForAllTenants(): List<Flow>
  + delete(Flow): Flow
}
class AbstractJdbcFlowRepositoryTest {
  # flowRepository: AbstractJdbcFlowRepository
  # dslContextWrapper: JooqDSLContextWrapper
  ~ jdbcTestUtils: JdbcTestUtils
  ~ shouldCountForNullTenantGivenNamespace(): void
  - createTestFlowForNamespace(String): Flow
  # setup(): void
  ~ shouldCountForNullTenant(): void
  + findSourceCode(): void
  + invalidFlow(): void
}
class AbstractJdbcFlowTopologyRepository {
  # jdbcRepository: AbstractJdbcRepository<FlowTopology>
  + save(Flow, List<FlowTopology>): void
  # buildTenantCondition(String, String): Condition
  # buildMergeStatement(DSLContext, FlowTopology): DMLQuery<Record>
  + findByNamespace(String, String): List<FlowTopology>
  + save(FlowTopology): FlowTopology
  + save(DSLContext, FlowTopology): FlowTopology
  + findByFlow(String, String, String, Boolean): List<FlowTopology>
}
class AbstractJdbcFlowTopologyRepositoryTest {
  ~ jdbcTestUtils: JdbcTestUtils
  - flowTopologyRepository: AbstractJdbcFlowTopologyRepository
  # init(): void
  ~ saveMultiple(): void
}
class AbstractJdbcLogRepository {
  # jdbcRepository: AbstractJdbcRepository<LogEntry>
  + find(Pageable, String?, String?, String?, String?, String?, Level?, ZonedDateTime?, ZonedDateTime?): ArrayListTotal<LogEntry>
  + findByExecutionIdAndTaskRunIdAndAttempt(String, String, String, Level, Integer): List<LogEntry>
  + findByExecutionIdAndTaskRunId(String, String, String, Level, Pageable): ArrayListTotal<LogEntry>
  + purge(Execution): Integer
  # findCondition(String): Condition
  + deleteByQuery(String, String, String, String, Level, Integer): void
  + findByExecutionIdAndTaskId(String, String, String, Level, Pageable): ArrayListTotal<LogEntry>
  + save(LogEntry): LogEntry
  + statistics(String?, String?, String?, String?, Level?, ZonedDateTime?, ZonedDateTime?, GroupType?): List<LogStatistics>
  - fillDate(List<LogStatistics>, ZonedDateTime, ZonedDateTime, ChronoUnit, String): List<LogStatistics>
  # levelsCondition(List<Level>): Condition
  + deleteByQuery(String, String, String, String): void
  + findByExecutionIdAndTaskId(String, String, String, String, String, Level): List<LogEntry>
  + findByExecutionIdAndTaskRunIdAndAttempt(String, String, String, Level, Integer, Pageable): ArrayListTotal<LogEntry>
  - filter(SelectConditionStep<T>, String?, String?, String?, String?, Level?, ZonedDateTime?, ZonedDateTime?): SelectConditionStep<T>
  + save(DSLContext, LogEntry): LogEntry
  + deleteByQuery(String, String, String, List<Level>, ZonedDateTime, ZonedDateTime): int
  + findByExecutionIdAndTaskId(String, String, String, Level): List<LogEntry>
  + findByExecutionIdAndTaskRunId(String, String, String, Level): List<LogEntry>
  + findByExecutionId(String, String, Level): List<LogEntry>
  - query(String, Condition, Level, Pageable): ArrayListTotal<LogEntry>
  - query(String, Condition, Level): List<LogEntry>
  - minLevel(Level): Condition
  - fillDate(List<LogStatistics>, ZonedDateTime, ZonedDateTime): List<LogStatistics>
  + findByExecutionId(String, String, String, String, Level): List<LogEntry>
  + findByExecutionId(String, String, Level, Pageable): ArrayListTotal<LogEntry>
}
class AbstractJdbcLogRepositoryTest {
  ~ jdbcTestUtils: JdbcTestUtils
  # init(): void
}
class AbstractJdbcMetricRepository {
  # jdbcRepository: AbstractJdbcRepository<MetricEntry>
  - fillDate(List<MetricAggregation>, ZonedDateTime, ZonedDateTime): List<MetricAggregation>
  + sortMapping(): Function<String, String>
  + taskMetrics(String, String, String, String): List<String>
  - aggregate(String, Condition, ZonedDateTime, ZonedDateTime, String): List<MetricAggregation>
  - queryDistinct(String, Condition, String): List<String>
  + findByExecutionIdAndTaskId(String, String, String, Pageable): ArrayListTotal<MetricEntry>
  - fillDate(List<MetricAggregation>, ZonedDateTime, ZonedDateTime, ChronoUnit, String): List<MetricAggregation>
  + save(DSLContext, MetricEntry): MetricEntry
  + findByExecutionId(String, String, Pageable): ArrayListTotal<MetricEntry>
  + purge(Execution): Integer
  - aggregate(String): Field<?>
  + findByExecutionIdAndTaskRunId(String, String, String, Pageable): ArrayListTotal<MetricEntry>
  + save(MetricEntry): MetricEntry
  - query(String, Condition, Pageable): ArrayListTotal<MetricEntry>
  + aggregateByFlowId(String, String, String, String?, String, ZonedDateTime, ZonedDateTime, String): MetricAggregations
  + flowMetrics(String, String, String): List<String>
  + tasksWithMetrics(String, String, String): List<String>
}
class AbstractJdbcMetricRepositoryTest {
  ~ jdbcTestUtils: JdbcTestUtils
  # init(): void
}
class AbstractJdbcMultipleConditionStorage {
  # jdbcRepository: AbstractJdbcRepository<MultipleConditionWindow>
  + get(Flow, String): Optional<MultipleConditionWindow>
  + save(List<MultipleConditionWindow>): void
  + delete(MultipleConditionWindow): void
  + expired(String): List<MultipleConditionWindow>
}
class AbstractJdbcRepository {
  # defaultFilter(String, boolean): Condition
  # groupByFields(Duration, boolean): List<Field<?>>
  # groupByFields(Duration, String, GroupType, boolean): List<Field<?>>
  # buildTenantCondition(String): Condition
  # defaultFilter(String): Condition
  # defaultFilter(): Condition
  # defaultFilter(Boolean): Condition
  # groupByFields(Duration, String, GroupType): List<Field<?>>
  # groupByFields(Duration): List<Field<?>>
  + field(String): Field<Object>
  # weekFromTimestamp(Field<Timestamp>): Field<Integer>
  + field(String, Class<T>): Field<T>
}
class AbstractJdbcRepository<T> {
  # cls: Class<T>
  # table: Table<Record>
  # queueService: QueueService
  # dslContextWrapper: JooqDSLContextWrapper
  # MAPPER: ObjectMapper
  # deserializer: Function<Record, T>
  + fetch(Select<R>): List<T>
  + getDslContextWrapper(): JooqDSLContextWrapper
  + getTable(): Table<Record>
  + setDeserializer(Function<Record, T>): void
  + fullTextCondition(List<String>, String): Condition
  + delete(DSLContext, T): int
  + map(R): T
  + fetchPage(DSLContext, SelectConditionStep<R>, Pageable): ArrayListTotal<T>
  + persist(T): void
  + deserialize(String): T
  + fragments(String, String): List<String>
  + weekFromTimestamp(Field<Timestamp>): Field<Integer>
  + persist(T, Map<Field<Object>, Object>): void
  + mapMetricAggregation(R, String): MetricAggregation
  # sort(SelectConditionStep<R>, Pageable): SelectConditionStep<R>
  + key(T): String
  # limit(SelectConditionStep<R>, Pageable): Select<R>
  + delete(T): int
  + persist(T, DSLContext, Map<Field<Object>, Object>): void
  + fetchMetricStat(Select<Record>, String): List<MetricAggregation>
  + getDate(R, String): Instant
  + fetchOne(Select<R>): Optional<T>
  + fetchPage(DSLContext, SelectConditionStep<R>, Pageable, RecordMapper<R, E>): ArrayListTotal<E>
  + persistFields(T): Map<Field<Object>, Object>
  # pageable(SelectConditionStep<R>, Pageable): Select<R>
}
class AbstractJdbcServiceInstanceRepository {
  - UPDATED_AT: Field<Instant>
  - log: Logger
  - TYPE: Field<Object>
  - SERVICE_ID: Field<Object>
  - STATE: Field<Object>
  - CREATED_AT: Field<Instant>
  - VALUE: Field<Object>
  # jdbcRepository: AbstractJdbcRepository<ServiceInstance>
  + mayTransitionServiceTo(ServiceInstance, ServiceState, String): Response
  + findAllInstancesInNotRunningState(Configuration, boolean): List<ServiceInstance>
  + getJdbcRepository(): AbstractJdbcRepository<ServiceInstance>
  + findAllInstancesInState(ServiceState): List<ServiceInstance>
  + findAllInstancesInNotRunningState(): List<ServiceInstance>
  - mayUpdateStatusById(Configuration, ServiceInstance, ServiceState, String): ImmutablePair<ServiceInstance, ServiceInstance>?
  + findAllInstancesBetween(ServiceType, Instant, Instant): List<ServiceInstance>
  + findById(String): Optional<ServiceInstance>
  + mayTransitServiceTo(Configuration, ServiceInstance, ServiceState, String): Response
  + findById(String, Configuration, boolean): Optional<ServiceInstance>
  + transaction(TransactionalRunnable): void
  + delete(DSLContext, ServiceInstance): void
  + save(ServiceInstance): ServiceInstance
  + findAllInstancesInStates(Configuration, Set<ServiceState>, boolean): List<ServiceInstance>
  + findAllInstancesInStates(Set<ServiceState>): List<ServiceInstance>
  + sortMapping(): Function<String, String>
  + find(Pageable, Set<ServiceState>, Set<ServiceType>): ArrayListTotal<ServiceInstance>
  + findAllNonRunningInstances(Configuration, boolean): List<ServiceInstance>
  + findAllNonRunningInstances(): List<ServiceInstance>
  + transactionResult(TransactionalCallable<T>): T
  - table(): Table<Record>
  + findAll(): List<ServiceInstance>
  + delete(ServiceInstance): void
}
class AbstractJdbcServiceInstanceRepositoryTest {
  ~ jdbcTestUtils: JdbcTestUtils
  # repository: AbstractJdbcServiceInstanceRepository
  # shouldFindByServiceId(): void
  ~ shouldReturnSucceedTransitionResponseForValidTransition(): void
  ~ shouldReturnEmptyForTransitionWorkerStateGivenInvalidWorker(): void
  # shouldFindAllServiceInstances(): void
  # shouldFindAllInstancesInNotRunningState(): void
  ~ shouldReturnInvalidTransitionResponseForInvalidTransition(): void
  # shouldSaveServiceInstance(): void
  # shouldDeleteGivenServiceInstance(): void
  # init(): void
  # shouldFindAllNonRunningInstances(): void
}
class AbstractJdbcSettingRepository {
  - eventPublisher: ApplicationEventPublisher<CrudEvent<Setting>>
  # jdbcRepository: AbstractJdbcRepository<Setting>
  + findAll(): List<Setting>
  + isTaskRunEnabled(): Boolean
  + delete(Setting): Setting
  + findByKey(String): Optional<Setting>
  + save(Setting): Setting
}
class AbstractJdbcSettingRepositoryTest {
  ~ jdbcTestUtils: JdbcTestUtils
  # init(): void
}
class AbstractJdbcSubflowExecutionStorage {
  # jdbcRepository: AbstractJdbcRepository<SubflowExecution<?>>
  - MAPPER: ObjectMapper
  + delete(SubflowExecution<?>): void
  + get(String): Optional<SubflowExecution<?>>
  + save(List<SubflowExecution<?>>): void
}
class AbstractJdbcTemplateRepository {
  - templateQueue: QueueInterface<Template>
  - eventPublisher: ApplicationEventPublisher<CrudEvent<Template>>
  # jdbcRepository: AbstractJdbcRepository<Template>
  + create(Template): Template
  + findById(String, String, String): Optional<Template>
  + find(Pageable, String?, String?, String?): ArrayListTotal<Template>
  + findAll(String): List<Template>
  + findByNamespace(String, String): List<Template>
  + findAllForAllTenants(): List<Template>
  + find(String?, String?, String?): List<Template>
  + update(Template, Template): Template
  + findDistinctNamespace(String): List<String>
  + delete(Template): void
  # findCondition(String): Condition
}
class AbstractJdbcTemplateRepositoryTest {
  ~ jdbcTestUtils: JdbcTestUtils
  ~ find(): void
  # init(): void
}
class AbstractJdbcTriggerRepository {
  + NAMESPACE_FIELD: Field<Object>
  # jdbcRepository: AbstractJdbcRepository<Trigger>
  + findAllForAllTenants(): List<Trigger>
  + findLast(TriggerContext): Optional<Trigger>
  + lock(String, Function<Trigger, Trigger>): Trigger
  # fullTextCondition(String): Condition
  + updateExecution(Trigger): Trigger
  + count(String?): int
  + update(Trigger): Trigger
  # defaultFilter(): Condition
  + save(Trigger, ScheduleContextInterface): Trigger
  + find(Pageable, String, String, String, String, String): ArrayListTotal<Trigger>
  # defaultFilter(String, boolean): Condition
  + save(Trigger): Trigger
  + save(DSLContext, Trigger): Trigger
  + create(Trigger): Trigger
  + countForNamespace(String?, String?): int
  + update(Flow, AbstractTrigger, ConditionContext): Trigger
  + delete(Trigger): void
  + findByNextExecutionDateReadyForAllTenants(ZonedDateTime, ScheduleContextInterface): List<Trigger>
  + findAll(String): List<Trigger>
  + findByExecution(Execution): Optional<Trigger>
  + find(String, String, String): Flux<Trigger>
  + sortMapping(): Function<String, String>
}
class AbstractJdbcTriggerRepositoryTest {
  ~ jdbcTestUtils: JdbcTestUtils
  # repository: AbstractJdbcTriggerRepository
  ~ shouldCountForNullTenantGivenNamespace(): void
  # init(): void
  ~ shouldCountForNullTenant(): void
}
class AbstractJdbcWorkerJobRunningRepository {
  # jdbcRepository: AbstractJdbcRepository<WorkerJobRunning>
  - log: Logger
  + save(WorkerJobRunning, DSLContext): WorkerJobRunning
  + deleteByKey(String): void
  + findByKey(String): Optional<WorkerJobRunning>
  + getWorkerJobWithWorkerDead(DSLContext, List<String>): List<WorkerJobRunning>
}
class AbstractLogConsumer {
  # outputs: Map<String, Object>
  # stdErrCount: AtomicInteger
  # stdOutCount: AtomicInteger
  + getStdErrCount(): int
  + getOutputs(): Map<String, Object>
  + getStdOutCount(): int
}
class AbstractLogRepositoryTest {
  # logRepository: LogRepositoryInterface
  ~ pageable(): void
  ~ statistics(): void
  ~ delete(): void
  - logEntry(Level): LogEntryBuilder
  ~ deleteByQuery(): void
  ~ all(): void
}
class AbstractMemoryRunnerTest {
  # repositoryLoader: LocalFlowRepositoryLoader
  # runner: StandAloneRunner
  # runnerUtils: RunnerUtils
  # init(): void
}
class AbstractMetricEntry<T> {
  # timestamp: Instant
  # tags: Map<String, String>
  # name: String
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getName(): String
  + getTags(): Map<String, String>
  + getTimestamp(): Instant
  + toString(): String
  + increment(T): void
  # tagsAsArray(Map<String, String>): String[]
  + register(MetricRegistry, String, Map<String, String>): void
  - tagsAsMap(String[]): Map<String, String>
  + getType(): String
  # metricName(String): String
  + getValue(): T
}
class AbstractMetricRepositoryTest {
  # metricRepository: MetricRepositoryInterface
  ~ all(): void
  - taskRun(String, String): TaskRun
  - counter(String): Counter
  ~ names(): void
  - timer(): Timer
}
class AbstractMultipleConditionStorageTest {
  - NAMESPACE: String
  - mockFlow(Duration, Duration): Pair<Flow, MultipleCondition>
  ~ daily(): void
  ~ expired(): void
  # multipleConditionStorage(): MultipleConditionStorageInterface
  ~ minutely(): void
  ~ dailyAdvance(): void
  # save(MultipleConditionStorageInterface, Flow, List<MultipleConditionWindow>): void
  ~ hourly(): void
  ~ expiration(): void
}
class AbstractRetry {
  - maxAttempt: Integer
  - warningOnRetry: Boolean
  - behavior: Behavior
  - maxDuration: Duration
  + getMaxDuration(): Duration
  + getMaxAttempt(): Integer
  + getWarningOnRetry(): Boolean
  + getBehavior(): Behavior
  - $default$warningOnRetry(): Boolean
  - $default$behavior(): Behavior
  + nextRetryDate(Integer, Instant): Instant
  + getType(): String
  + toPolicy(): RetryPolicyBuilder<T>
  + retryPolicy(AbstractRetry): RetryPolicyBuilder<T>
}
class AbstractScheduler {
  - runContextInitializer: RunContextInitializer
  - metricRegistry: MetricRegistry
  - scheduleExecutor: ScheduledExecutorService
  # applicationContext: ApplicationContext
  - eventPublisher: ApplicationEventPublisher<ServiceStateChangeEvent>
  - executionQueue: QueueInterface<Execution>
  - runContextFactory: RunContextFactory
  - id: String
  - workerGroupService: WorkerGroupService
  - triggerQueue: QueueInterface<Trigger>
  - shutdown: AtomicBoolean
  # flowListeners: FlowListenersInterface
  - schedulable: List<FlowWithTriggers>
  # receiveCancellations: List<Runnable>
  - executionKilledQueue: QueueInterface<ExecutionKilled>
  - conditionService: ConditionService
  - schedulableNextDate: Map<String, FlowWithWorkerTriggerNextDate>
  - state: AtomicReference<ServiceState>
  - workerTriggerResultQueue: WorkerTriggerResultQueueInterface
  # triggerState: SchedulerTriggerStateInterface
  - logService: LogService
  - log: Logger
  - pluginDefaultService: PluginDefaultService
  - workerTaskQueue: QueueInterface<WorkerJob>
  - isReady: Boolean
  + getSchedulable(): List<FlowWithTriggers>
  + getSchedulableNextDate(): Map<String, FlowWithWorkerTriggerNextDate>
  + run(): void
  - evaluateScheduleTrigger(FlowWithWorkerTrigger): Optional<SchedulerExecutionWithTrigger>
  + getState(): ServiceState
  + close(): void
  - initializedTriggers(List<Flow>): void
  - emitExecution(Execution, TriggerContext): void
  # close(Runnable?): void
  - log(SchedulerExecutionWithTrigger): void
  - logError(FlowWithWorkerTrigger, Throwable): void
  + isReady(): boolean
  - computeSchedulable(List<Flow>, List<Trigger>, ScheduleContextInterface): List<FlowWithTriggers>
  - interval(AbstractTrigger): Duration
  - logError(ConditionContext, Flow, AbstractTrigger, Throwable): void
  - nextEvaluationDate(AbstractTrigger, ConditionContext, Optional<TriggerContext>): ZonedDateTime
  - handle(): void
  + getId(): String
  - sendWorkerTriggerToWorker(FlowWithWorkerTrigger): void
  + schedulerTriggers(): List<FlowWithTriggers>
  # setState(ServiceState): void
  - handleEvaluateWorkerTriggerResult(SchedulerExecutionWithTrigger, ZonedDateTime): void
  - nextEvaluationDate(AbstractTrigger): ZonedDateTime
  - handleEvaluateSchedulingTriggerResult(Schedulable, SchedulerExecutionWithTrigger, ConditionContext, ScheduleContextInterface): void
  + handleNext(List<Flow>, ZonedDateTime, BiConsumer<List<Trigger>, ScheduleContextInterface>): void
  # saveLastTriggerAndEmitExecution(Execution, Trigger, Consumer<Trigger>): void
  - isExecutionNotRunning(FlowWithWorkerTrigger): boolean
  - now(): ZonedDateTime
  + getType(): ServiceType
}
class AbstractSchedulerTest {
  # executionQueue: QueueInterface<Execution>
  # COUNTER: int
  # applicationContext: ApplicationContext
  + createThreadFlow(String): Flow
  # createFlow(List<AbstractTrigger>, List<PluginDefault>): Flow
  # createFlow(List<AbstractTrigger>): Flow
  + createThreadFlow(): Flow
}
class AbstractServerCommand {
  ~ serverPort: Integer
  # defaultWorkerThread(): int
}
class AbstractServiceLivenessCoordinator {
  - log: Logger
  # DEFAULT_REASON_FOR_DISCONNECTED: String
  # serviceInstanceRepository: ServiceInstanceRepositoryInterface
  # DEFAULT_REASON_FOR_NOT_RUNNING: String
  # serverId: String
  - DEFAULT_SCHEDULE_JITTER_MAX_MS: int
  - TASK_NAME: String
  # mayDetectAndLogNewConnectedServices(): void
  # filterAllNonRespondingServices(List<ServiceInstance>, Instant): List<ServiceInstance>
  # safelyTransitionServiceTo(ServiceInstance, ServiceState, String): void
  # getScheduleInterval(): Duration
}
class AbstractServiceLivenessTask {
  - scheduledExecutorService: ScheduledExecutorService
  - log: Logger
  - name: String
  - isStopped: AtomicBoolean
  # serverConfig: ServerConfig
  - lastScheduledExecution: Instant
  + close(): void
  + run(Instant): void
  + start(): void
  # onSchedule(Instant): void
  # getScheduleInterval(): Duration
  # getElapsedMilliSinceLastSchedule(Instant): long
  + run(): void
  # lastScheduledExecution(): Instant
  # isLivenessEnabled(): Boolean
}
class AbstractServiceNamespaceUpdateCommand {
  + delete: boolean
  + namespace: String
  + directory: Path
}
class AbstractSettingRepositoryTest {
  # settingRepository: SettingRepositoryInterface
  ~ all(): void
}
class AbstractState {
  # name: String
  - namespace: Boolean
  - taskrunValue: Boolean
  - TYPE_REFERENCE: TypeReference<Map<String, Object>>
  + equals(Object): boolean
  # get(RunContext): Map<String, Object>
  # canEqual(Object): boolean
  + hashCode(): int
  + getName(): String
  + getNamespace(): Boolean
  - $default$namespace(): Boolean
  + getTaskrunValue(): Boolean
  - $default$taskrunValue(): Boolean
  + toString(): String
  - $default$name(): String
  # merge(RunContext, Map<String, Object>): Pair<String, Map<String, Object>>
  # delete(RunContext): boolean
  - taskRunValue(RunContext): String?
}
class AbstractSubflowExecutionTest {
  ~ subflowExecutionStorage: AbstractJdbcSubflowExecutionStorage
  ~ jdbcTestUtils: JdbcTestUtils
  # persistFields(): Map<Field<Object>, Object>
  # init(): void
  ~ suite(): void
  ~ deserializationIssue(): void
}
class AbstractTaskRunnerTest {
  - storage: StorageInterface
  - runContextFactory: RunContextFactory
  # fail(): void
  # runContext(RunContextFactory): RunContext
  # runContext(RunContextFactory, Map<String, Object>): RunContext
  # defaultImage(): String
  # needsToSpecifyWorkingDirectory(): boolean
  # run(): void
  # outputDirDisabled(): void
  # initScriptCommands(RunContext): TaskCommands
  # taskRunner(): TaskRunner
  # inputAndOutputFiles(): void
}
class AbstractTemplateRepositoryTest {
  # templateRepository: TemplateRepositoryInterface
  # init(): void
  # builder(): TemplateBuilder<?, ?>
  # builder(String): TemplateBuilder<?, ?>
  ~ findAllForAllTenants(): void
  ~ save(): void
  ~ findByNamespace(): void
  ~ delete(): void
  ~ findAll(): void
  ~ find(): void
  ~ findById(): void
}
class AbstractTrigger {
  # type: String
  - workerGroup: WorkerGroup
  - description: String
  - logLevel: Level
  - logToFile: boolean
  - stopAfter: List<Type>
  # conditions: List<Condition>
  - disabled: boolean
  # id: String
  - labels: List<Label>
  + getConditions(): List<Condition>
  + getId(): String
  + getType(): String
  + getDescription(): String
  + isDisabled(): boolean
  - $default$disabled(): boolean
  + getWorkerGroup(): WorkerGroup
  + getLogLevel(): Level
  + getLabels(): List<Label>
  - $default$logToFile(): boolean
  + getStopAfter(): List<Type>
  + isLogToFile(): boolean
  + setMinLogLevel(Level): void
}
class AbstractTriggerForExecution {
  # type: String
  # id: String
  + getId(): String
  + getType(): String
  + builder(): AbstractTriggerForExecutionBuilder<?, ?>
  + toBuilder(): AbstractTriggerForExecutionBuilder<?, ?>
  + of(AbstractTrigger): AbstractTriggerForExecution
}
class AbstractTriggerRepositoryTest {
  - TEST_NAMESPACE: String
  # triggerRepository: TriggerRepositoryInterface
  - trigger(): TriggerBuilder<?, ?>
  ~ all(): void
}
class AbstractValidateCommand {
  # local: boolean
  # directory: Path
  + buildYamlBody(Path): String
  + handleHttpException(HttpClientResponseException, String): void
  + handleValidateConstraintViolation(ValidateConstraintViolation, String): void
  + call(Class<?>, YamlFlowParser, ModelValidator, Function<Object, String>, Function<Object, List<String>>): Integer
  + handleException(ConstraintViolationException, String): void
}
class AbstractWorkerThread {
  ~ runContext: RunContext
  ~ type: String
  ~ logger: Logger
  ~ killed: boolean
  ~ taskState: Type
  - classLoader: ClassLoader
  - shutdownLatch: CountDownLatch
  ~ exception: Throwable
  # exceptionHandler(Thread, Throwable): void
  + getRunContext(): RunContext
  + getType(): String
  + getTaskState(): Type
  + getException(): Throwable
  + run(): void
  # signalStop(): void
  # kill(boolean): void
  # doRun(): void
  + kill(): void
  + awaitStop(Duration): boolean
}
class AbstractWorkerTriggerThread {
  ~ workerTrigger: WorkerTrigger
  - AWAIT_ON_KILL: Duration
  + signalStop(): void
  + getWorkerTrigger(): WorkerTrigger
  # kill(boolean): void
}
class AliasTest {
  ~ taskAlias(): void
  ~ triggerAlias(): void
}
class AllowFailure {
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + toString(): String
  + builder(): AllowFailureBuilder<?, ?>
  + resolveState(RunContext, Execution, TaskRun): Optional<Type>
}
class AllowFailureTest {
  - flowIO: FlowInputOutput
  - control(Execution): void
  ~ success(): void
  ~ failed(): void
}
class ApiController {
  # basePath: String
  # getBasePath(): String
  + rapidoc(): HttpResponse<?>
  # getSwaggerFilename(): String
}
class App {
  # execute(Class<?>, String[]): void
  - isPracticalCommand(CommandLine): boolean
  + main(String[]): void
  - getPropertiesFromMethod(Class<?>, String, Object): T?
  # applicationContext(Class<?>, String[]): ApplicationContext
  + call(): Integer
}
class AppTest {
  ~ testHelp(): void
  ~ testServerCommandHelp(String): void
}
class Application {
  + main(String[]): void
}
class ArrayInput {
  - itemType: Type
  + getItemType(): Type
  + builder(): ArrayInputBuilder<?, ?>
  + validate(List<?>): void
}
annotation ArrayInputValidation << annotation >> {
  + payload(): Class<Payload>[]
  + groups(): Class<?>[]
  + message(): String
}
class ArrayInputValidator {
  + isValid(ArrayInput, AnnotationValue<ArrayInputValidation>, ConstraintValidatorContext): boolean
}
class ArrayListTotal<T> {
  - total: long
  - serialVersionUID: long
  + of(Pageable, List<T>): ArrayListTotal<T>
  + getTotal(): long
  + map(Function<T, R>): ArrayListTotal<R>
}
class AuthUtils {
  + encodePassword(String, String): String
  + generateSalt(): String
}
class AuthenticationFilter {
  - PREFIX: String
  - ORDER: Integer
  - basicAuthService: BasicAuthService
  + getOrder(): int
  - isManagementEndpoint(HttpRequest<?>): boolean
  + doFilter(HttpRequest<?>, ServerFilterChain): Publisher<MutableHttpResponse<?>>
}
class AuthenticationFilterTest {
  - basicAuthConfiguration: BasicAuthConfiguration
  - client: ReactorHttpClient
  ~ testAuthenticated(): void
  ~ testUnauthorized(): void
  ~ testAnonymous(): void
  ~ testManagementEndpoint(): void
}
class AutocompleteUtils {
  + map(Function<T, R>, List<T>[]): List<R>
  + from(List<T>[]): List<T>
}
class Await {
  - defaultSleep: Duration
  + until(BooleanSupplier): void
  + until(Supplier<T>, Duration): T
  + until(BooleanSupplier, Duration): void
  - untilSupplier(Supplier<T>, AtomicReference<T>): BooleanSupplier
  + until(Supplier<String>, BooleanSupplier, Duration, Duration): void
  + until(Supplier<T>, Duration, Duration): T
  + until(BooleanSupplier, Duration, Duration): void
}
class Backfill {
  - inputs: Map<String, Object>
  ~ end: ZonedDateTime
  ~ start: ZonedDateTime
  ~ previousNextExecutionDate: ZonedDateTime
  ~ currentDate: ZonedDateTime
  ~ paused: Boolean
  ~ labels: List<Label>
  + getLabels(): List<Label>
  + getStart(): ZonedDateTime
  + getEnd(): ZonedDateTime
  + getCurrentDate(): ZonedDateTime
  + getPaused(): Boolean
  + getInputs(): Map<String, Object>
  + getPreviousNextExecutionDate(): ZonedDateTime
  - $default$paused(): Boolean
  + toBuilder(): BackfillBuilder<?, ?>
  + builder(): BackfillBuilder<?, ?>
}
class BadExecutable {
  + createSubflowExecutionResult(RunContext, TaskRun, Flow, Execution): Optional<SubflowExecutionResult>
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + toString(): String
  + builder(): BadExecutableBuilder<?, ?>
}
class BadExecutableTest {
  ~ badExecutable(): void
}
class BadFlowableTest {
  ~ flowableWithParentFail(): void
  ~ sequential(): void
}
class BadSequential {
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + toString(): String
  + builder(): BadSequentialBuilder<?, ?>
  + resolveState(RunContext, Execution, TaskRun): Optional<Type>
}
class Base64Render
class BasicAuthEndpointsFilter {
  - endpointBasicAuthConfiguration: EndpointBasicAuthConfiguration
  + getOrder(): int
  + doFilter(HttpRequest<?>, ServerFilterChain): Publisher<MutableHttpResponse<?>>
  - validateUser(HttpRequest<?>): boolean
}
class BasicAuthEndpointsFilterTest {
  ~ withoutPasswordOk(): void
  ~ test(boolean, BiConsumer<ReactorHttpClient, MutableHttpRequest<String>>): void
  ~ withPasswordOk(): void
  ~ withPasswordKo(): void
}
class BasicAuthService {
  - EMAIL_PASSWORD_MAX_LEN: int
  - ossAuthEventPublisher: ApplicationEventPublisher<OssAuthEvent>
  + BASIC_AUTH_SETTINGS_KEY: String
  - settingRepository: SettingRepositoryInterface
  - basicAuthConfiguration: BasicAuthConfiguration
  - instanceService: InstanceService
  - EMAIL_PATTERN: Pattern
  + save(String, BasicAuthConfiguration): void
  + save(BasicAuthConfiguration): void
  + isEnabled(): boolean
  + configuration(): SaltedBasicAuthConfiguration
  + unsecure(): void
  - init(): void
}
class BasicAuthServiceTest {
  - ctx: ApplicationContext
  - basicAuthService: BasicAuthService
  - instanceService: InstanceService
  - basicAuthConfiguration: BasicAuthConfiguration
  - settingRepositoryInterface: SettingRepositoryInterface
  - awaitOssAuthEventApiCall(String): void
  ~ stopApp(): void
  ~ unsecure(): void
  ~ initFromYamlConfig(): void
  ~ mockEventsAndStartApp(): void
  - assertConfigurationMatchesApplicationYaml(): void
  ~ secure(): void
}
class BlueprintController {
  - httpClient: HttpClient
  + blueprint(String, HttpRequest<?>): BlueprintItemWithFlow
  + blueprintTags(Optional<String>, HttpRequest<?>): List<BlueprintTagItem>
  # fastForwardToKestraApi(HttpRequest<?>, String, Argument<T>): T
  + blueprints(Optional<String>, Optional<String>, Optional<List<String>>, Integer, Integer, HttpRequest<?>): PagedResults<BlueprintItem>
  + blueprintGraph(String, HttpRequest<?>): Map<String, Object>
  + blueprintFlow(String, HttpRequest<?>): String
  - fastForwardToKestraApi(HttpRequest<?>, String, Map<String, Object>, Argument<T>): T
}
class BlueprintControllerTest {
  ~ client: HttpClient
  ~ blueprintFlow(WireMockRuntimeInfo): void
  ~ blueprints(WireMockRuntimeInfo): void
  ~ blueprintGraph(WireMockRuntimeInfo): void
  ~ blueprintTags(WireMockRuntimeInfo): void
  ~ blueprint(WireMockRuntimeInfo): void
}
class BooleanInput {
  + builder(): BooleanInputBuilder<?, ?>
  + validate(Boolean): void
}
class BulkErrorResponse {
  ~ invalids: Object
  ~ message: String
  + getMessage(): String
  + getInvalids(): Object
  + builder(): BulkErrorResponseBuilder<?, ?>
}
class BulkResponse {
  ~ count: Integer
  + getCount(): Integer
  + builder(): BulkResponseBuilder<?, ?>
}
interface ChildFlowInterface << interface >> {
  + getNamespace(): String
  + getFlowId(): String
}
class ChunkFilter {
  + getArgumentNames(): List<String>
  + apply(Object, Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
}
class ChunkFilterTest {
  ~ variableRenderer: VariableRenderer
  ~ out(): void
  ~ exception(): void
}
class ClassInputDocumentation {
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + toString(): String
  + of(JsonSchemaGenerator, Class<Input>): ClassInputDocumentation
}
class ClassNameFilter {
  + getArgumentNames(): List<String>
  + apply(Object, Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
}
class ClassPluginDocumentation<T> {
  - icon: String
  # docLicense: String
  - docMetrics: List<MetricDoc>
  - outputs: Map<String, Object>
  - outputsSchema: Map<String, Object>
  - pluginTitle: String
  - replacement: String
  - group: String
  - subGroup: String
  + hashCode(): int
  + equals(Object): boolean
  # canEqual(Object): boolean
  + getIcon(): String
  + getGroup(): String
  + getDocLicense(): String
  + getPluginTitle(): String
  + getSubGroup(): String
  + toString(): String
  + getOutputsSchema(): Map<String, Object>
  + getReplacement(): String
  + getDocMetrics(): List<MetricDoc>
  + getOutputs(): Map<String, Object>
  + of(JsonSchemaGenerator, RegisteredPlugin, Class<T>, Class<T>, String): ClassPluginDocumentation<T>
  + of(JsonSchemaGenerator, RegisteredPlugin, Class<T>, Class<T>): ClassPluginDocumentation<T>
}
class ClassPluginDocumentationTest {
  ~ taskRunner(): void
  ~ tasks(): void
  ~ dynamicProperty(): void
  ~ trigger(): void
}
class CollectorScheduler {
  # collectorService: CollectorService
  - log: Logger
  + report(): void
}
class CollectorService {
  # kestraUrl: String
  # url: URI
  - defaultUsage: Usage
  - log: Logger
  - executionRepository: ExecutionRepositoryInterface
  # UUID: String
  # serverType: ServerType
  - flowRepository: FlowRepositoryInterface
  # versionProvider: VersionProvider
  # client: ReactorHttpClient
  # applicationContext: ApplicationContext
  # instanceService: InstanceService
  # pluginRegistry: PluginRegistry
  + metrics(boolean): Usage
  - handleResponse(Result): void
  # request(Usage): MutableHttpRequest<Usage>
  + metrics(boolean, ZonedDateTime, ZonedDateTime): Usage
  # defaultUsage(): Usage
  + report(): void
}
class CollectorServiceTest {
  + metrics(): void
}
class CommandsWrapper {
  - logConsumer: AbstractLogConsumer
  - env: Map<String, String>
  - runnerType: RunnerType
  - commands: List<String>
  - outputDirectory: Path
  - targetOS: TargetOS
  - runContext: RunContext
  - enableOutputDirectory: Boolean
  - additionalVars: Map<String, Object>
  - warningOnStdErr: Boolean
  - workingDirectory: Path
  - containerImage: String
  - namespaceFiles: NamespaceFiles
  - outputFiles: List<String>
  - timeout: Duration
  - taskRunner: TaskRunner
  - dockerOptions: DockerOptions
  - inputFiles: Object
  + getWorkingDirectory(): Path
  + getRunContext(): RunContext
  + getWarningOnStdErr(): Boolean
  + withNamespaceFiles(NamespaceFiles): CommandsWrapper
  + getDockerOptions(): DockerOptions
  + withDockerOptions(DockerOptions): CommandsWrapper
  + withCommands(List<String>): CommandsWrapper
  + getAdditionalVars(): Map<String, Object>
  + getCommands(): List<String>
  + withEnableOutputDirectory(Boolean): CommandsWrapper
  + getOutputFiles(): List<String>
  + withTaskRunner(TaskRunner): CommandsWrapper
  + withTargetOS(TargetOS): CommandsWrapper
  + withLogConsumer(AbstractLogConsumer): CommandsWrapper
  + withWarningOnStdErr(Boolean): CommandsWrapper
  + withTimeout(Duration): CommandsWrapper
  + getTargetOS(): TargetOS
  + getEnv(): Map<String, String>
  + getLogConsumer(): AbstractLogConsumer
  + getRunnerType(): RunnerType
  + getInputFiles(): Object
  + withOutputFiles(List<String>): CommandsWrapper
  + getTimeout(): Duration
  + withRunnerType(RunnerType): CommandsWrapper
  + withContainerImage(String): CommandsWrapper
  + withInputFiles(Object): CommandsWrapper
  + getNamespaceFiles(): NamespaceFiles
  + getContainerImage(): String
  + render(RunContext, String, List<String>): String
  + run(): ScriptOutput
  + addEnv(Map<String, String>): CommandsWrapper
  + getEnableOutputDirectory(): Boolean
  + addAdditionalVars(Map<String, Object>): CommandsWrapper
  + render(RunContext, List<String>): List<String>
  + getOutputDirectory(): Path
  + withEnv(Map<String, String>): CommandsWrapper
  + getTaskRunner(): TaskRunner
}
class Concat {
  - files: Object
  - extension: String
  - separator: String
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getFiles(): Object
  + getSeparator(): String
  + getExtension(): String
  + toString(): String
  - $default$extension(): String
  + builder(): ConcatBuilder<?, ?>
  + run(RunContext): Output
}
class ConcatTest {
  ~ runContextFactory: RunContextFactory
  ~ storageInterface: StorageInterface
  ~ list(): void
  ~ run(Boolean): void
  ~ json(): void
}
class Concurrency {
  - behavior: Behavior
  - limit: Integer
  + getLimit(): Integer
  + getBehavior(): Behavior
  - $default$behavior(): Behavior
  + builder(): ConcurrencyBuilder<?, ?>
}
class Condition {
  # type: String
  + getType(): String
}
class ConditionContext {
  - flow: Flow
  - execution: Execution
  - runContext: RunContext
  - variables: Map<String, Object>
  - multipleConditionStorage: MultipleConditionStorageInterface
  + getFlow(): Flow
  + getExecution(): Execution
  + getRunContext(): RunContext
  + getVariables(): Map<String, Object>
  + getMultipleConditionStorage(): MultipleConditionStorageInterface
  - $default$variables(): Map<String, Object>
  + builder(): ConditionContextBuilder
  + withRunContext(RunContext): ConditionContext
  + withVariables(Map<String, Object>): ConditionContext
}
class ConditionService {
  - runContextFactory: RunContextFactory
  + conditionContext(RunContext, Flow, Execution, MultipleConditionStorageInterface): ConditionContext
  + isValid(List<ScheduleCondition>, ConditionContext): boolean
  + findValidListeners(Flow, Execution): List<ResolvedTask>
  + isValid(AbstractTrigger, Flow, Execution, MultipleConditionStorageInterface): boolean
  + conditionContext(RunContext, Flow, Execution): ConditionContext
  + isValid(Condition, Flow, Execution): boolean
  - logException(Flow, Object, ConditionContext, Exception): void
  + isValid(Flow, AbstractTrigger, ConditionContext): boolean
  + isTerminatedWithListeners(Flow, Execution): boolean
  ~ valid(Flow, List<Condition>, ConditionContext): boolean
  + areValid(List<Condition>, ConditionContext): boolean
  + isValid(Condition, Flow, Execution, MultipleConditionStorageInterface): boolean
}
class ConditionServiceTest {
  - logQueue: QueueInterface<LogEntry>
  ~ runContextFactory: RunContextFactory
  ~ conditionService: ConditionService
  ~ exception(): void
  ~ valid(): void
}
class ConfigCommand {
  - log: Logger
  + call(): Integer
}
class ConfigPropertiesCommand {
  - applicationContext: ApplicationContext
  - log: Logger
  + call(): Integer
}
class ConfigPropertiesCommandTest {
  ~ run(): void
}
class ConfigurationUsage {
  - repositoryType: String
  - queueType: String
  - javaSecurityEnabled: Boolean
  - secretType: String
  - storageType: String
  + getRepositoryType(): String
  + getQueueType(): String
  + getStorageType(): String
  + getSecretType(): String
  + getJavaSecurityEnabled(): Boolean
  + builder(): ConfigurationUsageBuilder<?, ?>
  + of(ApplicationContext): ConfigurationUsage
  + of(String, ApplicationContext): ConfigurationUsage
}
class Constant {
  # type: String
  - interval: Duration
  + getType(): String
  + getInterval(): Duration
  - $default$type(): String
  + builder(): ConstantBuilder<?, ?>
  + nextRetryDate(Integer, Instant): Instant
  + toPolicy(): RetryPolicyBuilder<T>
}
class Count {
  # states: List<Type>
  # endDate: String
  # flows: List<Flow>
  # startDate: String
  # expression: String
  + getEndDate(): String
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getFlows(): List<Flow>
  + getStates(): List<Type>
  + getStartDate(): String
  + getExpression(): String
  + builder(): CountBuilder<?, ?>
  + toString(): String
  + run(RunContext): Output
}
class Counter {
  - type: String
  - value: Double
  + TYPE: String
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getType(): String
  + getValue(): Double
  + toString(): String
  + of(String, Double, String[]): Counter
  + of(String, Long, String[]): Counter
  + of(String, Integer, String[]): Counter
  + increment(Double): void
  + register(MetricRegistry, String, Map<String, String>): void
  + of(String, Float, String[]): Counter
}
class Cpu {
  - cpus: Long
  + getCpus(): Long
  + builder(): CpuBuilder<?, ?>
}
class Credentials {
  - username: String
  - auth: String
  - registryToken: String
  - registry: String
  - password: String
  - identityToken: String
  + getRegistry(): String
  + getUsername(): String
  + getPassword(): String
  + getRegistryToken(): String
  + getIdentityToken(): String
  + getAuth(): String
  + builder(): CredentialsBuilder<?, ?>
}
class CrudEvent<T> {
  ~ model: T
  ~ request: HttpRequest<?>
  ~ type: CrudEventType
  ~ previousModel: T
  + getModel(): T
  + getPreviousModel(): T
  + getType(): CrudEventType
  + getRequest(): HttpRequest<?>
}
enum CrudEventType << enumeration >> {
  + LOGOUT:
  + READ:
  + CREATE:
  + LOGIN:
  + UPDATE:
  + IMPERSONATE:
  + DELETE:
  + valueOf(String): CrudEventType
  + values(): CrudEventType[]
}
class CurrentEachOutputFunction {
  + getArgumentNames(): List<String>
  + execute(Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
}
class CurrentEachOutputFunctionTest {
  ~ parallel(): void
}
class Dag {
  - concurrent: Integer
  - tasks: List<DagTask>
  # errors: List<Task>
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getConcurrent(): Integer
  + getTasks(): List<DagTask>
  + getErrors(): List<Task>
  + toString(): String
  - $default$concurrent(): Integer
  + builder(): DagBuilder<?, ?>
  + dagCheckCyclicDependencies(List<DagTask>): ArrayList<String>
  + resolveNexts(RunContext, Execution, TaskRun): List<NextTaskRun>
  + childTasks(RunContext, TaskRun): List<ResolvedTask>
  - controlTask(): void
  + allChildTasks(): List<Task>
  + tasksTree(Execution, TaskRun, List<String>): GraphCluster
  - nestedDependencies(DagTask, List<DagTask>, List<String>): ArrayList<String>
  + dagCheckNotExistTask(List<DagTask>): List<String>
}
annotation DagTaskValidation << annotation >> {
  + groups(): Class<?>[]
  + message(): String
  + payload(): Class<Payload>[]
}
class DagTaskValidator {
  + isValid(Dag, AnnotationValue<DagTaskValidation>, ConstraintValidatorContext): boolean
}
class DagTest {
  ~ yamlFlowParser: YamlFlowParser
  ~ modelValidator: ModelValidator
  - parse(String): Flow
  ~ dagNotExistTask(): void
  ~ dag(): void
  ~ dagCyclicDependencies(): void
}
class DailyExecutionStatistics {
  # startDate: Instant
  - groupBy: String
  - duration: Duration
  - executionCounts: Map<Type, Long>
  + getExecutionCounts(): Map<Type, Long>
  + getStartDate(): Instant
  - $default$executionCounts(): Map<Type, Long>
  + getDuration(): Duration
  + builder(): DailyExecutionStatisticsBuilder
  + getGroupBy(): String
  + setStartDate(Instant): void
  + setDuration(Duration): void
  + setExecutionCounts(Map<Type, Long>): void
  + setGroupBy(String): void
  + toString(): String
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
}
interface Data << interface >> {
  + toConstraintViolationException(String, Object): ConstraintViolationException
  + getType(): Type
  + getId(): String
}
class Data<T> {
  - fromMap: Property<Map<String, Object>>
  - fromURI: Property<URI>
  - fromList: Property<List<Map<String, Object>>>
  + getFromURI(): Property<URI>
  + getFromMap(): Property<Map<String, Object>>
  + getFromList(): Property<List<Map<String, Object>>>
  + builder(): DataBuilder<T>
  + ifFromURI(RunContext, Consumer<URI>): void
  + ifFromList(RunContext, Consumer<List<Map<String, Object>>>): void
  + isFromList(): boolean
  + flux(RunContext, Class<T>, Function<Map<String, Object>, T>): Flux<T>
  + ofList(List<Map<String, Object>>): Data<?>
  + ofMap(Map<String, Object>): Data<?>
  + ofURI(URI): Data<?>
  + isFromURI(): boolean
  + isFromMap(): boolean
  + ifFromMap(RunContext, Consumer<Map<String, Object>>): void
}
annotation DataValidation << annotation >> {
  + payload(): Class<Payload>[]
  + groups(): Class<?>[]
  + message(): String
}
class DataValidationTest {
  - modelValidator: ModelValidator
  ~ invalid(): void
  ~ valid(): void
}
class DataValidator {
  + isValid(Data, AnnotationValue<DataValidation>, ConstraintValidatorContext): boolean
}
class DatabaseCommand {
  + call(): Integer
}
class DatabaseCommandTest {
  ~ runWithNoParam(): void
}
class DatabaseMigrateCommand {
  - log: Logger
  + call(): Integer
  + propertiesOverrides(): Map<String, Object>
}
class DatasourceProvider {
  + getDatasourceConfiguration(): CustomDatasourceConfiguration
  + getFlywayConfiguration(): CustomFlywayConfiguration
}
class DateAddFilter {
  + getArgumentNames(): List<String>
  + apply(Object, Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
}
class DateFilter {
  + apply(Object, Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
}
class DateFilterTest {
  + NOW: ZonedDateTime
  - variableRenderer: VariableRenderer
  ~ instantmicro(): void
  ~ dateStringFormat(): void
  ~ timestamp(): void
  ~ dateRfc(): void
  ~ now(): void
  ~ dateFormat(): void
  ~ instantnano(): void
  ~ add(): void
  ~ timestampCompare(): void
}
annotation DateFormat << annotation >> {
  + groups(): Class<?>[]
  + message(): String
  + payload(): Class<Payload>[]
}
class DateFormatTest {
  - modelValidator: ModelValidator
  ~ formatSource(): Stream<Arguments>
  ~ format(String, String, String, Boolean, int): void
}
class DateFormatValidator {
  + isValid(String, AnnotationValue<DateFormat>, ConstraintValidatorContext): boolean
}
class DateInput {
  ~ before: LocalDate
  ~ after: LocalDate
  + getAfter(): LocalDate
  + getBefore(): LocalDate
  + builder(): DateInputBuilder<?, ?>
  + validate(LocalDate): void
}
class DateTimeBetweenCondition {
  - date: String
  - after: ZonedDateTime
  - before: ZonedDateTime
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getDate(): String
  + getAfter(): ZonedDateTime
  + getBefore(): ZonedDateTime
  + toString(): String
  - $default$date(): String
  + builder(): DateTimeBetweenConditionBuilder<?, ?>
  + test(ConditionContext): boolean
}
class DateTimeBetweenConditionTest {
  ~ conditionService: ConditionService
  ~ source(): Stream<Arguments>
  ~ valid(String, ZonedDateTime, ZonedDateTime, boolean): void
}
class DateTimeInput {
  ~ after: Instant
  ~ before: Instant
  + getAfter(): Instant
  + getBefore(): Instant
  + builder(): DateTimeInputBuilder<?, ?>
  + validate(Instant): void
}
class DateUtils {
  + parseOffsetTime(String): OffsetTime
  + parseLocalDate(String): LocalDate
  + validateTimeline(ZonedDateTime, ZonedDateTime): void
  + parseZonedDateTime(String): ZonedDateTime
  + groupByType(Duration): GroupType
}
class DayWeekCondition {
  - date: String
  - dayOfWeek: DayOfWeek
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getDate(): String
  + getDayOfWeek(): DayOfWeek
  + toString(): String
  - $default$date(): String
  + builder(): DayWeekConditionBuilder<?, ?>
  + test(ConditionContext): boolean
}
class DayWeekConditionTest {
  ~ conditionService: ConditionService
  ~ source(): Stream<Arguments>
  ~ valid(String, DayOfWeek, boolean): void
}
class DayWeekInMonthCondition {
  - dayOfWeek: DayOfWeek
  - date: String
  - dayInMonth: DayInMonth
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getDate(): String
  + getDayOfWeek(): DayOfWeek
  + getDayInMonth(): DayInMonth
  + toString(): String
  - $default$date(): String
  + builder(): DayWeekInMonthConditionBuilder<?, ?>
  + test(ConditionContext): boolean
}
class DayWeekInMonthConditionTest {
  ~ conditionService: ConditionService
  ~ valid(String, DayOfWeek, DayInMonth, boolean): void
  ~ source(): Stream<Arguments>
}
class Debug {
  - LOGGER: Logger
  - MAPPER: ObjectMapper
  - NAME: String
  + toJson(T): String
  - caller(): String
  + log(T[]): void
}
class DecryptFunction {
  + getArgumentNames(): List<String>
  + execute(Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
}
class DeduplicateItems {
  - from: String
  - expr: String
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getFrom(): String
  + getExpr(): String
  + toString(): String
  + builder(): DeduplicateItemsBuilder<?, ?>
  - getKeyExtractor(RunContext): PebbleFieldExtractor
  + run(RunContext): Output
  - newBufferedReader(RunContext, URI): BufferedReader
}
class DeduplicateItemsTest {
  ~ storageInterface: StorageInterface
  ~ runContextFactory: RunContextFactory
  - generateKeyValueFile(List<?>, RunContext): URI
  ~ shouldDeduplicateFileGivenKeyExpressionReturningArray(): void
  - assertSimpleCompactedFile(RunContext, Output, List<T>, Class<T>): void
  ~ shouldDeduplicateFileGivenKeyExpression(): void
}
class DefaultFileRender {
  - truncateStringSize(String): String
  - renderContent(InputStream, Charset): void
}
class DefaultFileRenderTest {
  ~ testTruncatedByLineCount(int, boolean): void
  ~ testTruncatedBySize(int, boolean): void
}
class DefaultFlowExecutor {
  - allFlows: List<Flow>
  - flowRepository: FlowRepositoryInterface
  + findById(String, String, String, Optional<Integer>): Optional<Flow>
  + setAllFlows(List<Flow>): void
  + allLastVersion(): Collection<Flow>
  + isReady(): Boolean
}
class DefaultLogConsumer {
  - runContext: RunContext
  + accept(String, Boolean): void
}
class DefaultPluginRegistry {
  - initialized: AtomicBoolean
  - pluginClassByIdentifier: Map<PluginIdentifier, Class<Plugin>>
  - scannedPluginPaths: Set<Path>
  - plugins: Map<PluginBundleIdentifier, RegisteredPlugin>
  - scanner: PluginScanner
  - isInitialized(): boolean
  + findClassByIdentifier(PluginIdentifier): Class<Plugin>
  + plugins(Predicate<RegisteredPlugin>): List<RegisteredPlugin>
  + register(Path): void
  + unregister(RegisteredPlugin): void
  + plugins(): List<RegisteredPlugin>
  + clear(): void
  - containsPluginBundle(PluginBundleIdentifier): boolean
  - isPluginPathValid(Path): boolean
  + register(RegisteredPlugin): void
  + findClassByIdentifier(String): Class<Plugin>
  # init(): void
  + externalPlugins(): List<RegisteredPlugin>
  - isPluginPathScanned(Path): boolean
  + getOrCreate(): DefaultPluginRegistry
  + registerIfAbsent(Path): void
}
class DefaultRunContext {
  - workingDir: WorkingDir
  - variableRenderer: VariableRenderer
  - pluginConfiguration: Map<String, Object>
  - applicationContext: ApplicationContext
  - triggerExecutionId: String
  - storage: Storage
  - meterRegistry: MetricRegistry
  - logger: RunContextLogger
  - secretKey: Optional<String>
  - dynamicWorkerTaskResult: List<WorkerTaskResult>
  - version: Provider<VersionProvider>
  - metrics: List<AbstractMetricEntry<?>>
  - variables: Map<String, Object>
  - kvStoreService: KVStoreService
  - isInitialized: AtomicBoolean
  + render(Map<String, Object>, Map<String, Object>): Map<String, Object>
  + decrypt(String): String
  + render(String, Map<String, Object>): String
  ~ setPluginConfiguration(Map<String, Object>): void
  - metricsTags(): Map<String, String>
  + workingDir(): WorkingDir
  + render(List<String>): List<String>
  + version(): String
  + flowInfo(): FlowInfo
  + getTriggerExecutionId(): String
  ~ init(ApplicationContext): void
  + logFileURI(): URI
  + getVariables(): Map<String, Object>
  ~ setWorkingDir(WorkingDir): void
  ~ setVariables(Map<String, Object>): void
  + metric(AbstractMetricEntry<T>): RunContext
  + dynamicWorkerResult(List<WorkerTaskResult>): void
  + clone(): DefaultRunContext
  + tenantId(): String
  + namespaceKv(String): KVStore
  + cleanup(): void
  + pluginConfiguration(String): Optional<T>
  + metrics(): List<AbstractMetricEntry<?>>
  + render(String): String
  + getStorageOutputPrefix(): URI
  + encrypt(String): String
  + render(Map<String, Object>): Map<String, Object>
  ~ setLogger(RunContextLogger): void
  + render(List<String>, Map<String, Object>): List<String>
  + renderMap(Map<String, String>): Map<String, String>
  + logger(): Logger
  ~ setTriggerExecutionId(String): void
  ~ setStorage(Storage): void
  + renderMap(Map<String, String>, Map<String, Object>): Map<String, String>
  + renderTyped(String): Object
  - metricPrefix(): String?
  + dynamicWorkerResults(): List<WorkerTaskResult>
  + getApplicationContext(): ApplicationContext
  + render(Set<String>, Map<String, Object>): Set<String>
  + storage(): Storage
  + pluginConfigurations(): Map<String, Object>
  + render(Set<String>): Set<String>
}
class DefaultRunContextTest {
  ~ applicationContext: ApplicationContext
  ~ shouldGetKestraVersion(): void
}
class Delete {
  - uri: String
  - errorOnMissing: Boolean
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getUri(): String
  + getErrorOnMissing(): Boolean
  + toString(): String
  - $default$errorOnMissing(): Boolean
  + builder(): DeleteBuilder<?, ?>
  + run(RunContext): Output
}
class Delete {
  - key: String
  - errorOnMissing: boolean
  - namespace: String
  + getKey(): String
  + getNamespace(): String
  + isErrorOnMissing(): boolean
  - $default$namespace(): String
  - $default$errorOnMissing(): boolean
  + builder(): DeleteBuilder<?, ?>
  + toBuilder(): DeleteBuilder<?, ?>
  + run(RunContext): Output
}
class Delete {
  - errorOnMissing: Boolean
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getErrorOnMissing(): Boolean
  + toString(): String
  - $default$errorOnMissing(): Boolean
  + builder(): DeleteBuilder<?, ?>
  + run(RunContext): Output
}
class DeleteConfigurationApplicationListeners {
  - log: Logger
  ~ environment: Environment
  + onStartupEvent(StartupEvent): void
}
class DeleteConfigurationApplicationListenersTest {
  ~ run(): void
}
class DeleteFiles {
  - namespace: String
  - files: Object
  + getNamespace(): String
  + getFiles(): Object
  + builder(): DeleteFilesBuilder<?, ?>
  + run(RunContext): Output
}
class DeleteFilesTest {
  ~ storageInterface: StorageInterface
  ~ runContextFactory: RunContextFactory
  ~ shouldDeleteNamespaceFilesForMatchingExpression(): void
}
class DeleteTest {
  ~ runContextFactory: RunContextFactory
  ~ TEST_KV_KEY: String
  ~ shouldOutputTrueGivenExistingKey(): void
  ~ shouldOutputFalseGivenNonExistingKey(): void
}
class DeleteTest {
  ~ storageInterface: StorageInterface
  ~ runContextFactory: RunContextFactory
  ~ run(): void
}
interface DeletedInterface << interface >> {
  + isDeleted(): boolean
}
entity DependsOn << record >> {
  - inputs: List<String>?
  - condition: String?
  + condition(): String?
  + inputs(): List<String>?
}
class DeprecatedTask {
  - additionalProperty: String
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getAdditionalProperty(): String
  + toString(): String
  + builder(): DeprecatedTaskBuilder<?, ?>
}
class DeserializationException {
  - serialVersionUID: long
  - record: String
  + getRecord(): String
}
class DeserializationIssuesCaseTest {
  - INVALID_WORKER_TASK_KEY: String
  # workerTaskResultQueue: QueueInterface<WorkerTaskResult>
  + INVALID_SUBFLOW_EXECUTION_KEY: String
  - flowListeners: FlowListenersInterface
  - INVALID_WORKER_TASK_VALUE: String
  - INVALID_FLOW_KEY: String
  # workerTriggerResultQueue: QueueInterface<WorkerTriggerResult>
  - INVALID_WORKER_TRIGGER_VALUE: String
  + INVALID_SUBFLOW_EXECUTION_VALUE: String
  - INVALID_WORKER_TRIGGER_KEY: String
  - INVALID_FLOW_VALUE: String
  + flowDeserializationIssue(Consumer<QueueMessage>): void
  + workerTriggerDeserializationIssue(Consumer<QueueMessage>): void
  + workerTaskDeserializationIssue(Consumer<QueueMessage>): void
}
class DeviceRequest {
  - driver: String
  - count: Integer
  - deviceIds: List<String>
  - options: Map<String, String>
  - capabilities: List<List<String>>
  + getDriver(): String
  + getCount(): Integer
  + getDeviceIds(): List<String>
  + getCapabilities(): List<List<String>>
  + getOptions(): Map<String, String>
  + builder(): DeviceRequestBuilder<?, ?>
}
interface DisabledInterface << interface >> {
  + isDisabled(): boolean
}
class DisabledTest {
  ~ error(): void
  ~ flowable(): void
  ~ simple(): void
}
class Docker {
  - LEGACY_VOLUME_ENABLED_CONFIG: String
  - fileHandlingStrategy: FileHandlingStrategy
  # cpu: Cpu
  # memory: Memory
  # pullPolicy: PullPolicy
  - credentials: Credentials
  # deviceRequests: List<DeviceRequest>
  # extraHosts: List<String>
  - host: String
  # entryPoint: List<String>
  - READABLE_BYTES_TYPE_CONVERTER: ReadableBytesTypeConverter
  # networkMode: String
  - VOLUME_ENABLED_CONFIG: String
  - config: Object
  # volumes: List<String>
  - delete: Boolean
  - NEWLINE_PATTERN: Pattern
  # image: String
  # user: String
  - shmSize: String
  + getConfig(): Object
  + equals(Object): boolean
  + getVolumes(): List<String>
  + toString(): String
  + getPullPolicy(): PullPolicy
  - $default$entryPoint(): List<String>
  - $default$fileHandlingStrategy(): FileHandlingStrategy
  # canEqual(Object): boolean
  + getDeviceRequests(): List<DeviceRequest>
  + hashCode(): int
  + getHost(): String
  + getMemory(): Memory
  + getDelete(): Boolean
  + getNetworkMode(): String
  - $default$delete(): Boolean
  + getShmSize(): String
  - $default$pullPolicy(): PullPolicy
  + getCredentials(): Credentials
  + toBuilder(): DockerBuilder<?, ?>
  + builder(): DockerBuilder<?, ?>
  + getImage(): String
  + getCpu(): Cpu
  + getUser(): String
  + getExtraHosts(): List<String>
  + getEntryPoint(): List<String>
  + getFileHandlingStrategy(): FileHandlingStrategy
  + run(RunContext, TaskCommands, List<String>): RunnerResult
  - kill(DockerClient, String, Logger): void
  + instance(): Docker
  - dockerClient(RunContext, String): DockerClient
  + from(DockerOptions): Docker
  - pullImage(DockerClient, String, PullPolicy, Logger): void
  + runnerAdditionalVars(RunContext, TaskCommands): Map<String, Object>
  - convertBytes(String): Long
  - configure(TaskCommands, DockerClient, RunContext, Map<String, Object>): CreateContainerCmd
}
class DockerOptions {
  - shmSize: String
  # deviceRequests: List<DeviceRequest>
  # entryPoint: List<String>
  # image: String
  - host: String
  - config: Object
  # user: String
  # extraHosts: List<String>
  # cpu: Cpu
  # volumes: List<String>
  # pullPolicy: PullPolicy
  # memory: Memory
  # networkMode: String
  - credentials: Credentials
  + getHost(): String
  + getConfig(): Object
  + getCredentials(): Credentials
  - $default$pullPolicy(): PullPolicy
  + getImage(): String
  + getUser(): String
  + getDeviceRequests(): List<DeviceRequest>
  + builder(): DockerOptionsBuilder<?, ?>
  + getEntryPoint(): List<String>
  + toBuilder(): DockerOptionsBuilder<?, ?>
  + getMemory(): Memory
  + getExtraHosts(): List<String>
  + getNetworkMode(): String
  + getShmSize(): String
  + getPullPolicy(): PullPolicy
  + getVolumes(): List<String>
  + getCpu(): Cpu
  + setDockerConfig(String): void
  + setDockerHost(String): void
}
class DockerService {
  + findHost(RunContext, String): String
  + client(DockerClientConfig): DockerClient
  + createConfig(RunContext, Object?, List<Credentials>?, String?): Path
  + registryUrlFromImage(String): String
}
class DockerTest {
  # taskRunner(): TaskRunner
}
class Document {
  - path: String
  - body: String
  - icon: String
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getPath(): String
  + getBody(): String
  + getIcon(): String
  + toString(): String
}
class DocumentationGenerator {
  - pebbleEngine: PebbleEngine
  ~ jsonSchemaGenerator: JsonSchemaGenerator
  - generate(RegisteredPlugin, List<Class<T>>, Class<T>, String): List<Document>
  - index(RegisteredPlugin): List<Document>
  - indexGroupedClass(RegisteredPlugin): Map<SubGroup, Map<String, List<ClassPlugin>>>
  + render(ClassPluginDocumentation<T>): String
  + render(AbstractClassDocumentation<T>): String
  - docPath(RegisteredPlugin): String
  - guides(RegisteredPlugin): List<Document>
  + generate(RegisteredPlugin): List<Document>
  + render(String, Map<String, Object>): String
  - docPath(RegisteredPlugin, String, ClassPluginDocumentation<T>): String
}
class DocumentationGeneratorTest {
  ~ jsonSchemaGenerator: JsonSchemaGenerator
  ~ documentationGenerator: DocumentationGenerator
  ~ echo(): void
  ~ taskRunner(): void
  ~ defaultBool(): void
  ~ returnDoc(): void
  ~ dag(): void
  ~ state(): void
  - assertRequiredPropsAreFirst(String): void
  ~ pluginDoc(): void
  ~ tasks(): void
  ~ pluginEeDoc(): void
}
class DocumentationWithSchema {
  ~ schema: Schema
  ~ markdown: String
  + getMarkdown(): String
  + getSchema(): Schema
  + setMarkdown(String): void
  + setSchema(Schema): void
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + toString(): String
}
class Download {
  - failOnEmptyResponse: Boolean
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getFailOnEmptyResponse(): Boolean
  + toString(): String
  - $default$failOnEmptyResponse(): Boolean
  + builder(): DownloadBuilder<?, ?>
  - filenameFromHeader(RunContext, String): String?
  + run(RunContext): Output
  - filenameFromURI(URI): String?
}
class DownloadFiles {
  - namespace: String
  - files: Object
  - log: Logger
  - destination: String
  + getNamespace(): String
  + getFiles(): Object
  + getDestination(): String
  - $default$destination(): String
  + builder(): DownloadFilesBuilder<?, ?>
  + run(RunContext): Output
}
class DownloadFilesTest {
  ~ storageInterface: StorageInterface
  ~ runContextFactory: RunContextFactory
  ~ shouldDownloadNamespaceFile(): void
}
class DownloadTest {
  - storageInterface: StorageInterface
  - applicationContext: ApplicationContext
  + FILE: String
  - runContextFactory: RunContextFactory
  ~ error(): void
  ~ contentDisposition(): void
  ~ run(): void
  ~ allowNoResponse(): void
  ~ noResponse(): void
}
class DurationInput {
  ~ max: Duration
  ~ min: Duration
  + getMin(): Duration
  + getMax(): Duration
  + builder(): DurationInputBuilder<?, ?>
  + validate(Duration): void
}
class DurationOrSizeTrigger<V> {
  - batchSize: int
  - next: Instant
  - batchDuration: Duration
  ~ getNext(): Instant
  + test(Collection<V>): boolean
  - nextDate(): void
}
class DurationOrSizeTriggerTest {
  - batchDuration: Duration
  - trigger: DurationOrSizeTrigger<String>
  + testBySize(): void
  + testByDuration(): void
  + testByDurationAndSize(): void
  - generateHashMap(int): HashMap<String, String>
}
class DynamicPropertyExampleTask {
  - number: Property<Integer>
  - items: Property<List<String>>
  - properties: Property<Map<String, String>>
  - withDefault: Property<String>
  - data: Data<Message>
  - level: Property<Level>
  - string: Property<String>
  - someDuration: Property<Duration>
  + equals(Object): boolean
  # canEqual(Object): boolean
  + getProperties(): Property<Map<String, String>>
  + hashCode(): int
  - $default$level(): Property<Level>
  + builder(): DynamicPropertyExampleTaskBuilder<?, ?>
  + toString(): String
  + getNumber(): Property<Integer>
  + getString(): Property<String>
  + getWithDefault(): Property<String>
  + getLevel(): Property<Level>
  + getSomeDuration(): Property<Duration>
  + getItems(): Property<List<String>>
  - $default$withDefault(): Property<String>
  + getData(): Data<Message>
  + run(RunContext): Output
}
class DynamicTask {
  - fail: Boolean
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getFail(): Boolean
  + toString(): String
  - $default$fail(): Boolean
  + builder(): DynamicTaskBuilder<?, ?>
  + toBuilder(): DynamicTaskBuilder<?, ?>
  + run(RunContext): VoidOutput
}
class EachParallel {
  - value: Object
  - concurrent: Integer
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getConcurrent(): Integer
  + getValue(): Object
  + toString(): String
  - $default$concurrent(): Integer
  + builder(): EachParallelBuilder<?, ?>
  + resolveNexts(RunContext, Execution, TaskRun): List<NextTaskRun>
  + tasksTree(Execution, TaskRun, List<String>): GraphCluster
  + childTasks(RunContext, TaskRun): List<ResolvedTask>
  + resolveState(RunContext, Execution, TaskRun): Optional<Type>
}
class EachParallelTest {
  ~ parallel(): void
  ~ parallelNested(): void
  ~ parallelInteger(): void
}
class EachSequential {
  - value: Object
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getValue(): Object
  + toString(): String
  + builder(): EachSequentialBuilder<?, ?>
  + tasksTree(Execution, TaskRun, List<String>): GraphCluster
  + childTasks(RunContext, TaskRun): List<ResolvedTask>
  + resolveNexts(RunContext, Execution, TaskRun): List<NextTaskRun>
  + resolveState(RunContext, Execution, TaskRun): Optional<Type>
}
class EachSequentialTest {
  ~ logQueue: QueueInterface<LogEntry>
  ~ eachEmpty(): void
  + eachNullTest(RunnerUtils, QueueInterface<LogEntry>): void
  ~ eachSwitch(): void
  ~ objectInList(): void
  ~ object(): void
  ~ eachNull(): void
  ~ sequential(): void
  ~ sequentialNested(): void
}
class Echo {
  - format: String
  - level: Level
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getFormat(): String
  + getLevel(): Level
  + toString(): String
  - $default$level(): Level
  + builder(): EchoBuilder<?, ?>
  + run(RunContext): VoidOutput
}
class Either<L, R> {
  - right: Optional<R>
  - left: Optional<L>
  + getLeft(): L
  + right(R): Either<L, R>
  + isLeft(): boolean
  + isRight(): boolean
  + getRight(): R
  + left(L): Either<L, R>
}
class EmptyVariablesTest {
  - flowIO: FlowInputOutput
  ~ emptyVariables(): void
}
class EncryptDecryptFunctionTest {
  - secretKey: String
  - variableRenderer: VariableRenderer
  ~ missingParameter(): void
  ~ encryptDecrypt(): void
}
class EncryptFunction {
  + getArgumentNames(): List<String>
  + execute(Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
}
class Encrypted {
  - format: String
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getFormat(): String
  + toString(): String
  + builder(): EncryptedBuilder<?, ?>
  + run(RunContext): Output
}
class EncryptedString {
  - value: String
  - type: String
  + TYPE: String
  + from(String): EncryptedString
  + from(String, RunContext): EncryptedString
  + getValue(): String
  + getType(): String
}
class EncryptionService {
  - SECURE_RANDOM: SecureRandom
  - CIPHER_ALGORITHM: String
  - IV_LENGTH: int
  - KEY_ALGORITHM: String
  - AUTH_TAG_LENGTH: int
  + decrypt(String, byte[]): byte[]
  - generateIv(): byte[]
  + encrypt(String, String): String
  + decrypt(String, String): String
  + encrypt(String, byte[]): byte[]
}
class EncryptionServiceTest {
  - KEY: String
  ~ avoidNpeForEmptyOrNullText(): void
  ~ encryptAndDecryptByteArray(): void
  ~ encryptAndDecryptString(): void
}
class EndpointBasicAuthConfiguration {
  ~ username: String
  ~ password: String
  + getUsername(): String
  + getPassword(): String
}
class EndsWithFilter {
  + FILTER_NAME: String
  - ARGS: List<String>
  - ARGUMENT_VALUE: String
  + getArgumentNames(): List<String>
  + apply(Object, Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
}
class EndsWithFilterTest {
  ~ variableRenderer: VariableRenderer
  ~ out(): void
}
class EnumInput {
  ~ values: List<String>
  + getValues(): List<String>
  + builder(): EnumInputBuilder<?, ?>
  + validate(String): void
}
class Enums {
  + getForNameIgnoreCase(String?, Class<T>): T
  + getForNameIgnoreCase(String?, Class<T>, Map<String, T>): T
}
class EnumsTest {
  ~ shouldThrowExceptionGivenInvalidString(): void
  ~ shouldGetEnumForNameIgnoreCaseForExisting(): void
  ~ shouldGetEnumForNameIgnoreCaseForFallback(): void
}
class ErrorController {
  - log: Logger
  + error(HttpRequest<?>, ConversionErrorException): HttpResponse<JsonError>
  + jsonError(HttpRequest<?>, Throwable, HttpStatus, String): HttpResponse<JsonError>
  + error(HttpRequest<?>, IllegalArgumentException): HttpResponse<JsonError>
  + error(HttpRequest<?>, Throwable): HttpResponse<JsonError>
  + serialization(HttpRequest<?>, ResourceExpiredException): HttpResponse<JsonError>
  + notFound(HttpRequest<?>): HttpResponse<JsonError>
  + httpClient(HttpRequest<?>, HttpClientResponseException): HttpResponse<JsonError>
  + notFound(HttpRequest<?>, UnsatisfiedQueryValueRouteException): HttpResponse<JsonError>
  - jsonError(JsonError, HttpStatus, String): HttpResponse<JsonError>
  + serialization(HttpRequest<?>, DeserializationException): HttpResponse<JsonError>
  + notFound(HttpRequest<?>, FileNotFoundException): HttpResponse<JsonError>
  + error(HttpRequest<?>, JsonParseException): HttpResponse<JsonError>
  - path(JsonMappingException): String
  + error(HttpRequest<?>, InvalidException): HttpResponse<JsonError>
  + error(HttpRequest<?>, InvalidFormatException): HttpResponse<JsonError>
  + error(HttpRequest<?>, HttpStatusException): HttpResponse<JsonError>
  + jsonError(HttpRequest<?>, HttpStatus, String): HttpResponse<JsonError>
  + error(HttpRequest<?>, UnsatisfiedBodyRouteException): HttpResponse<JsonError>
  + notFound(HttpRequest<?>, NoSuchElementException): HttpResponse<JsonError>
  + error(HttpRequest<?>, IllegalStateException): HttpResponse<JsonError>
  + error(HttpRequest<?>, ConstraintViolationException): HttpResponse<JsonError>
}
class ErrorControllerTest {
  ~ client: ReactorHttpClient
  ~ unknownProperties(): void
  ~ invalidEnum(): void
  ~ type(): void
}
class EscapeCharFilter {
  - ARG_NAME: String
  - argumentNames: List<String>
  + apply(Object, Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
  - processMap(Map<String, Object>, Map<String, Object>, PebbleTemplate, int): Object
  - argsToType(Map<String, Object>, PebbleTemplate, int): FilterType
  - escapeString(String, Map<String, Object>, PebbleTemplate, int): String
  + getArgumentNames(): List<String>
  - processList(List<Object>, Map<String, Object>, PebbleTemplate, int): Object
  - escape(String, String, String): String
}
class EscapeCharFilterTest {
  - variableRenderer: VariableRenderer
  - provideValidTypes(): Stream<Arguments>
  ~ validTypes(String, String, String): void
  ~ invalidTypes(String): void
}
class Event {
  # counter: Integer
  # type: EventType
  # uid: String
  # iid: String
  # date: Instant
  + getType(): EventType
  + getIid(): String
  + getUid(): String
  + getDate(): Instant
  + getCounter(): Integer
}
annotation Example << annotation >> {
  + title(): String
  + code(): String[]
  + lang(): String
  + full(): boolean
}
annotation Examples << annotation >> {
  + value(): Example[]
}
interface ExecutableTask<T> << interface >> {
  + waitForExecution(): boolean
  + createSubflowExecutionResult(RunContext, TaskRun, Flow, Execution): Optional<SubflowExecutionResult>
  + createSubflowExecutions(RunContext, FlowExecutorInterface, Flow, Execution, TaskRun): List<SubflowExecution<?>>
  + subflowId(): SubflowId
}
class ExecutableUtils {
  - log: Logger
  + TASK_VARIABLE_SUBFLOW_OUTPUTS_BASE_URI: String
  + TASK_VARIABLE_ITERATIONS: String
  + TASK_VARIABLE_NUMBER_OF_BATCHES: String
  + guessState(Execution, boolean, boolean): Type
  - findTerminalState(Map<String, Integer>, boolean): Type
  + subflowExecution(RunContext, FlowExecutorInterface, Execution, Flow, T, TaskRun, Map<String, Object>, List<Label>, Property<ZonedDateTime>): SubflowExecution<?>
  + subflowExecutionResult(TaskRun, Execution): SubflowExecutionResult
  + manageIterations(Storage, TaskRun, Execution, boolean, boolean): TaskRun
}
class Execution {
  - inputs: Map<String, Object>
  - metadata: ExecutionMetadata
  - deleted: boolean
  - flowId: String
  - log: Logger
  - id: String
  - state: State
  - tenantId: String
  - namespace: String
  - labels: List<Label>
  - parentId: String
  - variables: Map<String, Object>
  - taskRunList: List<TaskRun>
  - originalId: String
  - scheduleDate: Instant
  - outputs: Map<String, Object>
  - flowRevision: Integer
  - trigger: ExecutionTrigger
  + equals(Object): boolean
  + withInputs(Map<String, Object>): Execution
  + withTrigger(ExecutionTrigger): Execution
  + getInputs(): Map<String, Object>
  + toString(): String
  # canEqual(Object): boolean
  + getLabels(): List<Label>
  + withTaskRunList(List<TaskRun>): Execution
  + getVariables(): Map<String, Object>
  + hashCode(): int
  + getState(): State
  + isDeleted(): boolean
  + getScheduleDate(): Instant
  + getOutputs(): Map<String, Object>
  + withFlowRevision(Integer): Execution
  + getTrigger(): ExecutionTrigger
  + withMetadata(ExecutionMetadata): Execution
  + withScheduleDate(Instant): Execution
  + withOutputs(Map<String, Object>): Execution
  + withTenantId(String): Execution
  + getTenantId(): String
  + getId(): String
  + getNamespace(): String
  + getFlowId(): String
  + getParentId(): String
  + getFlowRevision(): Integer
  + getMetadata(): ExecutionMetadata
  + withVariables(Map<String, Object>): Execution
  - $default$deleted(): boolean
  + getTaskRunList(): List<TaskRun>
  + getOriginalId(): String
  + toBuilder(): ExecutionBuilder
  + withLabels(List<Label>): Execution
  + builder(): ExecutionBuilder
  + newExecution(Flow, List<Label>): Execution
  + withTaskRun(TaskRun): Execution
  + findParentsValues(TaskRun, boolean): List<String>
  + hasCreated(List<ResolvedTask>): boolean
  - outputs(TaskRun, Map<String, TaskRun>): Map<String, Object>
  + findParents(TaskRun): List<TaskRun>
  + findLastCreated(List<TaskRun>): Optional<TaskRun>
  + hasFailedNoRetry(List<ResolvedTask>, TaskRun): boolean
  + guessFinalState(List<ResolvedTask>, TaskRun, boolean): Type
  + hasWarning(List<ResolvedTask>, TaskRun): boolean
  + findLastByState(List<TaskRun>, Type): Optional<TaskRun>
  + hasCreated(List<ResolvedTask>, TaskRun): boolean
  + hasFailed(List<ResolvedTask>, TaskRun): boolean
  + childExecution(String, List<TaskRun>, State): Execution
  + findLastNotTerminated(): Optional<TaskRun>
  - findParents(TaskRun, Map<String, TaskRun>): List<TaskRun>
  - newAttemptsTaskRunForFailedExecution(TaskRun, Exception): FailedTaskRunWithLog
  + toStringState(): String
  + findTaskDependingFlowState(List<ResolvedTask>, List<ResolvedTask>): List<ResolvedTask>
  + hasCreated(): boolean
  + findTaskRunByTaskRunId(String): TaskRun
  + guessFinalState(Flow): Type
  + findTaskRunByTasks(List<ResolvedTask>, TaskRun): List<TaskRun>
  + findTaskDependingFlowState(List<ResolvedTask>): List<ResolvedTask>
  + parents(TaskRun): List<Map<String, Object>>
  + isTerminated(List<ResolvedTask>, TaskRun): boolean
  + findFirstRunning(): Optional<TaskRun>
  + hasFailed(List<ResolvedTask>): boolean
  + findTaskDependingFlowState(List<ResolvedTask>, List<ResolvedTask>, TaskRun): List<ResolvedTask>
  + toDeleted(): Execution
  + isTerminated(List<ResolvedTask>): boolean
  + outputs(): Map<String, Object>
  + hasRunning(List<ResolvedTask>): boolean
  + hasRunning(List<ResolvedTask>, TaskRun): boolean
  + hasTaskRunJoinable(TaskRun): boolean
  + findLastTerminated(List<TaskRun>): Optional<TaskRun>
  + toCrc32State(): Long
  + hasWarning(): boolean
  + findTaskRunsByTaskId(String): List<TaskRun>
  + findTaskRunByTaskIdAndValue(String, List<String>): TaskRun
  + withState(Type): Execution
  + hasWarning(List<ResolvedTask>): boolean
  + findLastRunning(List<TaskRun>): Optional<TaskRun>
  + hasFailed(): boolean
  + failedExecutionFromExecutor(Exception): FailedExecutionWithLog
  + toString(boolean): String
  + findFirstByState(Type): Optional<TaskRun>
  + loggingEventFromException(Exception): ILoggingEvent
  - removeDisabled(List<ResolvedTask>): List<ResolvedTask>
  - lastAttemptsTaskRunForFailedExecution(TaskRun, TaskRunAttempt, Exception): FailedTaskRunWithLog
  + newExecution(Flow, BiFunction<Flow, Execution, Map<String, Object>>, List<Label>, Optional<ZonedDateTime>): Execution
}
class ExecutionController {
  - graphService: GraphService
  # executionQueue: QueueInterface<Execution>
  - log: Logger
  - eventPublisher: ApplicationEventPublisher<CrudEvent<Execution>>
  - flowService: FlowService
  - storageInterface: StorageInterface
  - executionService: ExecutionService
  - conditionService: ConditionService
  - runContextFactory: RunContextFactory
  - tenantService: TenantService
  - flowRepository: FlowRepositoryInterface
  - maxPreviewRows: Integer
  # killQueue: QueueInterface<ExecutionKilled>
  - flowInputOutput: FlowInputOutput
  - kestraUrl: Optional<String>
  # basePath: String
  # executionRepository: ExecutionRepositoryInterface
  - initialPreviewRows: Integer
  + replay(String, String, Integer): Execution
  + restartByQuery(String, List<FlowScope>, String, String, ZonedDateTime, ZonedDateTime, Duration, List<Type>, List<String>, String, ChildFilter): HttpResponse<BulkResponse>
  + changeStatus(String, Type): Execution
  + changeStatusByQuery(String, List<FlowScope>, String, String, ZonedDateTime, ZonedDateTime, Duration, List<Type>, List<String>, String, ChildFilter, Type): HttpResponse<?>
  + setLabels(String, List<Label>): HttpResponse<?>
  ~ resolveAbsoluteDateTime(ZonedDateTime, Duration, ZonedDateTime): ZonedDateTime
  + filePreview(String, URI, Integer, String): HttpResponse<?>
  + validateInputsOnCreate(String, String, MultipartBody, List<String>, Optional<Integer>): Publisher<ApiValidateExecutionInputsResponse>
  - executionUrl(Execution): URI
  + getFlowForExecution(String, String, Integer): FlowForExecution
  + deleteByIds(List<String>, Boolean, Boolean, Boolean, Boolean): MutableHttpResponse<?>
  + killByIds(List<String>): MutableHttpResponse<?>
  + replayByIds(List<String>): MutableHttpResponse<?>
  + getFlowsByNamespace(String): List<FlowForExecution>
  + flowGraph(String, List<String>): FlowGraph
  + create(String, String, MultipartBody, List<String>, Boolean, Optional<Integer>, Optional<ZonedDateTime>): Publisher<ExecutionResponse>
  + changeStatusById(List<String>, Type): HttpResponse<?>
  # validateFile(String, URI, String): HttpResponse<T>
  + replayByQuery(String, List<FlowScope>, String, String, ZonedDateTime, ZonedDateTime, Duration, List<Type>, List<String>, String, ChildFilter): HttpResponse<?>
  + killByQuery(String, List<FlowScope>, String, String, ZonedDateTime, ZonedDateTime, Duration, List<Type>, List<String>, String, ChildFilter): HttpResponse<?>
  + webhookTriggerPost(String, String, String, HttpRequest<String>): HttpResponse<Execution>
  + file(String, URI): HttpResponse<StreamedFile>
  + deleteByQuery(String, List<FlowScope>, String, String, ZonedDateTime, ZonedDateTime, Duration, List<Type>, List<String>, String, ChildFilter, Boolean, Boolean, Boolean, Boolean): HttpResponse<BulkResponse>
  + restartByIds(List<String>): MutableHttpResponse<?>
  - setLabels(Execution, List<Label>): Execution
  + webhookTriggerGet(String, String, String, HttpRequest<String>): HttpResponse<Execution>
  # runContextRender(Flow, Task, Execution, TaskRun, String): String
  + setLabelsByIds(SetLabelsByIdsRequest): MutableHttpResponse<?>
  + kill(String, Boolean): HttpResponse<?>
  - isStopFollow(Flow, Execution): boolean
  + find(int, int, List<String>, String, List<FlowScope>, String, String, ZonedDateTime, ZonedDateTime, Duration, List<Type>, List<String>, String, ChildFilter): PagedResults<Execution>
  + getTenant(): String
  + resumeByQuery(String, List<FlowScope>, String, String, ZonedDateTime, ZonedDateTime, Duration, List<Type>, List<String>, String, ChildFilter): HttpResponse<?>
  + changeState(String, StateRequest): Execution
  + getFlowForExecutionById(String): FlowForExecution
  + resumeByIds(List<String>): MutableHttpResponse<?>
  # webhook(Optional<Flow>, String, HttpRequest<String>): HttpResponse<Execution>
  + setLabelsByQuery(String, List<FlowScope>, String, String, ZonedDateTime, ZonedDateTime, Duration, List<Type>, List<String>, String, ChildFilter, List<Label>): HttpResponse<?>
  - parseLabels(List<String>): List<Label>
  + filesize(String, URI): HttpResponse<FileMetas>
  + resume(String, MultipartBody): Publisher<HttpResponse<?>>
  - webhook(String, String, String, HttpRequest<String>): HttpResponse<Execution>
  + follow(String): Flux<Event<Execution>>
  + listDistinctNamespace(): List<String>
  + delete(String, Boolean, Boolean, Boolean): HttpResponse<Void>
  + findByFlowId(String, String, int, int): PagedResults<Execution>
  + validateInputsOnResume(String, MultipartBody): Publisher<ApiValidateExecutionInputsResponse>
  + webhookTriggerPut(String, String, String, HttpRequest<String>): HttpResponse<Execution>
  + trigger(String, String, MultipartBody, List<String>, Boolean, Optional<Integer>): Publisher<ExecutionResponse>
  - controlRevision(Execution, Integer): void
  + eval(String, String, String): EvalResult
  + restart(String, Integer): Execution
  + get(String): Execution
}
class ExecutionControllerTest {
  ~ client: ReactorHttpClient
  # killQueue: QueueInterface<ExecutionKilled>
  ~ flowRepositoryInterface: FlowRepositoryInterface
  + inputs: Map<String, Object>
  ~ executionController: ExecutionController
  ~ sseClient: ReactorSseClient
  ~ executionRepositoryInterface: ExecutionRepositoryInterface
  - flowIO: FlowInputOutput
  + URL_LABEL_VALUE: String
  # executionQueue: QueueInterface<Execution>
  + TESTS_WEBHOOK_KEY: String
  + ENCODED_URL_LABEL_VALUE: String
  + TESTS_FLOW_NS: String
  ~ shouldHaveAnUrlWhenCreated(): void
  ~ setLabelsByQuery(): void
  ~ replayByIds(): void
  ~ find(): void
  ~ eval(): void
  ~ getNotFound(): void
  - triggerExecution(String, String, MultipartBody, Boolean): Execution
  ~ kill(): void
  ~ downloadFile(): void
  ~ restartFromTaskId(): void
  ~ resumePausedWithInputs(): void
  ~ resumePaused(): void
  ~ commaInOneOfMultiLabels(): void
  ~ trigger(): void
  ~ getFlowFromNamespace(): void
  ~ restartWithNoFailure(): void
  ~ resumeByIds(): void
  ~ changeStatusByIds(): void
  ~ restartFromTaskIdWithSequential(): void
  ~ resolveAbsoluteDateTime(): void
  ~ changeStatusByQuery(): void
  ~ resumeByQuery(): void
  - eval(Execution, String, int): EvalResult
  ~ evalKeepEncryptedValues(): void
  ~ webhookDynamicKey(): void
  ~ webhookFlowNotFound(): void
  ~ restartFromLastFailed(): void
  ~ scheduleDate(): void
  ~ getDistinctNamespaceExecutables(): void
  ~ webhookDynamicKeyFromASecret(): void
  ~ invalidInputs(): void
  ~ deleteByQuery(): void
  ~ getFlowForExecutionById(): void
  ~ killPaused(): void
  ~ webhookWithCondition(): void
  ~ findByFlowId(): void
  ~ changeStatus(): void
  ~ setLabels(): void
  ~ shouldValidateInputsForCreateGivenSimpleInputs(): void
  ~ commaInSingleLabelsValue(): void
  ~ triggerAndFollow(): void
  ~ triggerAndWait(): void
  ~ delete(): void
  ~ badDate(): void
  ~ nullLabels(): void
  ~ webhook(): void
  ~ replayByQuery(): void
  - createInputsFlowBody(): MultipartBody
  - triggerInputsFlowExecution(Boolean): Execution
  ~ get(): void
  ~ restartFromUnknownTaskId(): void
  ~ setLabelsByIds(): void
  ~ restartFromLastFailedWithPause(): void
  ~ filePreview(): void
  ~ getFlowForExecution(): void
  ~ deleteByIds(): void
}
class ExecutionCount {
  - namespace: String
  - count: Long
  - flowId: String
  + getNamespace(): String
  + getFlowId(): String
  + getCount(): Long
  + equals(Object): boolean
  + hashCode(): int
  + toString(): String
}
entity ExecutionCountStatistics << record >> {
  - DEFAULT_COUNTS: Map<Type, Long>
  - total: Long
  - counts: Map<Type, Long>
  + counts(): Map<Type, Long>
  + total(): Long
  + compareTo(ExecutionCountStatistics): int
  - withAllStatesZero(Map<Type, Long>): Map<Type, Long>
}
class ExecutionDelay {
  - date: Instant
  - taskRunId: String
  - state: Type
  - delayType: DelayType
  - executionId: String
  + builder(): ExecutionDelayBuilder
  + getTaskRunId(): String
  + getExecutionId(): String
  + getDate(): Instant
  + getState(): Type
  + equals(Object): boolean
  + hashCode(): int
  + toString(): String
  + getDelayType(): DelayType
  + uid(): String
}
class ExecutionFixture {
  + EXECUTION_1: Execution
  + EXECUTION_2: Execution
}
class ExecutionFlowCondition {
  - flowId: String
  - namespace: String
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getNamespace(): String
  + getFlowId(): String
  + toString(): String
  + builder(): ExecutionFlowConditionBuilder<?, ?>
  + test(ConditionContext): boolean
}
class ExecutionFlowConditionTest {
  ~ conditionService: ConditionService
  ~ valid(): void
  ~ notValid(): void
}
class ExecutionKilled {
  ~ state: State
  # tenantId: String
  + uid(): String
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getState(): State
  + getTenantId(): String
  + toString(): String
  + getType(): String
}
class ExecutionKilledExecution {
  ~ executionId: String
  ~ isOnKillCascade: Boolean
  # type: String
  # canEqual(Object): boolean
  + equals(Object): boolean
  + hashCode(): int
  + getType(): String
  + getExecutionId(): String
  + getIsOnKillCascade(): Boolean
  + toString(): String
  - $default$type(): String
  + builder(): ExecutionKilledExecutionBuilder<?, ?>
  + uid(): String
  + isEqual(WorkerTask): boolean
}
class ExecutionKilledTrigger {
  ~ namespace: String
  ~ triggerId: String
  ~ flowId: String
  # type: String
  # canEqual(Object): boolean
  + equals(Object): boolean
  + hashCode(): int
  + getType(): String
  + getNamespace(): String
  + getFlowId(): String
  + getTriggerId(): String
  + toString(): String
  + builder(): ExecutionKilledTriggerBuilder<?, ?>
  - $default$type(): String
  + isEqual(TriggerContext): boolean
  + uid(): String
}
class ExecutionLabelsCondition {
  ~ labels: List<Label>
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getLabels(): List<Label>
  + toString(): String
  + builder(): ExecutionLabelsConditionBuilder<?, ?>
  + test(ConditionContext): boolean
}
class ExecutionLabelsConditionTest {
  ~ conditionService: ConditionService
  ~ valid(): void
  ~ validMultiples(): void
  ~ invalid(): void
  ~ invalidMultiples(): void
}
class ExecutionMetadata {
  ~ attemptNumber: Integer
  ~ originalCreatedDate: Instant
  + getAttemptNumber(): Integer
  + getOriginalCreatedDate(): Instant
  + setAttemptNumber(Integer): void
  + setOriginalCreatedDate(Instant): void
  - $default$attemptNumber(): Integer
  + builder(): ExecutionMetadataBuilder
  + toBuilder(): ExecutionMetadataBuilder
  + withAttemptNumber(Integer): ExecutionMetadata
  + nextAttempt(): ExecutionMetadata
}
class ExecutionNamespaceCondition {
  - comparison: Comparison
  - namespace: String
  - prefix: boolean
  + toString(): String
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getNamespace(): String
  + getComparison(): Comparison
  + builder(): ExecutionNamespaceConditionBuilder<?, ?>
  + isPrefix(): boolean
  - $default$prefix(): boolean
  + test(ConditionContext): boolean
}
class ExecutionNamespaceConditionTest {
  ~ conditionService: ConditionService
  ~ suffix(): void
  ~ comparisonMismatchShouldPreferComparisonProperty(): void
  ~ invalid(): void
  ~ defaultBehaviour(): void
  ~ valid(): void
  ~ prefix(): void
}
class ExecutionOutputsCondition {
  - TRIGGER_VAR: String
  - OUTPUTS_VAR: String
  - expression: String
  + test(ConditionContext): boolean
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getExpression(): String
  + toString(): String
  + builder(): ExecutionOutputsConditionBuilder<?, ?>
  - hasNoOutputs(Execution): boolean
}
class ExecutionOutputsConditionTest {
  ~ conditionService: ConditionService
  ~ shouldEvaluateToTrueGivenValidExpression(): void
  ~ shouldEvaluateToFalseGivenInvalidExpression(): void
  ~ shouldEvaluateToFalseGivenExecutionWithNoOutputs(): void
}
class ExecutionQueued {
  - flowId: String
  - date: Instant
  - tenantId: String
  - namespace: String
  - execution: Execution
  + builder(): ExecutionQueuedBuilder
  + getTenantId(): String
  + getNamespace(): String
  + getFlowId(): String
  + getExecution(): Execution
  + getDate(): Instant
  + equals(Object): boolean
  + hashCode(): int
  + toString(): String
  + fromExecutionRunning(ExecutionRunning): ExecutionQueued
  + uid(): String
}
interface ExecutionRepositoryInterface << interface >> {
  + findById(String, String): Optional<Execution>
  + findByFlowId(String, String, String, Pageable): ArrayListTotal<Execution>
  + lastExecutions(String?, List<FlowFilter>?): List<Execution>
  + findTaskRun(Pageable, String?, String?, String?, String?, ZonedDateTime?, ZonedDateTime?, List<Type>?, Map<String, String>?, String?, ChildFilter?): ArrayListTotal<TaskRun>
  + isTaskRunEnabled(): Boolean
  + findById(String, String, boolean): Optional<Execution>
  + update(Execution): Execution
  + purge(Execution): Integer
  + find(String?, String?, List<FlowScope>?, String?, String?, ZonedDateTime?, ZonedDateTime?, List<Type>?, Map<String, String>?, String?, ChildFilter?): Flux<Execution>
  + dailyStatistics(String?, String?, List<FlowScope>?, String?, String?, ZonedDateTime?, ZonedDateTime?, GroupType?, List<Type>, boolean): List<DailyExecutionStatistics>
  + save(Execution): Execution
  + find(String?, String?, List<FlowScope>?, String?, String?, ZonedDateTime?, ZonedDateTime?, List<Type>?, Map<String, String>?, String?, ChildFilter?, boolean): Flux<Execution>
  + dailyStatisticsForAllTenants(String?, String?, String?, ZonedDateTime?, ZonedDateTime?, GroupType?, boolean): List<DailyExecutionStatistics>
  + findAllByTriggerExecutionId(String, String): Flux<Execution>
  + executionCountsGroupedByNamespace(String?, String?, ZonedDateTime?, ZonedDateTime?): Map<String, ExecutionCountStatistics>
  + dailyGroupByFlowStatistics(String?, String?, String?, String?, List<FlowFilter>?, ZonedDateTime?, ZonedDateTime?, boolean): Map<String, Map<String, List<DailyExecutionStatistics>>>
  + delete(Execution): Execution
  + maxTaskRunSetting(): Integer
  + executionCounts(String?, List<Flow>, List<Type>?, ZonedDateTime?, ZonedDateTime?): List<ExecutionCount>
  + sortMapping(): Function<String, String>
  + find(Pageable, String?, String?, List<FlowScope>?, String?, String?, ZonedDateTime?, ZonedDateTime?, List<Type>?, Map<String, String>?, String?, ChildFilter?): ArrayListTotal<Execution>
}
class ExecutionResumed {
  - taskRunId: String
  - state: Type
  - executionId: String
  + builder(): ExecutionResumedBuilder
  + getTaskRunId(): String
  + getExecutionId(): String
  + getState(): Type
  + equals(Object): boolean
  + hashCode(): int
  + toString(): String
  + uid(): String
}
class ExecutionRunning {
  - tenantId: String
  - concurrencyState: ConcurrencyState
  - namespace: String
  - flowId: String
  - execution: Execution
  + builder(): ExecutionRunningBuilder
  + getTenantId(): String
  + getNamespace(): String
  + getFlowId(): String
  + getExecution(): Execution
  + getConcurrencyState(): ConcurrencyState
  + equals(Object): boolean
  + hashCode(): int
  + toString(): String
  + withConcurrencyState(ConcurrencyState): ExecutionRunning
  + withExecution(Execution): ExecutionRunning
  + uid(): String
}
class ExecutionService {
  - executionRepository: ExecutionRepositoryInterface
  - metricRepository: MetricRepositoryInterface
  # executionQueue: QueueInterface<Execution>
  - eventPublisher: ApplicationEventPublisher<CrudEvent<Execution>>
  - flowRepositoryInterface: FlowRepositoryInterface
  - logRepository: LogRepositoryInterface
  - flowInputOutput: FlowInputOutput
  - storageInterface: StorageInterface
  - log: Logger
  + getExecutionIfPause(String, String): Execution
  + retryWaitFor(Execution, String): Execution
  + delete(Execution, boolean, boolean, boolean): void
  + validateForResume(Execution, Flow, Publisher<CompletedPart>): List<InputAndValue>
  + restart(Execution, Integer): Execution
  + resume(Execution, Flow, Type, Map<String, Object>): Execution
  + retryTask(Execution, String): Execution
  - mapTaskRun(Flow, TaskRun, Map<String, String>, String, Type, Boolean): TaskRun
  - markAs(Execution, Flow, String, Type, Map<String, Object>): Execution
  - getAncestors(Execution, TaskRun): Set<String>
  + purge(Boolean, Boolean, Boolean, Boolean, String, String, String, ZonedDateTime, ZonedDateTime, List<Type>): PurgeResult
  + killSubflowExecutions(String, String): Flux<ExecutionKilledExecution>
  + killParentTaskruns(TaskRun, Execution): Execution
  - taskRunWithAncestors(Execution, List<TaskRun>): Set<String>
  + kill(Execution, Flow): Execution
  - taskRunToRestart(Execution, Predicate<TaskRun>): Set<String>
  + markWithTaskRunAs(Execution, String, Type, Boolean): Execution
  - mapTaskRunId(Execution, boolean): Map<String, String>
  - removeWorkerTask(Flow, Execution, Set<String>, Map<String, String>): Set<String>
  + resume(Execution, Flow, Type): Execution
  + replay(Execution, String, Integer): Execution
  + resume(Execution, Flow, Type, Publisher<CompletedPart>): Execution
  + nextRetryDate(AbstractRetry, Execution): Instant
  + pauseFlowable(Execution, TaskRun): Execution
  + markAs(Execution, Flow, String, Type): Execution
  - getFirstPausedTaskOrThrow(Execution, Flow): Task
}
class ExecutionServiceTest {
  ~ flowRepository: FlowRepositoryInterface
  ~ executionService: ExecutionService
  ~ pluginDefaultService: PluginDefaultService
  ~ logRepository: LogRepositoryInterface
  ~ executionRepository: ExecutionRepositoryInterface
  ~ replayFlowable(): void
  ~ replayEachSeq(): void
  ~ deleteExecutionKeepLogs(): void
  ~ restartDynamic(): void
  ~ deleteExecution(): void
  ~ resumePausedToRunning(): void
  ~ markAsEachPara(): void
  ~ replayEachSeq2(): void
  ~ restartFlowable2(): void
  ~ restartSimpleRevision(): void
  ~ restartSimple(): void
  ~ replayParallel(): void
  ~ restartFlowable(): void
  ~ replayEachPara(): void
  ~ replaySimple(): void
  ~ resumePausedToKilling(): void
  ~ replayFromBeginning(): void
}
class ExecutionStatistics {
  - date: Instant
  - durationSum: Long
  - stateCurrent: String
  - durationMin: Long
  - durationMax: Long
  - count: Long
  + getDate(): Instant
  + getStateCurrent(): String
  + getCount(): Long
  + getDurationMin(): Long
  + hashCode(): int
  + setDurationMax(Long): void
  + setDurationSum(Long): void
  + equals(Object): boolean
  # canEqual(Object): boolean
  + getDurationMax(): Long
  + getDurationSum(): Long
  + setStateCurrent(String): void
  + setDate(Instant): void
  + toString(): String
  + builder(): ExecutionStatisticsBuilder
  + setCount(Long): void
  + setDurationMin(Long): void
}
class ExecutionStatusCondition {
  - in: List<Type>
  - notIn: List<Type>
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getIn(): List<Type>
  + getNotIn(): List<Type>
  + toString(): String
  + builder(): ExecutionStatusConditionBuilder<?, ?>
  + test(ConditionContext): boolean
}
class ExecutionStatusConditionTest {
  ~ conditionService: ConditionService
  ~ notIn(): void
  ~ in(): void
  ~ both(): void
}
class ExecutionTest {
  - TASK_RUN: TaskRunBuilder
  ~ hasTaskRunJoinableFailedExecutionFromExecutor(): void
  ~ originalId(): void
  ~ hasTaskRunJoinableAfterRestart(): void
  ~ hasTaskRunJoinableTrue(): void
  ~ hasTaskRunJoinableRestartFailed(): void
  ~ hasTaskRunJoinableRestartSuccess(): void
  ~ labels(): void
  ~ hasTaskRunJoinableSameState(): void
}
class ExecutionTrigger {
  - logFile: URI
  - id: String
  - type: String
  - variables: Map<String, Object>
  + of(AbstractTrigger, Output, URI): ExecutionTrigger
  + builder(): ExecutionTriggerBuilder
  + getId(): String
  + getType(): String
  + getVariables(): Map<String, Object>
  + getLogFile(): URI
  + equals(Object): boolean
  + hashCode(): int
  + toString(): String
  + of(AbstractTrigger, Map<String, Object>): ExecutionTrigger
  + of(AbstractTrigger, Map<String, Object>, URI): ExecutionTrigger
  + of(AbstractTrigger, Output): ExecutionTrigger
}
interface ExecutionUpdatableTask << interface >> {
  + update(Execution, RunContext): Execution
}
class ExecutionUsage {
  - dailyExecutionsCount: List<DailyExecutionStatistics>
  - dailyTaskRunsCount: List<DailyExecutionStatistics>
  + of(ExecutionRepositoryInterface, ZonedDateTime, ZonedDateTime): ExecutionUsage
  + getDailyExecutionsCount(): List<DailyExecutionStatistics>
  + getDailyTaskRunsCount(): List<DailyExecutionStatistics>
  + builder(): ExecutionUsageBuilder<?, ?>
  + of(String, ExecutionRepositoryInterface, ZonedDateTime, ZonedDateTime): ExecutionUsage
}
class Executor {
  - execution: Execution
  - joinedSubflowExecutionResult: SubflowExecutionResult
  - offset: Long
  - executionUpdated: boolean
  - executionRunning: ExecutionRunning
  - originalState: Type
  - subflowExecutions: List<SubflowExecution<?>>
  - joinedWorkerTaskResult: WorkerTaskResult
  - workerTriggers: List<WorkerTrigger>
  - workerTaskResults: List<WorkerTaskResult>
  - from: List<String>
  - nexts: List<TaskRun>
  - workerJobToResubmit: WorkerJob
  - flow: Flow
  - joinedExecutionResumed: ExecutionResumed
  - exception: Exception
  - subflowExecutionResults: List<SubflowExecutionResult>
  - workerTasks: List<WorkerTask>
  - executionDelays: List<ExecutionDelay>
  - executionKilled: List<ExecutionKilledExecution>
  - executionResumed: ExecutionResumed
  - seqId: long
  + withExecutionRunning(ExecutionRunning): Executor
  + getJoinedSubflowExecutionResult(): SubflowExecutionResult
  + getWorkerJobToResubmit(): WorkerJob
  + getExecution(): Execution
  + getException(): Exception
  + getExecutionRunning(): ExecutionRunning
  + getOriginalState(): Type
  + getWorkerTriggers(): List<WorkerTrigger>
  + getWorkerTasks(): List<WorkerTask>
  + getSubflowExecutionResults(): List<SubflowExecutionResult>
  + getFrom(): List<String>
  + getSeqId(): long
  + getOffset(): Long
  + isExecutionUpdated(): boolean
  + getSubflowExecutions(): List<SubflowExecution<?>>
  + getFlow(): Flow
  + getNexts(): List<TaskRun>
  + getExecutionResumed(): ExecutionResumed
  + getWorkerTaskResults(): List<WorkerTaskResult>
  + getExecutionDelays(): List<ExecutionDelay>
  + getExecutionKilled(): List<ExecutionKilledExecution>
  + getJoinedWorkerTaskResult(): WorkerTaskResult
  + getJoinedExecutionResumed(): ExecutionResumed
  + withExecution(Execution, String): Executor
  + withWorkerTasks(List<WorkerTask>, String): Executor
  + withExecutionKilled(List<ExecutionKilledExecution>): Executor
  + withWorkerTriggers(List<WorkerTrigger>, String): Executor
  + serialize(): Executor
  + withSubflowExecutions(List<SubflowExecution<?>>, String): Executor
  + incrementAndGetSeqId(): long
  + withExecutionResumed(ExecutionResumed): Executor
  + withWorkerTaskDelays(List<ExecutionDelay>, String): Executor
  + withTaskRun(List<TaskRun>, String): Executor
  + withWorkerTaskResults(List<WorkerTaskResult>, String): Executor
  + withFlow(Flow): Executor
  + withSubflowExecutionResults(List<SubflowExecutionResult>, String): Executor
  + canBeProcessed(): Boolean
  + withException(Exception, String): Executor
}
class ExecutorCommand {
  - skipFlows: List<String>
  - applicationContext: ApplicationContext
  - skipExecutionService: SkipExecutionService
  - skipTenants: List<String>
  - skipExecutions: List<String>
  - startExecutorService: StartExecutorService
  - skipNamespaces: List<String>
  - notStartExecutors: List<String>
  - log: Logger
  - startExecutors: List<String>
  + call(): Integer
  + propertiesOverrides(): Map<String, Object>
}
interface ExecutorInterface << interface >>
class ExecutorService {
  - conditionService: ConditionService
  - logService: LogService
  - runContextFactory: RunContextFactory
  - metricRegistry: MetricRegistry
  - flowInputOutput: FlowInputOutput
  - log: Logger
  # flowExecutorInterface: FlowExecutorInterface
  - executionService: ExecutionService
  - applicationContext: ApplicationContext
  - workerGroupExecutorInterface: WorkerGroupExecutorInterface
  + onNexts(Flow, Execution, List<TaskRun>): Execution
  - handleEnd(Executor): Executor
  + log(Logger, Boolean, WorkerTaskResult): void
  + checkConcurrencyLimit(Executor, Flow, Execution, long): Executor
  - saveFlowableOutput(List<NextTaskRun>, Executor): List<TaskRun>
  - childWorkerTaskResult(Flow, Execution, TaskRun): Optional<WorkerTaskResult>
  - childNextsTaskRun(Executor, TaskRun): List<TaskRun>
  - handleListeners(Executor): Executor
  - handleKilling(Executor): Executor
  - handlePausedDelay(Executor, List<WorkerTaskResult>): Executor
  + canBePurged(Executor): boolean
  - handleRestart(Executor): Executor
  - handleExecutableTask(Executor): Executor
  + log(Logger, Boolean, Executor): void
  - handleChildWorkerTaskResult(Executor): Executor
  - childWorkerTaskTypeToWorkerTask(Optional<Type>, TaskRun): Optional<WorkerTaskResult>
  + addDynamicTaskRun(Execution, Flow, WorkerTaskResult): Execution
  + log(Logger, Boolean, WorkerJob): void
  - onEnd(Executor): Executor
  - handleNext(Executor): Executor
  + process(Executor): Executor
  - handleExecutionUpdatingTask(Executor): Executor
  + log(Logger, Boolean, ExecutionKilledExecution): void
  + log(Logger, Boolean, Execution): void
  - handleWorkerTask(Executor): Executor
  - handleChildNext(Executor): Executor
  - handleCreatedKilling(Executor): Executor
  # flowExecutorInterface(): FlowExecutorInterface
  + log(Logger, Boolean, SubflowExecutionResult): void
}
class ExecutorState {
  - childDeduplication: Map<String, String>
  - executionId: String
  - workerTaskDeduplication: Map<String, Type>
  - subflowExecutionDeduplication: Map<String, Type>
  + getChildDeduplication(): Map<String, String>
  + getExecutionId(): String
  + getWorkerTaskDeduplication(): Map<String, Type>
  + getSubflowExecutionDeduplication(): Map<String, Type>
  + setExecutionId(String): void
  + setWorkerTaskDeduplication(Map<String, Type>): void
  + setChildDeduplication(Map<String, String>): void
  + toString(): String
  + setSubflowExecutionDeduplication(Map<String, Type>): void
  + hashCode(): int
  + equals(Object): boolean
  # canEqual(Object): boolean
}
class ExecutorsUtils {
  - threadFactoryBuilder: ThreadMainFactoryBuilder
  - meterRegistry: MeterRegistry
  + fixedThreadPool(int, String): ExecutorService
  + singleThreadExecutor(String): ExecutorService
  + singleThreadScheduledExecutor(String): ExecutorService
  - wrap(String, ExecutorService): ExecutorService
  + cachedThreadPool(String): ExecutorService
  + maxCachedThreadPool(int, String): ExecutorService
}
class Exponential {
  - maxInterval: Duration
  - delayFactor: Double
  # type: String
  - interval: Duration
  + getType(): String
  + getInterval(): Duration
  + getMaxInterval(): Duration
  + getDelayFactor(): Double
  - $default$type(): String
  + builder(): ExponentialBuilder<?, ?>
  + nextRetryDate(Integer, Instant): Instant
  + toPolicy(): RetryPolicyBuilder<T>
}
class ExpressionCondition {
  - expression: String
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getExpression(): String
  + toString(): String
  + builder(): ExpressionConditionBuilder<?, ?>
  + test(ConditionContext): boolean
}
class ExpressionConditionTest {
  ~ conditionService: ConditionService
  ~ invalid(): void
  ~ valid(): void
}
class Extension {
  - secretFunction: SecretFunction
  - renderFunction: RenderFunction
  - readFileFunction: ReadFileFunction
  - kvFunction: KvFunction
  - renderOnceFunction: RenderOnceFunction
  + getFilters(): Map<String, Filter>
  + getTokenParsers(): List<TokenParser>
  + getNodeVisitors(): List<NodeVisitorFactory>
  + getBinaryOperators(): List<BinaryOperator>
  + getUnaryOperators(): List<UnaryOperator>
  + getFunctions(): Map<String, Function>
  + getGlobalVariables(): Map<String, Object>
  + getTests(): Map<String, Test>
}
class ExtensionCustomizer {
  + getGlobalVariables(): Map<String, Object>
  + getNodeVisitors(): List<NodeVisitorFactory>
  + getAttributeResolver(): List<AttributeResolver>
  + getTokenParsers(): List<TokenParser>
  + getFunctions(): Map<String, Function>
  + getBinaryOperators(): List<BinaryOperator>
  + getTests(): Map<String, Test>
  + getUnaryOperators(): List<UnaryOperator>
  + getFilters(): Map<String, Filter>
}
class ExternalPlugin {
  - resources: URL[]
  - location: URL
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getLocation(): URL
  + getResources(): URL[]
  + toString(): String
}
class Fail {
  - condition: String
  - errorMessage: String
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getCondition(): String
  + getErrorMessage(): String
  + toString(): String
  - $default$errorMessage(): String
  + builder(): FailBuilder<?, ?>
  + run(RunContext): VoidOutput
}
class FailTest {
  ~ failOnSwitch(): void
  ~ failOnCondition(): void
  ~ dontFailOnCondition(): void
}
class Fetch {
  - flowId: String
  - level: Level
  - executionId: String
  - tasksId: Collection<String>
  - namespace: String
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getNamespace(): String
  + getFlowId(): String
  + getExecutionId(): String
  + getTasksId(): Collection<String>
  + getLevel(): Level
  - $default$level(): Level
  + toString(): String
  + builder(): FetchBuilder<?, ?>
  + run(RunContext): Output
}
class FetchOutput {
  - rows: List<Object>
  - uri: URI
  - size: Long
  - row: Map<String, Object>
  + getRows(): List<Object>
  + getRow(): Map<String, Object>
  + getUri(): URI
  + getSize(): Long
  + builder(): FetchOutputBuilder
}
class FetchTest {
  ~ flowRepository: FlowRepositoryInterface
  ~ fetchWithExecutionId(): void
  ~ fetch(): void
  ~ fetchWithTaskId(): void
}
enum FetchType << enumeration >> {
  + NONE:
  + FETCH_ONE:
  + FETCH:
  + STORE:
  + values(): FetchType[]
  + valueOf(String): FetchType
}
interface FileAttributes << interface >> {
  + getSize(): long
  + getMetadata(): Map<String, String>
  + getLastModifiedTime(): long
  + getCreationTime(): long
  + getType(): FileType
  + getFileName(): String
}
class FileInput {
  - DEFAULT_EXTENSION: String
  + extension: String
  + findFileInputExtension(List<Input<?>>, String): String
  + getExtension(): String
  - $default$extension(): String
  + builder(): FileInputBuilder<?, ?>
  + validate(URI): void
}
class FileInputTest {
  ~ shouldReturnDefaultExtensionWhenFindingExtensionForUnknownFile(): void
  ~ shouldGetExtensionWhenFindingFileExtensionForExistingFile(): void
}
annotation FileInputValidation << annotation >> {
  + groups(): Class<?>[]
  + payload(): Class<Payload>[]
  + message(): String
}
class FileInputValidator {
  + isValid(FileInput, AnnotationValue<FileInputValidation>, ConstraintValidatorContext): boolean
}
class FileMetas {
  - size: long
  + builder(): FileMetasBuilder
  + getSize(): long
  + equals(Object): boolean
  + hashCode(): int
  + toString(): String
}
class FileRender {
  + type: Type
  + truncated: boolean
  # MAX_LINES: int
  + extension: String
  + content: Object
  + maxLine: Integer
  + getExtension(): String
  + getType(): Type
  + getContent(): Object
  + getMaxLine(): Integer
  + isTruncated(): boolean
}
class FileRenderBuilder {
  - DEFAULT_FILE_CHARSET: Charset
  + of(String, InputStream, Optional<Charset>, Integer): FileRender
}
class FileRenderBuilderTest {
  ~ of(String, Class): void
  - provideExtensions(): Stream<Arguments>
}
class FileSerde {
  - DEFAULT_OBJECT_MAPPER: ObjectMapper
  + BUFFER_SIZE: int
  - DEFAULT_TYPE_REFERENCE: TypeReference<Object>
  + readAll(Reader): Flux<Object>
  + reader(BufferedReader): Consumer<FluxSink<Object>>
  + readAll(Reader, TypeReference<T>): Flux<T>
  + reader(BufferedReader, Consumer<Object>): void
  + readAll(Reader, Class<T>): Flux<T>
  + readAll(ObjectMapper, Reader, TypeReference<T>): Flux<T>
  - createMappingIterator(ObjectMapper, Reader, TypeReference<T>): MappingIterator<T>
  - createMappingIterator(ObjectMapper, Reader, Class<T>): MappingIterator<T>
  + readAll(ObjectMapper, Reader, Class<T>): Flux<T>
  + writeAll(Writer, Flux<T>): Mono<Long>
  - createSequenceWriter(ObjectMapper, Writer, TypeReference<T>): SequenceWriter
  + reader(BufferedReader, int, Consumer<Object>): boolean
  - convert(String): Object
  - convert(String, Class<T>): T
  + readAll(ObjectMapper, Reader): Flux<Object>
  + write(OutputStream, Object): void
  + reader(BufferedReader, Class<T>): Consumer<FluxSink<T>>
  + writeAll(ObjectMapper, Writer, Flux<T>): Mono<Long>
}
class FileSerdeTest {
  ~ readAll_fromMultiValuedSource(): void
  ~ writeAll_fromMultiValuedSource(): void
  - createTempFile(): Path
  ~ writeAll_fromSingleValuedSource(): void
  ~ readAll_fromEmptySource(): void
  ~ ion(Object, Object): void
  ~ source(): Stream<Arguments>
  ~ writeAll_fromReadAll(): void
  ~ readAll_fromSingleValuedSource(): void
  ~ readMax(): void
  ~ writeAll_fromEmptySource(): void
}
class FileUtils {
  + getFileName(URI): String
  + getExtension(String): String
  + getExtension(URI): String
  + getURI(String): Optional<URI>
}
class FileUtilsTest {
  ~ shouldGetExtension(): void
}
class FilesService {
  + outputFiles(RunContext, List<String>): Map<String, URI>
  + inputFiles(RunContext, Map<String, Object>, Object): Map<String, String>
  + inputFiles(RunContext, Object): Map<String, String>
  - resolveUniqueNameForFile(Path): String
}
class FilesServiceTest {
  - runContextFactory: RunContextFactory
  ~ renderInputFile(): void
  ~ overrideExistingInputFile(): void
  ~ renderRawFile(): void
  ~ renderOutputFiles(): void
  ~ outputFiles(): void
}
class FilterItems {
  - from: String
  - filterType: FilterType
  - errorOrNullBehavior: ErrorOrNullBehavior
  - filterCondition: String
  + getFilterType(): FilterType
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getFrom(): String
  + getFilterCondition(): String
  + builder(): FilterItemsBuilder<?, ?>
  + getErrorOrNullBehavior(): ErrorOrNullBehavior
  + toString(): String
  - $default$filterType(): FilterType
  - $default$errorOrNullBehavior(): ErrorOrNullBehavior
  - newBufferedReader(RunContext, URI): BufferedReader
  + run(RunContext): Output
  - getExpressionPredication(RunContext): PebbleExpressionPredicate
}
class FilterItemsTest {
  ~ storageInterface: StorageInterface
  ~ runContextFactory: RunContextFactory
  - TEST_VALID_ITEMS: List<KeyValue>
  - TEST_INVALID_ITEMS: List<KeyValue>
  ~ shouldFilterGivenInvalidRecordsForInclude(): void
  ~ shouldFilterGivenValidBooleanExpressionForExclude(): void
  - generateKeyValueFile(List<?>, RunContext): URI
  ~ shouldFilterGivenInvalidRecordsForExclude(): void
  - assertFile(RunContext, Output, List<T>, Class<T>): void
  ~ shouldThrowExceptionGivenInvalidRecordsForFail(): void
  ~ shouldFilterWithNotMatchGivenNonBooleanValue(): void
  ~ shouldFilterGivenValidBooleanExpressionForInclude(): void
}
class FlattenFilter {
  - argumentNames: List<String>
  + getArgumentNames(): List<String>
  + apply(Object, Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
}
class FlattenFilterTest {
  ~ variableRenderer: VariableRenderer
  ~ flatten(): void
}
class FloatInput {
  ~ min: Float
  ~ max: Float
  + validate(Float): void
  + getMin(): Float
  + getMax(): Float
  + builder(): FloatInputBuilder<?, ?>
}
class Flow {
  - namespace: String
  - flowId: String
  + getNamespace(): String
  + getFlowId(): String
  + equals(Object): boolean
  + hashCode(): int
  + toString(): String
}
class Flow {
  ~ concurrency: Concurrency
  ~ tasks: List<Task>
  ~ taskDefaults: List<PluginDefault>
  ~ labels: List<Label>
  ~ outputs: List<Output>
  ~ errors: List<Task>
  ~ triggers: List<AbstractTrigger>
  - NON_DEFAULT_OBJECT_MAPPER: ObjectMapper
  # retry: AbstractRetry
  ~ listeners: List<Listener>
  ~ pluginDefaults: List<PluginDefault>
  ~ description: String
  ~ variables: Map<String, Object>
  - WITHOUT_REVISION_OBJECT_MAPPER: ObjectMapper
  + findTaskByTaskIdOrNull(String): Task
  + getLabels(): List<Label>
  + equals(Object): boolean
  + getTriggers(): List<AbstractTrigger>
  + getConcurrency(): Concurrency
  # canEqual(Object): boolean
  + hashCode(): int
  + getDescription(): String
  + toBuilder(): FlowBuilder<?, ?>
  + getVariables(): Map<String, Object>
  + getRetry(): AbstractRetry
  + getTasks(): List<Task>
  + getPluginDefaults(): List<PluginDefault>
  + builder(): FlowBuilder<?, ?>
  + getListeners(): List<Listener>
  + getErrors(): List<Task>
  + toString(): String
  + getOutputs(): List<Output>
  + uidWithoutRevision(String, String, String): String
  + uid(String, String, String, Optional<Integer>): String
  + updateTask(String, Task): Flow
  + allErrorsWithChilds(): List<Task>
  + equalsWithoutRevision(Flow): boolean
  + uidWithoutRevision(): String
  - allTasksWithChilds(Task): Stream<Task>
  + allTasksWithChildsAndTriggerIds(): List<String>
  + validateUpdate(Flow): Optional<ConstraintViolationException>
  + allTasks(): Stream<Task>
  + setTaskDefaults(List<PluginDefault>): void
  + generateSource(): String
  + allTriggerIds(): List<String>
  + uidWithoutRevision(Execution): String
  + allTasksWithChilds(): List<Task>
  + uid(): String
  - recursiveUpdate(Object, Task, Task): Object
  - listenersTasks(): List<Task>
  + uid(Execution): String
  + getTaskDefaults(): List<PluginDefault>
  + logger(): Logger
  + allTypes(): Stream<String>
  + findTaskByTaskId(String): Task
  + toDeleted(): Flow
  + findParentTasksByTaskId(String): Task
}
class Flow {
  - states: List<Type>
  - TRIGGER_VAR: String
  - inputs: Map<String, Object>
  - OUTPUTS_VAR: String
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getInputs(): Map<String, Object>
  + getStates(): List<Type>
  + toString(): String
  - $default$states(): List<Type>
  + builder(): FlowBuilder<?, ?>
  + evaluate(RunContext, Flow, Execution): Optional<Execution>
  - generateLabels(RunContext, Flow): List<Label>
  - renderLabelValue(RunContext, Label): String?
}
class FlowAutoLoaderService {
  # pluginDefaultService: PluginDefaultService
  - namespaceUtils: NamespaceUtils
  # httpClient: HttpClient
  - log: Logger
  + PURGE_SYSTEM_FLOW_BLUEPRINT_ID: String
  - yamlFlowParser: YamlFlowParser
  # repository: FlowRepositoryInterface
  + load(): void
}
class FlowCaseTest {
  ~ executionQueue: QueueInterface<Execution>
  # runnerUtils: RunnerUtils
  + waitFailed(): void
  + noLabels(): void
  ~ run(String, Type, Type, int, String, boolean): void
  + invalidOutputs(): void
  + waitSuccess(): void
}
class FlowCommand {
  - log: Logger
  + call(): Integer
}
class FlowConcurrencyCaseTest {
  # executionQueue: QueueInterface<Execution>
  - runnerUtils: RunnerUtils
  - flowRepository: FlowRepositoryInterface
  + flowConcurrencyQueuePause(): void
  + flowConcurrencyCancelPause(): void
  + flowConcurrencyCancel(): void
  + flowConcurrencyFail(): void
  + flowConcurrencyQueue(): void
}
class FlowCondition {
  - namespace: String
  - flowId: String
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getNamespace(): String
  + getFlowId(): String
  + toString(): String
  + builder(): FlowConditionBuilder<?, ?>
  + test(ConditionContext): boolean
}
class FlowController {
  - flowTopologyRepository: FlowTopologyRepositoryInterface
  - modelValidator: ModelValidator
  - graphService: GraphService
  - flowService: FlowService
  - yamlFlowParser: YamlFlowParser
  - pluginDefaultService: PluginDefaultService
  - tenantService: TenantService
  - flowRepository: FlowRepositoryInterface
  - log: Logger
  - WARNING_JSON_FLOW_ENDPOINT: String
  - flowTopologyService: FlowTopologyService
  + create(String): HttpResponse<FlowWithSource>
  # doCreate(Flow, String): FlowWithSource
  + validateTask(String): ValidateConstraintViolation
  # parseTaskTrigger(String, Class<T>): T
  # importFlow(String, String): void
  + update(String, String, String): HttpResponse<FlowWithSource>
  + delete(String, String): HttpResponse<Void>
  + validateFlows(String): List<ValidateConstraintViolation>
  + enableByIds(List<IdWithNamespace>): HttpResponse<BulkResponse>
  + flowGraph(String, String, Optional<Integer>, List<String>): FlowGraph
  + importFlows(CompletedFileUpload): HttpResponse<Void>
  + exportByIds(List<IdWithNamespace>): HttpResponse<byte[]>
  - zipFlows(List<FlowWithSource>): byte[]
  + deleteByIds(List<IdWithNamespace>): HttpResponse<BulkResponse>
  # update(Flow, Flow, String): FlowWithSource
  + create(Flow): HttpResponse<Flow>
  + disableByIds(List<IdWithNamespace>): HttpResponse<BulkResponse>
  + dependencies(String, String, boolean): FlowTopologyGraph
  + validateTrigger(String): ValidateConstraintViolation
  + deleteByQuery(String, List<FlowScope>, String, List<String>): HttpResponse<BulkResponse>
  + disableByQuery(String, List<FlowScope>, String, List<String>): HttpResponse<BulkResponse>
  # setFlowsDisableByIds(List<IdWithNamespace>, boolean): List<FlowWithSource>
  + listDistinctNamespace(String): List<String>
  + find(int, int, List<String>, String, List<FlowScope>, String, List<String>): PagedResults<Flow>
  + getFlowsByNamespace(String): List<Flow>
  + updateTask(String, String, String, Task): HttpResponse<Flow>
  + exportByQuery(String, List<FlowScope>, String, List<String>): HttpResponse<byte[]>
  + enableByQuery(String, List<FlowScope>, String, List<String>): HttpResponse<BulkResponse>
  + update(String, String, Flow): HttpResponse<Flow>
  + flowGraphSource(String, List<String>): FlowGraph
  + revisions(String, String): List<FlowWithSource>
  + flowTask(String, String, String, Integer): Object
  # updateCompleteNamespace(String, List<FlowWithSource>, Boolean): List<FlowWithSource>
  + updateNamespace(String, List<Flow>, Boolean): List<Flow>
  + index(String, String, boolean, Integer, boolean): Object
  + source(int, int, List<String>, String, String): PagedResults<SearchResult<Flow>>
  + validateTask(String, TaskValidationType): ValidateConstraintViolation
  # setFlowsDisableByQuery(String, List<FlowScope>, String, List<String>, boolean): List<FlowWithSource>
  + updateNamespace(String, String, Boolean): List<FlowWithSource>
}
class FlowControllerTest {
  ~ jdbcFlowRepository: AbstractJdbcFlowRepository
  ~ client: ReactorHttpClient
  ~ disableEnableFlowsByIds(): void
  ~ createFlowWithJsonLabels(): void
  ~ importFlowsWithZip(): void
  ~ exportByQuery(): void
  ~ validateTask(): void
  ~ listDistinctNamespace(): void
  ~ disableEnableFlowsByQuery(): void
  ~ commaInSingleLabelsValue(): void
  - generateFlow(String, String): Flow
  ~ exportByIds(): void
  - generateFlowWithFlowable(String, String, String): Flow
  - generateFlowAsString(String, String, String): String
  ~ idNoSource(): void
  ~ commaInOneOfMultiLabels(): void
  ~ task(): void
  ~ findAll(): void
  ~ updateFlowFromString(): void
  ~ importFlowsWithYaml(): void
  ~ taskNotFound(): void
  ~ id(): void
  - generateTask(String, String): Task
  ~ createFlowFromString(): void
  - parseFlow(String): Flow
  ~ updateFlowMultilineJson(): void
  ~ updateFlow(): void
  ~ idNotFound(): void
  ~ createFlow(): void
  ~ updateTaskFlow(): void
  ~ validateFlows(): void
  ~ createInvalidFlowFromString(): void
  ~ getFlowsByNamespace(): void
  ~ graph(): void
  ~ updateNamespaceAsString(): void
  ~ validateTrigger(): void
  - generateFlow(String, String, String): Flow
  ~ deletedFlow(): void
  ~ deleteFlowsByQuery(): void
  ~ invalidUpdateFlow(): void
  ~ updateInvalidFlowFromString(): void
  ~ deleteFlowsByIds(): void
  - generateFlowAsString(String, String): String
  ~ graph_FlowNotFound(): void
  ~ updateNamespace(): void
  - postFlow(String, String, String): String
  # init(): void
  + beforeAll(): void
}
class FlowDotCommand {
  - applicationContext: ApplicationContext
  - file: Path
  - log: Logger
  + call(): Integer
}
class FlowDotCommandTest {
  ~ run(): void
}
interface FlowExecutorInterface << interface >> {
  + findByIdFromTask(String, String, String, Optional<Integer>, String, String, String): Optional<Flow>
  + findByExecution(Execution): Optional<Flow>
  + isReady(): Boolean
  + allLastVersion(): Collection<Flow>
  + findById(String, String, String, Optional<Integer>): Optional<Flow>
}
class FlowExpandCommand {
  - yamlFlowParser: YamlFlowParser
  - modelValidator: ModelValidator
  - file: Path
  + call(): Integer
}
class FlowExpandCommandTest {
  ~ run(): void
}
class FlowExportCommand {
  - DEFAULT_FILE_NAME: String
  + directory: Path
  + namespace: String
  - applicationContext: ApplicationContext
  - log: Logger
  + call(): Integer
}
class FlowExportCommandTest {
  ~ run(): void
}
class FlowForExecution {
  ~ triggers: List<AbstractTriggerForExecution>
  ~ tasks: List<TaskForExecution>
  + getTasks(): List<TaskForExecution>
  + getTriggers(): List<AbstractTriggerForExecution>
  + toString(): String
  + builder(): FlowForExecutionBuilder<?, ?>
  + toBuilder(): FlowForExecutionBuilder<?, ?>
  + of(Flow): FlowForExecution
}
class FlowGraph {
  - nodes: List<AbstractGraph>
  - flowables: List<String>
  - edges: List<Edge>
  - clusters: List<Cluster>
  + builder(): FlowGraphBuilder
  + toBuilder(): FlowGraphBuilder
  + getNodes(): List<AbstractGraph>
  + getEdges(): List<Edge>
  + getClusters(): List<Cluster>
  + getFlowables(): List<String>
  + equals(Object): boolean
  + hashCode(): int
  + toString(): String
  + forExecution(): FlowGraph
  + of(GraphCluster): FlowGraph
}
class FlowGraphTest {
  - triggerRepositoryInterface: TriggerRepositoryInterface
  - graphService: GraphService
  - yamlFlowParser: YamlFlowParser
  - runnerUtils: RunnerUtils
  ~ choice(): void
  ~ parallelNested(): void
  ~ dynamicIdSubflow(): void
  - node(FlowGraph, String): AbstractGraph
  ~ eachParallel(): void
  ~ eachWithExecution(): void
  ~ trigger(): void
  - nodeByUid(FlowGraph, String): AbstractGraph
  ~ parallel(): void
  ~ parallelWithExecution(): void
  ~ multipleTriggers(): void
  - cluster(FlowGraph, String, String): Cluster
  ~ sequentialNested(): void
  ~ simple(): void
  - edge(FlowGraph, String, String): Edge
  ~ each(): void
  - edges(FlowGraph, String): List<String>
  - parse(String): Flow
  ~ allFlowable(): void
  ~ subflow(): void
  - edge(FlowGraph, String): Edge
  ~ errors(): void
  - cluster(FlowGraph, String): Cluster
}
class FlowInputOutput {
  - log: Logger
  + YAML_MAPPER: ObjectMapper
  - storageInterface: StorageInterface
  + URI_PATTERN: Pattern
  - runContextFactory: RunContextFactory
  - secretKey: Optional<String>
  - buildRunContextForExecutionAndInputs(Execution, Map<String, InputAndValue>): RunContext
  - parseData(Execution, Data, Object): Optional<SimpleEntry<String, Object>>
  + validateExecutionInputs(List<Input<?>>, Execution, Publisher<CompletedPart>, boolean): List<InputAndValue>
  - readExecutionInputs(List<Input<?>>, Execution, Map<String, ?>): Map<String, Object>
  - parseType(Execution, Type, String, Type, Object): Object
  - resolveInputValue(ResolvableInput, Execution, Map<String, ResolvableInput>): InputAndValue
  + readExecutionInputs(Flow, Execution, Map<String, ?>): Map<String, Object>
  + readExecutionInputs(List<Input<?>>, Execution, Publisher<CompletedPart>): Map<String, Object>
  + resolveInputs(List<Input<?>>, Execution, Map<String, ?>): List<InputAndValue>
  + typedOutputs(Flow, Execution, Map<String, Object>): Map<String, Object>
  + readExecutionInputs(Flow, Execution, Publisher<CompletedPart>): Map<String, Object>
  - resolveAllDependentInputs(Input<?>, Execution, Map<String, ResolvableInput>): Map<String, InputAndValue>
  - readData(List<Input<?>>, Execution, Publisher<CompletedPart>): Map<String, ?>
}
class FlowInputOutputTest {
  ~ DEFAULT_TEST_EXECUTION: Execution
  ~ flowInputOutput: FlowInputOutput
  ~ storageInterface: StorageInterface
  ~ shouldResolveDisabledInputsGivenInputWithErroneousConditionalExpression(): void
  ~ shouldResolveEnabledInputsGivenInputWithConditionalExpressionMatchingTrue(): void
  ~ shouldResolveEnabledInputsGivenInputWithConditionalInputTrue(): void
  ~ shouldResolveDisabledInputsGivenInputWithConditionalInputFalse(): void
  ~ shouldResolveDisabledInputsGivenInputWithConditionalExpressionMatchingFalse(): void
  ~ shouldDeleteFileInputAfterValidationGivenDeleteTrue(): void
  ~ shouldNotDeleteFileInputAfterValidationGivenDeleteFalse(): void
}
class FlowListeners {
  - flows: List<Flow>
  - consumersEach: List<BiConsumer<Flow, Flow>>
  - isStarted: Boolean
  - log: Logger
  - MAPPER: ObjectMapper
  - flowQueue: QueueInterface<Flow>
  - consumers: List<Consumer<List<Flow>>>
  - notifyConsumersEach(Flow, Flow): void
  + flows(): List<Flow>
  - previous(Flow): Optional<Flow>
  - remove(Flow): boolean
  + listen(Consumer<List<Flow>>): void
  - upsert(Flow): void
  + run(): void
  - notifyConsumers(): void
  + listen(BiConsumer<Flow, Flow>): void
}
interface FlowListenersInterface << interface >> {
  + listen(Consumer<List<Flow>>): void
  + listen(BiConsumer<Flow, Flow>): void
  + run(): void
  + flows(): List<Flow>
}
class FlowListenersTest {
  # pluginDefaultService: PluginDefaultService
  # flowRepository: FlowRepositoryInterface
  # create(String, String): Flow
  - wait(Ref, Runnable): void
  + suite(FlowListenersInterface): void
}
class FlowNamespaceCommand {
  - log: Logger
  + call(): Integer
}
class FlowNamespaceCommandTest {
  ~ runWithNoParam(): void
}
class FlowNamespaceCondition {
  - prefix: Boolean
  - namespace: String
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getNamespace(): String
  + getPrefix(): Boolean
  + toString(): String
  - $default$prefix(): Boolean
  + builder(): FlowNamespaceConditionBuilder<?, ?>
  + test(ConditionContext): boolean
}
class FlowNamespaceUpdateCommand {
  + yamlFlowParser: YamlFlowParser
  - log: Logger
  + call(): Integer
}
class FlowNamespaceUpdateCommandTest {
  ~ runWithDelete(): void
  ~ runNoDelete(): void
  ~ invalid(): void
  ~ helper(): void
}
class FlowNode {
  ~ id: String
  ~ uid: String
  ~ tenantId: String
  ~ namespace: String
  + getUid(): String
  + getTenantId(): String
  + getNamespace(): String
  + getId(): String
  + builder(): FlowNodeBuilder<?, ?>
  + toBuilder(): FlowNodeBuilder<?, ?>
  + of(Flow): FlowNode
}
class FlowOutputTest {
  ~ NAMESPACE: String
  ~ shouldGetSuccessExecutionForFlowWithOutputs(): void
  ~ shouldGetFailExecutionForFlowWithInvalidOutputs(): void
  ~ shouldGetSuccessExecutionForFlowWithArrayOutputs(): void
}
enum FlowRelation << enumeration >> {
  + FLOW_TRIGGER:
  + FLOW_TASK:
  + valueOf(String): FlowRelation
  + values(): FlowRelation[]
}
interface FlowRepositoryInterface << interface >> {
  + findAllWithSourceForAllTenants(): List<FlowWithSource>
  + findByIdWithSource(String, String, String, Optional<Integer>, Boolean): Optional<FlowWithSource>
  + findByNamespaceWithSource(String, String): List<FlowWithSource>
  + create(Flow, String, Flow): FlowWithSource
  + findAllForAllTenants(): List<Flow>
  + findWithSource(String?, String?, List<FlowScope>?, String?, Map<String, String>?): List<FlowWithSource>
  + findByIdWithoutAcl(String, String, String, Optional<Integer>): Optional<Flow>
  + find(Pageable, String?, String?, List<FlowScope>?, String?, Map<String, String>?): ArrayListTotal<Flow>
  + findDistinctNamespace(String, String): List<String>
  + findByIdWithSource(String, String, String): Optional<FlowWithSource>
  + delete(Flow): Flow
  + findByExecutionWithoutAcl(Execution): Flow
  + findAll(String): List<Flow>
  + findByNamespaceExecutable(String, String): List<FlowForExecution>
  + count(String?): int
  + lastRevision(String, String, String): Integer
  + findAllWithSource(String): List<FlowWithSource>
  + findById(String, String, String, Optional<Integer>): Optional<Flow>
  + findRevisions(String, String, String): List<FlowWithSource>
  + findByIdWithSource(String, String, String, Optional<Integer>): Optional<FlowWithSource>
  + findDistinctNamespace(String): List<String>
  + findById(String, String, String, Optional<Integer>, Boolean): Optional<Flow>
  + countForNamespace(String?, String?): int
  + update(Flow, Flow, String, Flow): FlowWithSource
  + findDistinctNamespaceExecutable(String): List<String>
  + findById(String, String, String): Optional<Flow>
  + findByNamespacePrefix(String, String): List<Flow>
  + findByExecution(Execution): Flow
  + findByNamespace(String, String): List<Flow>
  + findSourceCode(Pageable, String?, String?, String?): ArrayListTotal<SearchResult<Flow>>
}
enum FlowScope << enumeration >> {
  + USER:
  + SYSTEM:
  + values(): FlowScope[]
  + valueOf(String): FlowScope
}
class FlowService {
  - log: Logger
  - NON_DEFAULT_OBJECT_MAPPER: ObjectMapper
  ~ pluginRegistry: PluginRegistry
  ~ pluginDefaultService: PluginDefaultService
  ~ flowRepository: Optional<FlowRepositoryInterface>
  ~ yamlFlowParser: YamlFlowParser
  + findByNamespacePrefix(String, String): List<Flow>
  + warnings(Flow): List<String>
  + keepLastVersion(List<Flow>): Collection<Flow>
  + importFlow(String, String): FlowWithSource
  + keepLastVersion(Stream<Flow>, String, String): Flow
  - fixSnakeYaml(Object): Object
  + findByNamespaceWithSource(String, String): List<FlowWithSource>
  + findByNamespace(String, String): List<Flow>
  + checkAllowedAllNamespaces(String, String, String): void
  + isAllowedNamespace(String, String, String, String): boolean
  + generateSource(Flow, String): String
  + deprecationPaths(Flow): List<String>
  - keepLastVersionCollector(Stream<Flow>): Stream<Flow>
  + findRemovedTrigger(Flow, Flow): List<AbstractTrigger>
  - noRepositoryException(): IllegalStateException
  + getFlowIfExecutableOrThrow(String, String, String, Optional<Integer>): Flow
  + checkAllowedNamespace(String, String, String, String): void
  + importFlow(String, String, boolean): FlowWithSource
  + keepLastVersion(Stream<Flow>): Stream<Flow>
  + findAll(String): List<Flow>
  - deprecationTraversal(String, Object): Stream<String>
  - relocations(Map<String, Class<?>>, Map<String, Object>): List<Relocation>
  + cleanupSource(String): String
  + areAllowedAllNamespaces(String, String, String): boolean
  + findUpdatedTrigger(Flow, Flow): List<AbstractTrigger>
  + injectDisabled(String, Boolean): String
  # removeUnwanted(Flow, Execution): boolean
  + relocations(String): List<Relocation>
  - allGetters(Class<?>): Stream<Method>
  + delete(Flow): Flow
  - toYamlWithoutDefault(Object): String
}
class FlowServiceTest {
  - flowRepository: FlowRepositoryInterface
  - flowService: FlowService
  ~ propertyRenamingDeprecation(): void
  - create(String, String, Integer): Flow
  ~ sameRevisionWithDeletedOrdered(): void
  ~ aliases(): void
  ~ isAllowedNamespace(): void
  ~ checkAllowedNamespace(): void
  ~ multipleFlow(): void
  ~ importFlow(): void
  - create(String, String, String, Integer): Flow
  ~ checkAllowedAllNamespaces(): void
  ~ sameRevisionWithDeletedUnordered(): void
  ~ importFlow_DryRun(): void
  ~ sameRevisionWithDeletedSameRevision(): void
  ~ areAllowedAllNamespaces(): void
  ~ warnings(): void
}
class FlowTest {
  ~ runContextFactory: RunContextFactory
  ~ success(): void
  ~ success_withLabels(): void
  ~ withTenant(): void
}
class FlowTest {
  ~ modelValidator: ModelValidator
  ~ yamlFlowParser: YamlFlowParser
  ~ workingDirectoryNoTasks(): void
  ~ workingDirectoryTaskInvalid(): void
  ~ duplicate(): void
  ~ switchTaskInvalid(): void
  - parse(String): Flow
  ~ duplicateUpdate(): void
  ~ duplicateInputs(): void
  ~ updateTask(): void
  ~ duplicateParallel(): void
  ~ allTasksWithChildsAndTriggerIds(): void
  ~ inputValidation(): void
  ~ workerGroup(): void
}
class FlowTest {
  ~ flowCaseTest: FlowCaseTest
  + invalidOutputs(): void
  + waitSuccess(): void
  + noLabels(): void
  + waitFailed(): void
}
class FlowTestCommand {
  - inputs: List<String>
  - random: SecureRandom
  - file: Path
  ~ spec: CommandSpec
  - applicationContext: ApplicationContext
  - log: Logger
  + propertiesOverrides(): Map<String, Object>
  + call(): Integer
  - generateTempDir(): Path
}
class FlowTopology {
  - source: FlowNode
  - destination: FlowNode
  - relation: FlowRelation
  + builder(): FlowTopologyBuilder
  + getSource(): FlowNode
  + getRelation(): FlowRelation
  + getDestination(): FlowNode
  + equals(Object): boolean
  + hashCode(): int
  + toString(): String
  + uid(): String
}
class FlowTopologyGraph {
  - nodes: Set<FlowNode>
  - edges: Set<Edge>
  + builder(): FlowTopologyGraphBuilder
  + getNodes(): Set<FlowNode>
  + getEdges(): Set<Edge>
  + equals(Object): boolean
  + hashCode(): int
  + toString(): String
  + of(Graph<FlowNode, FlowRelation>): FlowTopologyGraph
}
interface FlowTopologyRepositoryInterface << interface >> {
  + findByFlow(String, String, String, Boolean): List<FlowTopology>
  + findByNamespace(String, String): List<FlowTopology>
  + save(FlowTopology): FlowTopology
}
class FlowTopologyService {
  - flowTopologyRepository: FlowTopologyRepositoryInterface
  - log: Logger
  # conditionService: ConditionService
  - flowRepository: FlowRepositoryInterface
  # isFlowTaskChild(Flow, Flow): boolean
  # isMandatoryMultipleCondition(Condition): boolean
  # map(Flow, Flow): FlowTopology
  # validateCondition(Condition, Flow, Execution): boolean
  + namespaceGraph(String, String): FlowTopologyGraph
  + topology(Flow, Stream<Flow>): Stream<FlowTopology>
  + graph(Stream<FlowTopology>, Function<FlowNode, FlowNode>): FlowTopologyGraph
  + isChild(Flow, Flow): FlowRelation
  # isTriggerChild(Flow, Flow): boolean
  # isFilterCondition(Condition): boolean
}
class FlowTopologyServiceTest {
  - yamlFlowParser: YamlFlowParser
  - flowTopologyService: FlowTopologyService
  + multipleCondition(): void
  - returnTask(): Return
  - parse(String): Flow
  + trigger(): void
  + self(): void
  + noRelation(): void
  + flowTask(): void
  + self1(): void
}
class FlowTriggerCaseTest {
  # executionQueue: QueueInterface<Execution>
  # runnerUtils: RunnerUtils
  + trigger(): void
  + triggerWithPause(): void
}
class FlowTriggerService {
  - conditionService: ConditionService
  - runContextFactory: RunContextFactory
  - flowService: FlowService
  + computeExecutionsFromFlowTriggers(Execution, List<Flow>, Optional<MultipleConditionStorageInterface>): List<Execution>
  + flowTriggers(Flow): Stream<Flow>
  + withFlowTriggersOnly(Stream<Flow>): Stream<FlowWithFlowTrigger>
}
class FlowUsage {
  - namespacesCount: Long
  - taskTypeCount: Map<String, Long>
  - triggerTypeCount: Map<String, Long>
  - taskRunnerTypeCount: Map<String, Long>
  - count: Integer
  # namespacesCount(List<Flow>): long
  + getCount(): Integer
  + getNamespacesCount(): Long
  + getTaskTypeCount(): Map<String, Long>
  + getTriggerTypeCount(): Map<String, Long>
  + getTaskRunnerTypeCount(): Map<String, Long>
  + builder(): FlowUsageBuilder<?, ?>
  # taskTypeCount(List<Flow>): Map<String, Long>
  + of(List<Flow>): FlowUsage
  # count(List<Flow>): int
  + of(String, FlowRepositoryInterface): FlowUsage
  # triggerTypeCount(List<Flow>): Map<String, Long>
  # taskRunnerTypeCount(List<Flow>): Map<String, Long>
  + of(FlowRepositoryInterface): FlowUsage
}
class FlowValidateCommand {
  - modelValidator: ModelValidator
  - yamlFlowParser: YamlFlowParser
  - flowService: FlowService
  + call(): Integer
}
class FlowValidateCommandTest {
  ~ warning(): void
  ~ run(): void
}
annotation FlowValidation << annotation >> {
  + message(): String
  + groups(): Class<?>[]
  + payload(): Class<Payload>[]
}
class FlowValidationTest {
  - modelValidator: ModelValidator
  ~ yamlFlowParser: YamlFlowParser
  - parse(String): Flow
  ~ invalidRecursiveFlow(): void
}
class FlowValidator {
  - checkFlowInputsDependencyGraph(Flow, List<String>): void
  - getDuplicates(List<String>): List<String>
  + isValid(Flow, AnnotationValue<FlowValidation>, ConstraintValidatorContext): boolean
}
class FlowWithException {
  ~ exception: String
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getException(): String
  + toString(): String
  + builder(): FlowWithExceptionBuilder<?, ?>
  + toBuilder(): FlowWithExceptionBuilder<?, ?>
  + from(JsonNode, Exception): Optional<FlowWithException>
}
class FlowWithSource {
  ~ source: String
  + getSource(): String
  + toString(): String
  + builder(): FlowWithSourceBuilder<?, ?>
  + toBuilder(): FlowWithSourceBuilder<?, ?>
  - cleanupSource(String): String
  + toFlow(): Flow
  + equals(Flow, String): boolean
  + of(Flow, String): FlowWithSource
}
class FlowWithSourceTest {
  ~ source(): void
  ~ of(): void
  ~ scalar(): void
}
interface FlowableTask<T> << interface >> {
  + resolveState(RunContext, Execution, TaskRun): Optional<Type>
  + isAllowFailure(): boolean
  + allChildTasks(): List<Task>
  + getErrors(): List<Task>
  + childTasks(RunContext, TaskRun): List<ResolvedTask>
  + outputs(RunContext): T
  + tasksTree(Execution, TaskRun, List<String>): AbstractGraph
  + resolveNexts(RunContext, Execution, TaskRun): List<NextTaskRun>
}
class FlowableUtils {
  - TYPE_REFERENCE: TypeReference<List<Object>>
  - MAPPER: ObjectMapper
  + resolveParallelNexts(Execution, List<ResolvedTask>, List<ResolvedTask>, TaskRun, Integer, BiFunction<Stream<NextTaskRun>, List<TaskRun>, Stream<NextTaskRun>>): List<NextTaskRun>
  - innerResolveSequentialNexts(Execution, List<ResolvedTask>, TaskRun): List<NextTaskRun>
  + isTaskRunFor(ResolvedTask, TaskRun, TaskRun): boolean
  + resolveWaitForNext(Execution, List<ResolvedTask>, List<ResolvedTask>, TaskRun): List<NextTaskRun>
  + resolveConcurrentNexts(Execution, List<ResolvedTask>, List<ResolvedTask>, TaskRun, Integer): List<NextTaskRun>
  + resolveSequentialNexts(Execution, List<ResolvedTask>, List<ResolvedTask>): List<NextTaskRun>
  - filterCreated(List<ResolvedTask>, List<TaskRun>, TaskRun): List<ResolvedTask>
  + resolveSequentialNexts(Execution, List<ResolvedTask>): List<NextTaskRun>
  + resolveParallelNexts(Execution, List<ResolvedTask>, List<ResolvedTask>, TaskRun, Integer): List<NextTaskRun>
  + resolveEachTasks(RunContext, TaskRun, List<Task>, Object): List<ResolvedTask>
  + resolveSequentialNexts(Execution, List<ResolvedTask>, List<ResolvedTask>, TaskRun): List<NextTaskRun>
  + resolveDagNexts(Execution, List<ResolvedTask>, List<ResolvedTask>, TaskRun, Integer, List<DagTask>): List<NextTaskRun>
  + resolveTasks(List<Task>, TaskRun): List<ResolvedTask>
  + resolveState(Execution, List<ResolvedTask>, List<ResolvedTask>, TaskRun, RunContext, boolean): Optional<Type>
}
class ForEach {
  - concurrencyLimit: Integer
  - values: Object
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getValues(): Object
  + getConcurrencyLimit(): Integer
  + toString(): String
  - $default$concurrencyLimit(): Integer
  + builder(): ForEachBuilder<?, ?>
  + resolveState(RunContext, Execution, TaskRun): Optional<Type>
  + tasksTree(Execution, TaskRun, List<String>): GraphCluster
  + resolveNexts(RunContext, Execution, TaskRun): List<NextTaskRun>
  + childTasks(RunContext, TaskRun): List<ResolvedTask>
}
class ForEachItem {
  - wait: Boolean
  - transmitFailed: Boolean
  - items: String
  - namespace: String
  - labels: Map<String, String>
  - errors: List<Task>
  - revision: Integer
  - inputs: Map<String, Object>
  - flowId: String
  - inheritLabels: Boolean
  - batch: Batch
  - scheduleDate: Property<ZonedDateTime>
  # canEqual(Object): boolean
  + getTransmitFailed(): Boolean
  - $default$inheritLabels(): Boolean
  - $default$batch(): Batch
  + equals(Object): boolean
  + hashCode(): int
  + getItems(): String
  + getLabels(): Map<String, String>
  + getBatch(): Batch
  + toBuilder(): ForEachItemBuilder<?, ?>
  + getNamespace(): String
  + getInheritLabels(): Boolean
  - $default$wait(): Boolean
  - $default$transmitFailed(): Boolean
  + builder(): ForEachItemBuilder<?, ?>
  + toString(): String
  + getFlowId(): String
  + getScheduleDate(): Property<ZonedDateTime>
  + getWait(): Boolean
  + getRevision(): Integer
  + getInputs(): Map<String, Object>
  + getErrors(): List<Task>
  + resolveNexts(RunContext, Execution, TaskRun): List<NextTaskRun>
  + setTasks(List<Task>): void
  + childTasks(RunContext, TaskRun): List<ResolvedTask>
  + allChildTasks(): List<Task>
  + tasksTree(Execution, TaskRun, List<String>): GraphCluster
  + getTasks(): List<Task>
  - extractOutput(RunContext, String): Map<String, Object>
}
class ForEachItemCaseTest {
  - flowIO: FlowInputOutput
  # runnerUtils: RunnerUtils
  ~ TEST_NAMESPACE: String
  - executionQueue: QueueInterface<Execution>
  - storageInterface: StorageInterface
  - log: Logger
  - storageUpload(): URI
  + forEachItemNoWait(): void
  - content(): List<String>
  + forEachItem(): void
  + forEachItemEmptyItems(): void
  + forEachItemFailed(): void
  - emptyItems(): URI
  + forEachItemWithSubflowOutputs(): void
}
class ForEachTest {
  ~ concurrentNoLimit(): void
  ~ nonConcurrent(): void
  ~ concurrent(): void
  ~ concurrentWithParallel(): void
}
class FromIonFunction {
  - MAPPER: ObjectMapper
  + execute(Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
  + getArgumentNames(): List<String>
}
class FromIonFunctionTest {
  ~ variableRenderer: VariableRenderer
  ~ ionDecodeFunction(): void
  ~ exception(): void
}
class FromJsonFunction {
  - MAPPER: ObjectMapper
  + getArgumentNames(): List<String>
  + execute(Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
}
class FromJsonFunctionTest {
  ~ variableRenderer: VariableRenderer
  ~ jsonFunction(): void
  ~ exception(): void
  ~ fronJsonFunction(): void
}
class Get {
  - errorOnMissing: boolean
  - key: String
  - namespace: String
  - log: Logger
  + getKey(): String
  + getNamespace(): String
  + isErrorOnMissing(): boolean
  - $default$namespace(): String
  - $default$errorOnMissing(): boolean
  + builder(): GetBuilder<?, ?>
  + toBuilder(): GetBuilder<?, ?>
  + run(RunContext): Output
}
class Get {
  - errorOnMissing: Boolean
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getErrorOnMissing(): Boolean
  + toString(): String
  - $default$errorOnMissing(): Boolean
  + builder(): GetBuilder<?, ?>
  + run(RunContext): Output
}
class GetKeys {
  - log: Logger
  - prefix: String
  - namespace: String
  + run(RunContext): Output
  + getPrefix(): String
  + getNamespace(): String
  - $default$namespace(): String
  + builder(): GetKeysBuilder<?, ?>
  + toBuilder(): GetKeysBuilder<?, ?>
}
class GetKeysTest {
  ~ TEST_KEY_PREFIX_TEST: String
  ~ runContextFactory: RunContextFactory
  ~ shouldGetKeysGivenMatchingPrefix(): void
  ~ shouldGetNoKeysGivenEmptyKeyStore(): void
  ~ shouldGetAllKeys(): void
}
class GetTest {
  ~ runContextFactory: RunContextFactory
  ~ TEST_KV_KEY: String
  ~ shouldGetGivenExistingKey(): void
  ~ shouldGetGivenNonExistingKey(): void
}
class GlobalTagsConfigurer {
  ~ metricConfig: MetricConfig
  + getType(): Class<SimpleMeterRegistry>
  + supports(SimpleMeterRegistry): boolean
  + configure(SimpleMeterRegistry): void
}
class Graph2DotService {
  - node(AbstractGraph): String
  - name(AbstractGraph): String
  - subgraph(GraphCluster, int): String
  - nodeAndEdges(Graph<AbstractGraph, Relation>, int, String): String
  + dot(Graph<AbstractGraph, Relation>): String
  - label(AbstractGraph): String
  - nodeName(AbstractGraph): String
  - indent(int): String
}
class Graph<T, V> {
  - graph: MutableValueGraph<T, V>
  + addEdge(T, T, V): Graph<T, V>
  + successors(T): Set<T>
  + edges(): Set<Edge<T, V>>
  + nodes(): Set<T>
  + predecessors(T): Set<T>
  + addNode(T): Graph<T, V>
  + removeNode(T): void
}
class GraphCluster {
  - end: GraphClusterEnd
  - taskNode: AbstractGraphTask
  - graph: Graph<AbstractGraph, Relation>
  - root: GraphClusterRoot
  - relationType: RelationType
  + allNodesByParent(): Map<GraphCluster, List<AbstractGraph>>
  + getGraph(): Graph<AbstractGraph, Relation>
  + getRelationType(): RelationType
  + getRoot(): GraphClusterRoot
  + getEnd(): GraphClusterEnd
  + getTaskNode(): AbstractGraphTask
  + setTaskNode(AbstractGraphTask): void
  + addEdge(AbstractGraph, AbstractGraph, Relation): void
  - prefixedUid(String): String
  + addNode(AbstractGraph, boolean): void
  + updateErrorWithChildren(boolean): void
  + addNode(AbstractGraph): void
  + forExecution(): AbstractGraph
  + getUid(): String
  + updateUidWithChildren(String): void
}
class GraphClusterEnd
class GraphClusterRoot
class GraphService {
  - log: Logger
  - runContextFactory: RunContextFactory
  - pluginDefaultService: PluginDefaultService
  - flowRepository: FlowRepositoryInterface
  - triggerRepository: TriggerRepositoryInterface
  + flowGraph(Flow, List<String>): FlowGraph
  + of(Flow, List<String>, Map<String, Flow>, Execution): GraphCluster
  + of(GraphCluster, Flow, List<String>, Map<String, Flow>, Execution): GraphCluster
  + of(GraphCluster, Flow, List<String>, Map<String, Flow>): GraphCluster
  + flowGraph(Flow, List<String>, Execution): FlowGraph
}
class GraphTask
class GraphTrigger
class GraphUtils {
  + flowGraph(Flow, Execution, List<Trigger>): FlowGraph
  + nodes(GraphCluster): List<AbstractGraph>
  - fillGraph(GraphCluster, List<Task>, RelationType, TaskRun, Execution, String): void
  - fillGraphDag(GraphCluster, List<DagTask>, TaskRun, Execution): void
  - findTaskRuns(Task, Execution, TaskRun): List<TaskRun>
  + triggers(GraphCluster, List<AbstractTrigger>, List<Trigger>): GraphCluster
  + of(GraphCluster, Flow, Execution, List<Trigger>): GraphCluster
  - rawEdges(GraphCluster): List<Triple<AbstractGraph, AbstractGraph, Relation>>
  + edges(GraphCluster): List<Edge>
  + of(Flow, Execution, List<Trigger>): GraphCluster
  + dag(GraphCluster, List<DagTask>, List<Task>, TaskRun, Execution): void
  - iterate(GraphCluster, List<Task>, List<Task>, TaskRun, Execution, RelationType): void
  + of(Flow, Execution): GraphCluster
  - recursiveEdge(List<Edge>, String): List<Edge>
  - isAllLinkToEnd(RelationType): boolean
  + flowGraph(Flow, Execution): FlowGraph
  + parallel(GraphCluster, List<Task>, List<Task>, TaskRun, Execution): void
  + sequential(GraphCluster, List<Task>, List<Task>, TaskRun, Execution): void
  + successors(GraphCluster, List<String>): Set<AbstractGraph>
  + switchCase(GraphCluster, Map<String, List<Task>>, List<Task>, TaskRun, Execution): void
  + clusters(GraphCluster, List<String>): List<Pair<GraphCluster, List<String>>>
  + ifElse(GraphCluster, List<Task>, List<Task>, List<Task>, TaskRun, Execution): void
  - toEdgeTarget(AbstractGraph): AbstractGraph
}
class H2ExecutionDelayStorage
class H2ExecutionQueuedStorage
class H2ExecutionRepository {
  # findCondition(String, Map<String, String>): Condition
}
class H2ExecutionRepositoryService {
  + findCondition(AbstractJdbcRepository<Execution>, String, Map<String, String>): Condition
}
class H2ExecutionRepositoryTest {
  # mappingConflict(): void
  # taskRunsDailyStatistics(): void
  # findTaskRun(): void
}
class H2ExecutionServiceTest {
  ~ jdbcTestUtils: JdbcTestUtils
  # init(): void
}
class H2ExecutorStateStorage
class H2FlowListenersTest {
  ~ flowRepository: FlowRepositoryInterface
  ~ flowQueue: QueueInterface<Flow>
  ~ jdbcTestUtils: JdbcTestUtils
  ~ dslContextWrapper: JooqDSLContextWrapper
  + all(): void
  # init(): void
}
class H2FlowRepository {
  # findCondition(String, Map<String, String>): Condition
  # findSourceCodeCondition(String): Condition
}
class H2FlowRepositoryService {
  + findSourceCodeCondition(AbstractJdbcRepository<Flow>, String): Condition
  + findCondition(AbstractJdbcRepository<Flow>, String, Map<String, String>): Condition
}
class H2FlowRepositoryTest {
  + findSourceCode(): void
  # setup(): void
  # init(): void
}
class H2FlowTopologyRepository
class H2FlowTopologyRepositoryTest
class H2Functions {
  - scope: Scope
  + jqString(String, String): String
  + jqStringArray(String, String): String[]
  - jqArray(String, String, Function<JsonNode, T>): List<T>
  + jqInteger(String, String): Integer
  + jqLong(String, String): Long
  + jqDouble(String, String): Double
  - jq(String, String): List<JsonNode>
  + jqBoolean(String, String): Boolean
  - jq(String, String, Function<JsonNode, T>): T?
}
class H2FunctionsTest {
  + jqStringArray(): void
  + jqBoolean(): void
  + jqString(): void
  + jqStringWithArray(): void
  + jqLong(): void
  + jqNull(): void
  + jqInteger(): void
}
class H2JdbcDeserializationIssuesTest
class H2JdbcTestUtils {
  + drop(): void
}
class H2LogRepository {
  # findCondition(String): Condition
}
class H2LogRepositoryTest
class H2MetricRepository
class H2MetricRepositoryTest
class H2MultipleConditionStorage
class H2MultipleConditionStorageTest {
  ~ jdbcTestUtils: JdbcTestUtils
  ~ applicationContext: ApplicationContext
  ~ repository: H2Repository<MultipleConditionWindow>
  # save(MultipleConditionStorageInterface, Flow, List<MultipleConditionWindow>): void
  # init(): void
  # multipleConditionStorage(): MultipleConditionStorageInterface
}
class H2Queue<T> {
  # receiveFetch(DSLContext, String, String, boolean): Result<Record>
  # receiveFetch(DSLContext, String, Integer, boolean): Result<Record>
  # updateGroupOffsets(DSLContext, String, String, List<Integer>): void
}
annotation H2QueueEnabled << annotation >>
class H2QueueFactory {
  ~ applicationContext: ApplicationContext
  + workerTaskResult(): QueueInterface<WorkerTaskResult>
  + workerJobRunning(): QueueInterface<WorkerJobRunning>
  + subflowExecutionResult(): QueueInterface<SubflowExecutionResult>
  + trigger(): QueueInterface<Trigger>
  + metricEntry(): QueueInterface<MetricEntry>
  + kill(): QueueInterface<ExecutionKilled>
  + logEntry(): QueueInterface<LogEntry>
  + flow(): QueueInterface<Flow>
  + workerJobQueue(): WorkerJobQueueInterface
  + workerJob(): QueueInterface<WorkerJob>
  + executor(): QueueInterface<Executor>
  + template(): QueueInterface<Template>
  + workerTriggerResultQueue(): WorkerTriggerResultQueueInterface
  + workerTriggerResult(): QueueInterface<WorkerTriggerResult>
  + workerInstance(): QueueInterface<WorkerInstance>
  + execution(): QueueInterface<Execution>
}
class H2QueueTest
class H2Repository<T> {
  + fetchPage(DSLContext, SelectConditionStep<R>, Pageable, RecordMapper<R, E>): ArrayListTotal<E>
  + persist(T, DSLContext, Map<Field<Object>, Object>?): void
  + fullTextCondition(List<String>, String): Condition
}
annotation H2RepositoryEnabled << annotation >>
class H2RunnerRetryTest
class H2RunnerTest
class H2SchedulerScheduleTest {
  # scheduler(FlowListeners): AbstractScheduler
}
class H2ServiceInstanceRepository
class H2ServiceInstanceRepositoryTest
class H2ServiceLivenessCoordinatorTest
class H2SettingRepository
class H2SettingRepositoryTest
class H2SubflowExecutionStorage
class H2SubflowExecutionStorageTest
class H2TemplateRepository {
  # findCondition(String): Condition
}
class H2TemplateRepositoryTest
class H2TemplateRunnerTest
class H2TriggerRepository
class H2TriggerRepositoryTest
class H2WorkerJobQueue {
  - jdbcWorkerJobQueueService: JdbcWorkerJobQueueService
  - log: Logger
  + receive(String, Class<?>, Consumer<Either<WorkerJob, DeserializationException>>): Runnable
  + close(): void
}
class H2WorkerJobRunningRepository
class H2WorkerTriggerResultQueue {
  - log: Logger
  - jdbcWorkerTriggerResultQueueService: JdbcWorkerTriggerResultQueueService
  + receive(String, Class<?>, Consumer<Either<WorkerTriggerResult, DeserializationException>>): Runnable
  + close(): void
}
class HasRetryAttemptCondition {
  - in: List<Type>
  - notIn: List<Type>
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getIn(): List<Type>
  + getNotIn(): List<Type>
  + toString(): String
  + builder(): HasRetryAttemptConditionBuilder<?, ?>
  + test(ConditionContext): boolean
}
class HasRetryAttemptConditionTest {
  ~ conditionService: ConditionService
  ~ onlyOne(): void
  ~ test(): void
}
class Hashing {
  + hashToString(String): String
  + sha512Hash(byte[], byte[]): byte[]
  + decodeHexToBytes(String): byte[]
  + encodeBytesToHex(byte[]): String
  - getHashString(String): HashCode
  + hashToLong(String): long
}
class HashingTest {
  ~ shouldReturnConsistentHashString(): void
  ~ shouldReturnConsistentHashLong(): void
}
class Helpers {
  - plugins: Path
  + FLOWS_COUNT: long
  - countFlows(): int
  + runApplicationContext(String[], BiConsumer<ApplicationContext, EmbeddedServer>): void
  + applicationContext(): ApplicationContext
  + runApplicationContext(BiConsumer<ApplicationContext, EmbeddedServer>): void
  + runApplicationContext(String[], Map<String, Object>, BiConsumer<ApplicationContext, EmbeddedServer>): void
  + loadExternalPluginsFromClasspath(): void
  - applicationContext(Map<String, Object>, String[]): ApplicationContext
  + runApplicationContext(Consumer<ApplicationContext>): void
  + applicationContext(Map<String, Object>): ApplicationContext
}
class HostUsage {
  - hardware: Hardware
  - uuid: String
  - jvm: Jvm
  - os: Os
  + getUuid(): String
  + getHardware(): Hardware
  + getOs(): Os
  + getJvm(): Jvm
  + builder(): HostUsageBuilder<?, ?>
  + of(): HostUsage
}
interface HttpInterface << interface >> {
  + getFormData(): Map<String, Object>
  + getBody(): String
  + getOptions(): RequestOptions
  + getMethod(): HttpMethod
  + getHeaders(): Map<CharSequence, CharSequence>
  + getContentType(): String
  + getUri(): String
  + getSslOptions(): SslOptions
}
class IdUtils {
  - HASH_FUNCTION: HashFunction
  - ID_SEPARATOR: char
  + fromParts(String[]): String
  + fromPartsAndSeparator(char, String[]): String
  + from(String): String
  + create(): String
}
class IdUtilsTest {
  ~ create(): void
  ~ fromParts(): void
  ~ fromPartsAndSeparator(): void
  ~ from(String): void
}
class IdWithNamespace {
  - namespace: String
  - id: String
  + getNamespace(): String
  + getId(): String
  + setNamespace(String): void
  + setId(String): void
}
class If {
  - errors: List<Task>
  - condition: String
  - _else: List<Task>
  - then: List<Task>
  + getCondition(): String
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getThen(): List<Task>
  + get_else(): List<Task>
  + toString(): String
  + builder(): IfBuilder<?, ?>
  + resolveNexts(RunContext, Execution, TaskRun): List<NextTaskRun>
  + getErrors(): List<Task>
  + allChildTasks(): List<Task>
  + resolveState(RunContext, Execution, TaskRun): Optional<Type>
  + childTasks(RunContext, TaskRun): List<ResolvedTask>
  + tasksTree(Execution, TaskRun, List<String>): GraphCluster
}
class IfTest {
  ~ ifTruthy(): void
  ~ ifFalsy(): void
  ~ ifWithoutElse(): void
}
class IllegalArgumentExceptionHandler {
  + handle(HttpRequest, IllegalArgumentException): HttpResponse
}
class IllegalConditionEvaluation {
  - serialVersionUID: long
}
class IllegalStateExceptionHandler {
  + handle(HttpRequest, IllegalStateException): HttpResponse
}
class IllegalVariableEvaluationException {
  - serialVersionUID: long
}
class ImageFileRender
class IncludeHelperExpander {
  + expand(String, Path): String
  - expandLine(String, Path): String
}
class IndentFilter {
  + apply(Object, Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
}
class IndentFilterTest {
  ~ variableRenderer: VariableRenderer
  ~ indentNull(): void
  ~ indentInteger(): void
  ~ indentStringWithCR(): void
  ~ indentStringWithLF(): void
  ~ indentStringWithSystemNewLine(): void
  ~ indentEmpty(): void
  ~ indentString(): void
  ~ indentWithTab(): void
  ~ indentEmptyLines(): void
  ~ indentStringWithCRLF(): void
}
class Indexer {
  - metricRepository: MetricRepositoryInterface
  - receiveCancellations: List<Runnable>
  - executionRepository: ExecutionRepositoryInterface
  - logRepository: LogRepositoryInterface
  - metricRegistry: MetricRegistry
  - state: AtomicReference<ServiceState>
  - metricQueue: QueueInterface<MetricEntry>
  - logQueue: QueueInterface<LogEntry>
  - id: String
  - eventPublisher: ApplicationEventPublisher<ServiceStateChangeEvent>
  - log: Logger
  - executionQueue: QueueInterface<Execution>
  + getState(): ServiceState
  + run(): void
  # send(QueueInterface<T>, SaveRepositoryInterface<T>): void
  + getId(): String
  + getType(): ServiceType
  # setState(ServiceState): void
  + close(): void
}
class IndexerCommand {
  - log: Logger
  - applicationContext: ApplicationContext
  + propertiesOverrides(): Map<String, Object>
  + call(): Integer
}
interface IndexerInterface << interface >>
class Input<T> {
  ~ dependsOn: DependsOn
  ~ required: Boolean
  ~ defaults: Object
  ~ name: String
  ~ description: String
  ~ displayName: String
  ~ id: String
  ~ type: Type
  + setName(String): void
  + getDefaults(): Object
  + getId(): String
  + getName(): String
  + getType(): Type
  + getDescription(): String
  + getDependsOn(): DependsOn
  + getRequired(): Boolean
  + getDisplayName(): String
  - $default$required(): Boolean
  + validate(T): void
}
entity InputAndValue << record >> {
  - enabled: boolean
  - exception: ConstraintViolationException
  - value: Object
  - input: Input<?>
  + input(): Input<?>
  + enabled(): boolean
  + value(): Object
  + exception(): ConstraintViolationException
}
interface InputFilesInterface << interface >> {
  + getInputFiles(): Object
}
class InputTest {
  - modelValidator: ModelValidator
  ~ inputValidation(): void
  ~ inputNameDeprecation(): void
}
class InputType {
  - type: String
  - cls: String
  + getType(): String
  + getCls(): String
  + equals(Object): boolean
  + hashCode(): int
  + toString(): String
}
class InputsTest {
  + inputs: Map<String, Object>
  - flowIO: FlowInputOutput
  - flowRepository: FlowRepositoryInterface
  - storageInterface: StorageInterface
  ~ inputEmptyJson(): void
  ~ inputValidatedIntegerBadValue(): void
  - typedInputs(Map<String, Object>): Map<String, Object>
  - typedInputs(Map<String, Object>, Flow): Map<String, Object>
  ~ inputFailed(): void
  ~ inputArrayFailed(): void
  ~ allValidInputs(): void
  ~ nonRequiredNoDefaultNoValueIsNull(): void
  ~ inputValidatedDateTimeBadValue(): void
  ~ allValidTypedInputs(): void
  ~ inputValidatedStringBadValue(): void
  ~ inputValidatedDurationBadValue(): void
  ~ inputValidatedFloatBadValue(): void
  ~ inputEmptyJsonFlow(): void
  ~ inputFlow(): void
  ~ missingRequired(): void
  ~ inputValidatedDateBadValue(): void
  ~ inputValidatedTimeBadValue(): void
  ~ inputEnumFailed(): void
}
class InstanceService {
  - settingRepository: SettingRepositoryInterface
  - instanceIdSetting: Setting
  - log: Logger
  + fetch(): String
}
class IntInput {
  ~ min: Integer
  ~ max: Integer
  + getMin(): Integer
  + getMax(): Integer
  + builder(): IntInputBuilder<?, ?>
  + validate(Integer): void
}
class InternalException {
  - serialVersionUID: long
}
class InternalKVStore {
  - namespace: String
  - DURATION_PATTERN: Pattern
  - tenant: String
  - storage: StorageInterface
  + getRawValue(String): Optional<String>
  + namespace(): String
  + delete(String): boolean
  + put(String, KVValueAndMetadata, boolean): void
  + getValue(String): Optional<KVValue>
  + get(String): Optional<KVEntry>
  + list(): List<KVEntry>
}
class InternalKVStoreTest {
  - date: Instant
  ~ TEST_KV_KEY: String
  ~ storageInterface: LocalStorage
  - complexValue: Map<String, Object>
  - kv(): InternalKVStore
  + setUp(): void
  ~ illegalKey(): void
  ~ shouldGetGivenEntryWithNullValue(): void
  ~ shouldGetEmptyGivenNonExistingKey(): void
  ~ put(): void
  ~ list(): void
  ~ shouldGetGivenEntryWithComplexValue(): void
  ~ shouldThrowGivenExpiredEntry(): void
}
class InternalNamespace {
  - tenant: String
  - log: Logger
  - namespace: String
  - storage: StorageInterface
  - logger: Logger
  + putFile(Path, InputStream, Conflicts): NamespaceFile
  + all(boolean): List<NamespaceFile>
  + findAllFilesMatching(Predicate<Path>): List<NamespaceFile>
  + namespace(): String
  + delete(Path): boolean
  + relativize(URI): Path
  + all(): List<NamespaceFile>
  + get(Path): NamespaceFile
  + createDirectory(Path): URI
  + all(String, boolean): List<NamespaceFile>
  + getFileContent(Path): InputStream
}
class InternalNamespaceTest {
  ~ storageInterface: LocalStorage
  - logger: Logger
  ~ shouldReturnNoNamespaceFileForEmptyNamespace(): void
  ~ shouldSucceedPutFileGivenExistingFileForConflictOverwrite(): void
  + setUp(): void
  ~ shouldFindAllGivenTenant(): void
  ~ shouldIgnorePutFileGivenExistingFileForSkip(): void
  ~ shouldPutFileGivenNoTenant(): void
  ~ shouldGetAllNamespaceFiles(): void
  ~ shouldFindAllMatchingGivenNoTenant(): void
  ~ shouldFailPutFileGivenExistingFileForError(): void
}
class InternalStorage {
  - LOG: Logger
  - logger: Logger
  - context: StorageContext
  - storage: StorageInterface
  - PATH_SEPARATOR: String
  - flowService: FlowService
  + putFile(File, String): URI
  + putCacheFile(File, String, String?): URI
  - putFile(InputStream, String, String): URI
  + getCacheFile(String, String?, Duration?): Optional<InputStream>
  + isFileExist(URI): boolean
  + getTaskStorageContext(): Optional<Task>
  + putFile(InputStream, String): URI
  + putFile(File): URI
  - getCacheFileLastModifiedTime(String, String?): Optional<Long>
  + getContextBaseURI(): URI
  + putFile(InputStream, URI): URI
  + namespace(): Namespace
  + deleteExecutionFiles(): List<URI>
  + deleteCacheFile(String, String?): Optional<Boolean>
  + namespace(String): Namespace
  + deleteFile(URI): boolean
  + getFile(URI): InputStream
  - uriGuard(URI): void
  - putFileAndDelete(File, String, String): URI
  - putFileAndDelete(File, URI): URI
}
class InvalidException {
  - serialVersionUID: long
  - invalid: Object
  + invalidObject(): Object
}
class IonFactory {
  - serialVersionUID: long
  # _createParser(Reader, IOContext): JsonParser
  # _createGenerator(IonWriter, boolean, IOContext, Closeable): IonGenerator
}
class IonFileRender {
  - renderContent(InputStream): void
}
class IonFileRenderTest {
  ~ testTruncatedByLineCount(int, boolean): void
}
class IonGenerator {
  + writeDate(Instant): void
  + writeString(Object, String): void
  + writeDate(LocalDate): void
}
class IonModule {
  - serialVersionUID: long
  - VERSION: Version
  + version(): Version
  + getModuleName(): String
  + setupModule(SetupContext): void
}
class IonParser {
  # _tokenFromType(IonType): JsonToken
  + getEmbeddedObject(): Object
}
interface ItemTypeInterface << interface >> {
  + getItemType(): Type
}
class JacksonMapper {
  - ION_MAPPER: ObjectMapper
  + MAP_TYPE_REFERENCE: TypeReference<Map<String, Object>>
  - YAML_MAPPER: ObjectMapper
  + LIST_TYPE_REFERENCE: TypeReference<List<Object>>
  - MAPPER: ObjectMapper
  + OBJECT_TYPE_REFERENCE: TypeReference<Object>
  - NON_STRICT_MAPPER: ObjectMapper
  + toObject(String): Object
  + log(T): String
  + toMap(String): Map<String, Object>
  + ofIon(): ObjectMapper
  - createIonSystem(): IonSystem
  - configure(ObjectMapper): ObjectMapper
  + ofJson(): ObjectMapper
  + cast(Object, Class<T>): T
  + ofJson(boolean): ObjectMapper
  + toMap(Object): Map<String, Object>
  + ofYaml(): ObjectMapper
  + getBiDirectionalDiffs(Object, Object): Pair<JsonNode, JsonNode>
  + toMap(Object, Class<T>): T
  - createIonObjectMapper(): ObjectMapper
  + toMap(Object, ZoneId): Map<String, Object>
  + applyPatches(Object, List<JsonNode>): String
  + toList(String): List<Object>
}
class JacksonMapperTest {
  ~ pojo(): Pojo
  ~ test(Pojo, Pojo): void
  ~ ion(): void
  ~ json(): void
  ~ toList(): void
}
class JdbcCleaner {
  - configuration: Configuration
  # queueTable: Table<Record>
  - log: Logger
  - dslContextWrapper: JooqDSLContextWrapper
  + report(): void
  + deleteQueue(): void
}
class JdbcExecutor {
  - flowTopologyService: FlowTopologyService
  - executionRepository: AbstractJdbcExecutionRepository
  - workerJobRunningRepository: AbstractJdbcWorkerJobRunningRepository
  - workerTaskResultQueue: QueueInterface<WorkerTaskResult>
  - conditionService: ConditionService
  - executionService: ExecutionService
  - workerGroupService: WorkerGroupService
  - metricRegistry: MetricRegistry
  - executorStateStorage: AbstractJdbcExecutorStateStorage
  # flowListeners: FlowListenersInterface
  - executionDelayStorage: AbstractJdbcExecutionDelayStorage
  - executionQueue: QueueInterface<Execution>
  - skipExecutionService: SkipExecutionService
  - shutdown: AtomicBoolean
  - pluginDefaultService: PluginDefaultService
  - scheduledDelay: ScheduledExecutorService
  - runContextFactory: RunContextFactory
  - subflowExecutionResultQueue: QueueInterface<SubflowExecutionResult>
  - serviceLivenessCoordinator: JdbcServiceLivenessCoordinator
  - MAPPER: ObjectMapper
  - id: String
  - receiveCancellations: List<Runnable>
  - executionQueuedStorage: AbstractJdbcExecutionQueuedStorage
  - logQueue: QueueInterface<LogEntry>
  # killQueue: QueueInterface<ExecutionKilled>
  - eventPublisher: ApplicationEventPublisher<ServiceStateChangeEvent>
  - state: AtomicReference<ServiceState>
  - templateExecutorInterface: Optional<TemplateExecutorInterface>
  - flowTriggerService: FlowTriggerService
  - workerTaskQueue: QueueInterface<WorkerJob>
  - flowRepository: FlowRepositoryInterface
  - executorService: ExecutorService
  - flowTopologyRepository: AbstractJdbcFlowTopologyRepository
  - multipleConditionStorage: MultipleConditionStorageInterface
  - subflowExecutionStorage: AbstractJdbcSubflowExecutionStorage
  # allFlows: List<Flow>
  - logService: LogService
  - log: Logger
  - flowQueue: QueueInterface<Flow>
  - mayTransitExecutionToKillingStateAndGet(String): Executor
  - toExecution(Executor): void
  + getState(): ServiceState
  - executionQueue(Either<Execution, DeserializationException>): void
  + close(): void
  ~ reEmitWorkerJobsForWorkers(Configuration, List<String>): void
  - subflowExecutionResultQueue(Either<SubflowExecutionResult, DeserializationException>): void
  - workerTaskResultQueue(Either<WorkerTaskResult, DeserializationException>): void
  - killQueue(Either<ExecutionKilled, DeserializationException>): void
  - handleFailedExecutionFromExecutor(Executor, Exception): Executor
  + getType(): ServiceType
  + run(): void
  - transform(Flow, Execution): Flow
  - toExecution(Executor, boolean): void
  - executionDelaySend(): void
  - deduplicateWorkerTask(Execution, ExecutorState, TaskRun): boolean
  - deduplicateSubflowExecution(Execution, ExecutorState, TaskRun): boolean
  - deduplicationKey(TaskRun): String
  - sendSubflowExecutionResult(Execution, SubflowExecution<?>, TaskRun): void
  - deduplicateNexts(Execution, ExecutorState, List<TaskRun>): boolean
  - setState(ServiceState): void
  + getId(): String
}
class JdbcFlowRepositoryService {
  + findCondition(AbstractJdbcRepository<Flow>, String, Map<String, String>): Condition
  + lastRevision(AbstractJdbcRepository<Flow>, boolean): Table<Record>
  + findSourceCodeCondition(AbstractJdbcRepository<Flow>, String): Condition
}
class JdbcH2ControllerTest {
  # runnerUtils: RunnerUtils
  # repositoryLoader: LocalFlowRepositoryLoader
  - jdbcTestUtils: JdbcTestUtils
  # runner: StandAloneRunner
  # setup(): void
}
class JdbcIndexer {
  - log: Logger
  + getType(): ServiceType
  + run(): void
  + getId(): String
  + getState(): ServiceState
  + close(): void
}
interface JdbcIndexerInterface<T> << interface >> {
  + save(DSLContext, T): T
}
class JdbcMapper {
  - MAPPER: ObjectMapper
  - ZONED_DATE_TIME_FORMATTER: DateTimeFormatter
  - INSTANT_FORMATTER: DateTimeFormatter
  + of(): ObjectMapper
}
class JdbcMapperTest {
  ~ instant(): void
  ~ zoneDateTime(): void
  ~ zoneDateTimeMs(): void
}
class JdbcQueue<T> {
  # MAPPER: ObjectMapper
  # cls: Class<T>
  # dslContextWrapper: JooqDSLContextWrapper
  # jdbcQueueIndexer: JdbcQueueIndexer
  - MAX_ASYNC_THREADS: int
  # messageProtectionConfiguration: MessageProtectionConfiguration
  # queueService: QueueService
  # table: Table<Record>
  - log: Logger
  # configuration: Configuration
  - asyncPoolExecutor: ExecutorService
  - isClosed: AtomicBoolean
  - poolExecutor: ExecutorService
  # send(Result<Record>, Consumer<Either<T, DeserializationException>>): void
  + receive(String, Consumer<Either<T, DeserializationException>>, boolean): Runnable
  # queueName(Class<?>): String
  # poll(Supplier<Integer>): Runnable
  + close(): void
  + emit(String, T): void
  # receiveFetch(DSLContext, String, String, boolean): Result<Record>
  # receiveFetch(DSLContext, String, Integer): Result<Record>
  + emitOnly(String, T): void
  # map(Result<Record>): List<Either<T, DeserializationException>>
  + delete(String, T): void
  + receiveImpl(String, Class<?>, BiConsumer<DSLContext, List<Either<T, DeserializationException>>>, Boolean, boolean): Runnable
  # receiveFetch(DSLContext, String, String): Result<Record>
  - produce(String, String, T, Boolean): void
  + emitAsync(String, T): void
  # updateGroupOffsets(DSLContext, String, String, List<Integer>): void
  + receive(String, Class<?>, Consumer<Either<T, DeserializationException>>, boolean): Runnable
  # produceFields(String, String, T): Map<Field<Object>, Object>
  # receiveFetch(DSLContext, String, Integer, boolean): Result<Record>
  + receiveTransaction(String, Class<?>, BiConsumer<DSLContext, List<Either<T, DeserializationException>>>): Runnable
}
class JdbcQueueIndexer {
  - repositories: Map<Class<?>, JdbcIndexerInterface<?>>
  - log: Logger
  - metricRegistry: MetricRegistry
  # cast(Object): T
  + accept(DSLContext, Object): void
}
class JdbcQueueTest {
  ~ jdbcTestUtils: JdbcTestUtils
  # flowQueue: QueueInterface<Flow>
  ~ noGroup(): void
  ~ withGroupAndType(): void
  ~ withType(): void
  - builder(String): Flow
  ~ withGroup(): void
  # init(): void
}
annotation JdbcRepositoryEnabled << annotation >>
annotation JdbcRunnerEnabled << annotation >>
class JdbcRunnerRetryTest {
  - retryCaseTest: RetryCaseTest
  ~ jdbcTestUtils: JdbcTestUtils
  # runnerUtils: RunnerUtils
  # repositoryLoader: LocalFlowRepositoryLoader
  - runner: StandAloneRunner
  ~ retryFlowableNestedChild(): void
  ~ retryFailedFlowDuration(): void
  ~ retryNewExecutionTaskAttempts(): void
  ~ retrySubflow(): void
  ~ retryFail(): void
  ~ retryExpo(): void
  ~ retryFailed(): void
  ~ retrySuccess(): void
  ~ retryNewExecutionFlowAttempts(): void
  ~ retryFlowableChild(): void
  ~ init(): void
  ~ retryNewExecutionFlowDuration(): void
  ~ retryFailedFlowAttempts(): void
  ~ retryNewExecutionTaskDuration(): void
  ~ retrySuccessAtFirstAttempt(): void
  ~ retryFailedTaskAttempts(): void
  ~ retryFlowable(): void
  ~ retryDynamicTask(): void
  ~ retryFailedTaskDuration(): void
  ~ retryRandom(): void
  ~ retryFlowableParallel(): void
}
class JdbcRunnerTest {
  - restartCaseTest: RestartCaseTest
  - workingDirectoryTest: Suite
  - flowConcurrencyCaseTest: FlowConcurrencyCaseTest
  - multipleConditionTriggerCaseTest: MultipleConditionTriggerCaseTest
  - waitForTestCaseTest: WaitForCaseTest
  - flowIO: FlowInputOutput
  ~ jdbcTestUtils: JdbcTestUtils
  # repositoryLoader: LocalFlowRepositoryLoader
  - pauseTest: Suite
  - scheduleDateCaseTest: ScheduleDateCaseTest
  - flowTriggerCaseTest: FlowTriggerCaseTest
  - forEachItemCaseTest: ForEachItemCaseTest
  - pluginDefaultsCaseTest: PluginDefaultsCaseTest
  - skipExecutionCaseTest: SkipExecutionCaseTest
  - flowCaseTest: FlowCaseTest
  # runnerUtils: RunnerUtils
  - runner: StandAloneRunner
  - logsQueue: QueueInterface<LogEntry>
  + workerEach(): void
  ~ restartFailed(): void
  ~ eachParallelNested(): void
  ~ waitFor(): void
  + workerSuccess(): void
  ~ eachSequentialNested(): void
  ~ waitforMaxDuration(): void
  ~ eachParallel(): void
  # forEachItemFailed(): void
  ~ errors(): void
  # forEachItem(): void
  ~ waitforMultipleTasks(): void
  ~ workerTaskResultTooLarge(): void
  ~ flowTriggerWithPause(): void
  # forEachItemEmptyItems(): void
  ~ sequential(): void
  ~ executionDate(): void
  ~ eachWithNull(): void
  ~ flowTrigger(): void
  ~ concurrencyQueuePause(): void
  ~ concurrencyCancel(): void
  ~ waitforMultipleTasksFailed(): void
  ~ parallel(): void
  + pauseRunTimeout(): void
  ~ restartMultiple(): void
  # forEachItemSubflowOutputs(): void
  ~ eachParallelWithSubflowMissing(): void
  ~ init(): void
  ~ queueMessageTooLarge(): void
  ~ parallelNested(): void
  ~ multipleConditionTriggerFailed(): void
  ~ taskDefaults(): void
  ~ concurrencyQueue(): void
  ~ replay(): void
  ~ multipleConditionTrigger(): void
  + pauseRunDelay(): void
  ~ dynamicTask(): void
  ~ flowWaitFailed(): void
  ~ badExecutable(): void
  ~ logs(): void
  + pauseRun(): void
  ~ flowTooLarge(): void
  ~ concurrencyCancelPause(): void
  # forEachItemNoWait(): void
  + pauseRunParallelDelay(): void
  + invalidOutputs(): void
  ~ flowWaitSuccess(): void
  ~ shouldScheduleOnDate(): void
  ~ waitforNoSuccess(): void
  + workerFailed(): void
  ~ skipExecution(): void
  ~ waitforMaxIterations(): void
  ~ full(): void
  ~ concurrencyFail(): void
}
class JdbcScheduler {
  - executionQueue: QueueInterface<Execution>
  - dslContextWrapper: JooqDSLContextWrapper
  - triggerRepository: TriggerRepositoryInterface
  - flowRepository: FlowRepositoryInterface
  - conditionService: ConditionService
  - log: Logger
  + run(): void
  + handleNext(List<Flow>, ZonedDateTime, BiConsumer<List<Trigger>, ScheduleContextInterface>): void
}
class JdbcSchedulerContext {
  - context: DSLContext
  - dslContextWrapper: JooqDSLContextWrapper
  + getContext(): DSLContext
  + getDslContextWrapper(): JooqDSLContextWrapper
  + commit(): void
  + startTransaction(Consumer<ScheduleContextInterface>): void
}
class JdbcSchedulerTriggerState {
  # triggerRepository: AbstractJdbcTriggerRepository
  + updateExecution(Trigger): Trigger
  + findAllForAllTenants(): List<Trigger>
  + update(Flow, AbstractTrigger, ConditionContext): Trigger
  + create(Trigger): Trigger
  + findByNextExecutionDateReadyForAllTenants(ZonedDateTime, ScheduleContextInterface): List<Trigger>
  + update(Trigger): Trigger
  + unlock(Trigger): void
  + findByNextExecutionDateReadyForGivenFlows(List<Flow>, ZonedDateTime, ScheduleContextInterface): List<Trigger>
  + findLast(TriggerContext): Optional<Trigger>
  + initTriggerEvaluateRunning(): void
  + save(Trigger, ScheduleContextInterface): Trigger
}
class JdbcServiceLivenessCoordinator {
  - executor: AtomicReference<JdbcExecutor>
  - log: Logger
  - serviceInstanceRepository: AbstractJdbcServiceInstanceRepository
  - mayLogNonRespondingAfterTerminationGracePeriod(ServiceInstance, Instant): void
  # onSchedule(Instant): void
  ~ setExecutor(JdbcExecutor): void
  ~ setServerInstance(String): void
}
class JdbcServiceLivenessCoordinatorTest {
  ~ jdbcServiceLivenessHandler: JdbcServiceLivenessCoordinator
  ~ jdbcTestUtils: JdbcTestUtils
  ~ skipExecutionService: SkipExecutionService
  ~ workerTaskResultQueue: QueueInterface<WorkerTaskResult>
  - applicationContext: ApplicationContext
  - runner: StandAloneRunner
  ~ runContextFactory: RunContextFactory
  ~ workerJobQueue: QueueInterface<WorkerJob>
  ~ workerTriggerResultQueue: QueueInterface<WorkerTriggerResult>
  - repositoryLoader: LocalFlowRepositoryLoader
  ~ shouldReEmitTasksWhenWorkerIsDetectedAsNonResponding(): void
  ~ shouldReEmitTriggerWhenWorkerIsDetectedAsNonResponding(): void
  ~ taskResubmitSkipExecution(): void
  - workerTrigger(Duration): WorkerTrigger
  ~ init(): void
  - flowBuilder(Duration): Flow
  - workerTask(Duration): WorkerTask
}
class JdbcServiceLivenessManager {
  - log: Logger
  # beforeScheduledStateUpdate(Instant, Service, ServiceInstance): boolean
  - getElapsedMilliSinceLastStateUpdate(Instant): long
  - isWorkerServer(): boolean
  + onServiceStateChangeEvent(ServiceStateChangeEvent): void
  - isServerDisconnected(Instant): boolean
}
class JdbcServiceLivenessManagerTest {
  - serviceLivenessManager: JdbcServiceLivenessManager
  - DEFAULT_DURATION: Duration
  + repository: ServiceInstanceRepositoryInterface
  - context: KestraContext
  ~ beforeEach(): void
  ~ shouldRunOnStateTransitionFailureWhenTimeoutForWorker(): void
}
class JdbcTableConfig {
  - name: String
  - cls: Class<?>
  - table: String
  + cls(): Class<?>
  + name(): String
  + table(): String
}
class JdbcTableConfigs {
  - tableConfigs: List<JdbcTableConfig>
  + tableConfig(Class<?>): JdbcTableConfig
  + getTableConfigs(): List<JdbcTableConfig>
  + tableConfig(String): JdbcTableConfig
}
class JdbcTableConfigsFactory {
  + multipleConditions(): InstantiableJdbcTableConfig
  + executionQueued(): InstantiableJdbcTableConfig
  + flows(): InstantiableJdbcTableConfig
  + logs(): InstantiableJdbcTableConfig
  + subflowExecutions(): InstantiableJdbcTableConfig
  + triggers(): InstantiableJdbcTableConfig
  + executions(): InstantiableJdbcTableConfig
  + queues(): InstantiableJdbcTableConfig
  + settings(): InstantiableJdbcTableConfig
  + executorDelayed(): InstantiableJdbcTableConfig
  + metrics(): InstantiableJdbcTableConfig
  + executorState(): InstantiableJdbcTableConfig
  + templates(): InstantiableJdbcTableConfig
  + workerJobRunning(): InstantiableJdbcTableConfig
  + serviceInstance(): InstantiableJdbcTableConfig
  + flowTopologies(): InstantiableJdbcTableConfig
}
class JdbcTemplateRunnerTest {
  - templateRepository: TemplateRepositoryInterface
  - logsQueue: QueueInterface<LogEntry>
  ~ jdbcTestUtils: JdbcTestUtils
  # runnerUtils: RunnerUtils
  - flowIO: FlowInputOutput
  # repositoryLoader: LocalFlowRepositoryLoader
  - runner: StandAloneRunner
  ~ withFailedTemplate(): void
  ~ withTemplate(): void
  ~ init(): void
}
class JdbcTestUtils {
  - tableConfigs: JdbcTableConfigs
  # dslContextWrapper: JooqDSLContextWrapper
  - config: FlywayConfigurationProperties
  - dataSource: DataSource
  - flywayMigrator: FlywayMigrator
  ~ tables: List<Table<?>>
  + migrate(): void
  + drop(): void
  + setup(): void
}
class JdbcWorkerJobQueueService {
  - log: Logger
  - workerTaskQueue: JdbcQueue<WorkerJob>
  - jdbcWorkerJobRunningRepository: AbstractJdbcWorkerJobRunningRepository
  - disposable: AtomicReference<Runnable>
  - isStopped: AtomicBoolean
  - serviceRegistry: ServiceRegistry
  + receive(String, Class<?>, Consumer<Either<WorkerJob, DeserializationException>>): Runnable
  + close(): void
}
class JdbcWorkerTriggerResultQueueService {
  - disposable: AtomicReference<Runnable>
  - MAPPER: ObjectMapper
  - jdbcWorkerJobRunningRepository: AbstractJdbcWorkerJobRunningRepository
  - log: Logger
  - isClosed: AtomicBoolean
  - queueStop: Runnable
  - workerTriggerResultQueue: JdbcQueue<WorkerTriggerResult>
  + close(): void
  + receive(String, Class<?>, Consumer<Either<WorkerTriggerResult, DeserializationException>>): Runnable
}
class JooqDSLContextWrapper {
  - retryUtils: RetryUtils
  - dslContext: DSLContext
  - retryer(): Instance<T, RuntimeException>
  + transaction(TransactionalRunnable): void
  + transactionResult(TransactionalCallable<T>): T
  - predicate(): Predicate<E>
}
class JooqExecuteListenerFactory {
  - log: Logger
  + jooqConfiguration(MetricRegistry): ExecuteListenerProvider
}
class JooqSettings {
  + settings(): Settings
}
class JqFilter {
  - argumentNames: List<String>
  - scope: Scope
  + getArgumentNames(): List<String>
  + apply(Object, Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
}
class JqFilterTest {
  ~ variableRenderer: VariableRenderer
  ~ typed(): void
  ~ simple(): void
  ~ object(): void
  ~ map(): void
  ~ list(): void
  ~ fromString(): void
}
class JsonFilter {
  - log: Logger
  + apply(Object, Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
}
class JsonFunction {
  - log: Logger
  + execute(Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
}
class JsonInput {
  + builder(): JsonInputBuilder<?, ?>
  + validate(Object): void
}
class JsonSchemaGenerator {
  - pluginRegistry: PluginRegistry
  ~ defaultInstances: Map<Class<?>, Object>
  - mutateDescription(ObjectNode): void
  - defaultInAllOf(JsonNode): boolean
  - safelyResolveSubtype(ResolvedType, Class<?>, TypeContext): Optional<ResolvedType>
  - defaultValue(Object, Class<?>, String): Object?
  # getRegisteredPlugins(): List<RegisteredPlugin>
  + properties(Class<T>, Class<T>): Map<String, Object>
  - buildDefaultInstance(Class<?>): Object?
  + outputs(Class<T>, Class<T>): Map<String, Object>
  # generate(Class<T>, Class<T>): Map<String, Object>
  - extractMainRef(ObjectNode): ObjectNode
  + schemas(Class<T>): Map<String, Object>
  - replaceAnyOfWithOneOf(ObjectNode): void
  # defaults(FieldScope): Object
  - addMainRefProperties(JsonNode, ObjectNode): void
  # build(SchemaGeneratorConfigBuilder, boolean): void
  + schemas(Class<T>, boolean): Map<String, Object>
}
class JsonSchemaGeneratorTest {
  ~ pluginRegistry: PluginRegistry
  ~ jsonSchemaGenerator: JsonSchemaGenerator
  ~ testEnum(): void
  ~ task(): void
  ~ trigger(): void
  ~ flow(): void
  ~ betaTask(): void
  + beforeAll(): void
  ~ tasks(): void
  ~ returnTask(): void
  ~ echoTask(): void
  - map(Object): Map<String, Object>
  ~ dag(): void
  - properties(Map<String, Object>): Map<String, Map<String, Object>>
}
annotation JsonString << annotation >> {
  + message(): String
  + groups(): Class<?>[]
  + payload(): Class<Payload>[]
}
class JsonStringTest {
  - modelValidator: ModelValidator
  ~ jsonString(): void
}
class JsonStringValidator {
  - OBJECT_MAPPER: ObjectMapper
  + isValid(String, AnnotationValue<JsonString>, ConstraintValidatorContext): boolean
}
class JsonTest {
  + apply(Object, Map<String, Object>, PebbleTemplate, EvaluationContext, int): boolean
  + getArgumentNames(): List<String>
}
class JsonWriter {
  - stringWriter: StringWriter
  - MAPPER: ObjectMapper
  + writeSpecialized(float): void
  + close(): void
  + writeSpecialized(String): void
  + writeSpecialized(long): void
  + write(char[], int, int): void
  + writeSpecialized(byte): void
  + writeSpecialized(int): void
  + flush(): void
  + toString(): String
  + output(): Object
  + writeSpecialized(short): void
  + writeSpecialized(double): void
  + writeSpecialized(char): void
  + write(Object): void
}
class KVController {
  - storageInterface: StorageInterface
  - tenantService: TenantService
  + delete(String, String): boolean
  + list(String): List<KVEntry>
  + put(HttpHeaders, String, String, String): void
  + get(String, String): TypedValue
  - kvStore(String): KVStore
}
class KVControllerTest {
  - storageInterface: StorageInterface
  ~ client: ReactorHttpClient
  - NAMESPACE: String
  ~ put(MediaType, String, Class<?>): void
  ~ delete(): void
  ~ illegalKey(): void
  ~ kvPutArgs(): Stream<Arguments>
  ~ get(String, KVType, String): void
  ~ getNotFound(): void
  - toKVUri(String, String): URI
  ~ list(): void
  ~ getExpired(): void
  ~ kvGetArgs(): Stream<Arguments>
  + init(): void
}
entity KVEntry << record >> {
  - key: String
  - creationDate: Instant
  - updateDate: Instant
  - expirationDate: Instant
  + key(): String
  + from(FileAttributes): KVEntry
  + creationDate(): Instant
  + expirationDate(): Instant
  + updateDate(): Instant
}
class KVMetadata {
  - expirationDate: Instant
  + getExpirationDate(): Instant
  + toMap(): Map<String, String>
}
interface KVStore << interface >> {
  + KEY_VALIDATOR_PATTERN: Pattern
  + put(String, KVValueAndMetadata, boolean): void
  + getValue(String): Optional<KVValue>
  + namespace(): String
  + storageUri(String, String): URI
  + storageUri(String): URI
  + delete(String): boolean
  + list(): List<KVEntry>
  + validateKey(String): void
  + put(String, KVValueAndMetadata): void
  + get(String): Optional<KVEntry>
  + exists(String): boolean
}
class KVStoreException {
  - serialVersionUID: long
}
class KVStoreService {
  - storageInterface: StorageInterface
  - flowService: FlowService
  - namespaceService: NamespaceService
  - isNotParentNamespace(String, String): boolean
  + get(String, String, String?): KVStore
}
class KVStoreServiceTest {
  ~ flowRepository: FlowRepositoryInterface
  - TEST_EXISTING_NAMESPACE: String
  ~ storeService: KVStoreService
  ~ shouldGetKVStoreForAnyNamespaceWhenAccessingFromChildNamespace(): void
  ~ shouldThrowExceptionWhenAccessingKVStoreForNonExistingNamespace(): void
  ~ shouldGetKVStoreForExistingNamespaceGivenFromNull(): void
}
enum KVType << enumeration >> {
  + BOOLEAN:
  + NUMBER:
  + DATE:
  + JSON:
  + STRING:
  + DATETIME:
  + DURATION:
  + from(Object): KVType
  + valueOf(String): KVType
  + values(): KVType[]
}
entity KVValue << record >> {
  - value: Object?
  + toString(): String
  + value(): Object?
}
entity KVValueAndMetadata << record >> {
  - value: Object?
  - metadata: KVMetadata?
  ~ from(StorageObject): KVValueAndMetadata
  + value(): Object?
  + metadataAsMap(): Map<String, String>
  + metadata(): KVMetadata?
}
class KestraBeansFactory {
  ~ storageType: Optional<String>
  ~ validator: Validator
  ~ storageConfig: StorageConfig
  + storageInterface(PluginRegistry): StorageInterface
  + pluginRegistry(): PluginRegistry
}
class KestraContext {
  - KESTRA_SERVER_TYPE: String
  - log: Logger
  - INSTANCE: AtomicReference<KestraContext>
  + getContext(): KestraContext
  + getServerType(): ServerType
  + shutdown(): void
  + getPluginRegistry(): PluginRegistry
  + setContext(KestraContext): void
  + getVersion(): String
}
class KestraIgnore {
  - gitIgnore: GitIgnore
  - rootFolderPath: Path
  + KESTRA_IGNORE_FILE_NAME: String
  + isIgnoredFile(String, boolean): boolean
}
class KestraRuntimeException {
  - serialVersionUID: long
}
annotation KestraTest << annotation >> {
  + rollback(): boolean
  + contextBuilder(): Class<ApplicationContextBuilder>[]
  + startApplication(): boolean
  + transactional(): boolean
  + transactionMode(): TransactionMode
  + rebuildContext(): boolean
  + resolveParameters(): boolean
  + environments(): String[]
  + propertySources(): String[]
  + packages(): String[]
  + application(): Class<?>
}
class KestraTestExtension {
  - NAMESPACE: Namespace
  # getStore(ExtensionContext): Store
  # hasExpectedAnnotations(Class<?>): boolean
  # buildMicronautTestValue(Class<?>): MicronautTestValue
}
class KeysFilter {
  + apply(Object, Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
  + getArgumentNames(): List<String>
}
class KeysFilterTest {
  ~ variableRenderer: VariableRenderer
  ~ map(): void
}
class KvCommand {
  - log: Logger
  + call(): Integer
}
class KvCommandTest {
  ~ runWithNoParam(): void
}
class KvFunction {
  - kvStoreService: KVStoreService
  - flowService: FlowService
  - log: Logger
  # getKey(Map<String, Object>, PebbleTemplate, int): String
  + getArgumentNames(): List<String>
  + execute(Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
}
class KvFunctionTest {
  - runnerUtils: RunnerUtils
  - storageInterface: StorageInterface
  - logQueue: QueueInterface<LogEntry>
  ~ get(): void
  ~ reset(): void
  ~ getKeyNotFound(): void
}
class KvUpdateCommand {
  - log: Logger
  + type: Type
  + value: String
  + fileValue: Path
  + key: String
  + expiration: String
  + namespace: String
  + wrapAsJsonLiteral(String): String
  - isLiteral(String): boolean
  + call(): Integer
}
class KvUpdateCommandTest {
  ~ integerStr(): void
  ~ fromFile(): void
  ~ integer(): void
  ~ objectStr(): void
  ~ string(): void
  ~ object(): void
}
entity Label << record >> {
  - key: String
  - value: String
  + key(): String
  + value(): String
}
class Labels {
  - labels: Object
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getLabels(): Object
  + toString(): String
  + builder(): LabelsBuilder<?, ?>
  + update(Execution, RunContext): Execution
}
class ListOrMapOfLabelDeserializer {
  + deserialize(JsonParser, DeserializationContext): List<Label>
  + resolve(DeserializationContext): void
}
class ListOrMapOfLabelSerializer {
  + serialize(Object, JsonGenerator, SerializerProvider): void
}
class ListUtils {
  + isEmpty(List<T>): boolean
  + emptyOnNull(List<T>): List<T>
}
class ListUtilsTest {
  ~ emptyOnNull(): void
  ~ isEmpty(): void
}
class Listener {
  - description: String
  - tasks: List<Task>
  - conditions: List<Condition>
  + builder(): ListenerBuilder
  + getDescription(): String
  + getConditions(): List<Condition>
  + getTasks(): List<Task>
  + equals(Object): boolean
  + hashCode(): int
  + toString(): String
}
class ListenersTest {
  ~ failed(): void
  ~ failedListeners(): void
  ~ initListeners(): void
  ~ multipleListeners(): void
  ~ success(): void
  ~ failedMultipleListeners(): void
  ~ flowableExecution(): void
}
class ListenersTestTask {
  + run(RunContext): Output
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + toString(): String
  + builder(): ListenersTestTaskBuilder<?, ?>
}
class LocalCommand {
  - applicationContext: ApplicationContext
  + propertiesOverrides(): Map<String, Object>
}
class LocalFileAttributes {
  - filePath: Path
  - basicFileAttributes: BasicFileAttributes
  + getType(): FileType
  + builder(): LocalFileAttributesBuilder
  + getFilePath(): Path
  + getBasicFileAttributes(): BasicFileAttributes
  + equals(Object): boolean
  + hashCode(): int
  + toString(): String
  + getCreationTime(): long
  + getMetadata(): Map<String, String>
  + getMetadata(Path): Map<String, String>?
  + getSize(): long
  + getLastModifiedTime(): long
  + getFileName(): String
}
class LocalFiles {
  - inputs: Object
  - outputs: List<String>
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getInputs(): Object
  + getOutputs(): List<String>
  + toString(): String
  + builder(): LocalFilesBuilder<?, ?>
  + run(RunContext): LocalFilesOutput
}
class LocalFilesTest {
  ~ runContextFactory: RunContextFactory
  ~ storageInterface: StorageInterface
  ~ run(): void
  ~ failWithExistingInputFile(): void
  ~ recursive(): void
  - internalFiles(): URI
}
class LocalFlowRepositoryLoader {
  - flowRepository: FlowRepositoryInterface
  - yamlFlowParser: YamlFlowParser
  - pluginDefaultService: PluginDefaultService
  - modelValidator: ModelValidator
  - log: Logger
  + load(URL): void
  + load(File): void
  - createFlow(String, Flow): void
  - udpateFlow(String, Flow, Flow): void
}
entity LocalServiceState << record >> {
  - instance: ServiceInstance
  - isStateUpdatable: AtomicBoolean
  - service: Service
  + with(ServiceInstance): LocalServiceState
  + service(): Service
  + isStateUpdatable(): AtomicBoolean
  + instance(): ServiceInstance
}
class LocalServiceStateFactory {
  - serverInstanceFactory: ServerInstanceFactory
  - serverConfig: ServerConfig
  + newLocalServiceState(Service, Map<String, Object>?): LocalServiceState
}
class LocalStorage {
  - log: Logger
  - basePath: Path
  + getBasePath(): Path
  + setBasePath(Path): void
  - getPath(String, URI): Path
  + move(String, URI, URI): URI
  + getAttributes(String, URI): FileAttributes
  + list(String, URI): List<FileAttributes>
  - parentTraversalGuard(URI): void
  + init(): void
  + getWithMetadata(String, URI): StorageObject
  + put(String, URI, StorageObject): URI
  + allByPrefix(String, URI, boolean): List<URI>
  + deleteByPrefix(String, URI): List<URI>
  + get(String, URI): InputStream
  - getKestraUri(String, Path): URI
  + exists(String, URI): boolean
  + delete(String, URI): boolean
  + createDirectory(String, URI): URI
}
class LocalStorageTest
class LocalWorkingDir {
  - workingDirPath: Path
  - workingDirId: String
  + path(boolean): Path
  + createTempFile(byte[], String): Path
  + createTempFile(byte[]): Path
  + createFile(String, byte[]): Path
  + putFile(Path, InputStream): Path
  + findAllFilesMatching(List<String>): List<Path>
  + path(): Path
  + createTempFile(String): Path
  + createFile(String): Path
  + resolve(Path): Path
  + createTempFile(): Path
  + createFile(String, InputStream): Path
  + id(): String
  + cleanup(): void
}
class LocalWorkingDirTest {
  ~ shouldFindAllFilesMatchingPatterns(): void
  ~ shouldCreatedTempFile(): void
  ~ shouldThrowExceptionGivenFileAlreadyExist(): void
  ~ shouldReturnWorkingDirPathGivenWorkingDirId(): void
  ~ shouldRecreateDirectoryAfterCleanup(): void
  ~ shouldResolvePathFromWorkingDir(): void
  ~ shouldCreateFile(): void
  ~ shouldReturnTheSameWorkingDirPath(): void
}
class Log {
  - message: Object
  - level: Level
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getMessage(): Object
  + getLevel(): Level
  + toString(): String
  - $default$level(): Level
  + builder(): LogBuilder<?, ?>
  + run(RunContext): VoidOutput
  + log(Logger, Level, String): void
}
class LogConsumerTest {
  - TASK: Task
  - runContextFactory: RunContextFactory
  - logQueue: QueueInterface<LogEntry>
  ~ logs(): void
  ~ run(): void
  ~ testWithMultipleCrInSameFrame(): void
}
class LogController {
  - tenantService: TenantService
  - logRepository: LogRepositoryInterface
  # logQueue: QueueInterface<LogEntry>
  + find(String, int, int, List<String>, String, String, String, Level, ZonedDateTime, ZonedDateTime): PagedResults<LogEntry>
  + delete(String, Level, String, String, Integer): void
  + findByExecution(String, Level, String, String, Integer): List<LogEntry>
  + follow(String, Level): Flux<Event<LogEntry>>
  + deleteFromFlow(String, String, String): void
  + download(String, Level, String, String, Integer): StreamedFile
}
class LogControllerTest {
  ~ client: ReactorHttpClient
  ~ sseClient: ReactorSseClient
  - logRepository: LogRepositoryInterface
  ~ deleteByQuery(): void
  ~ delete(): void
  ~ find(): void
  ~ findByExecution(): void
  ~ download(): void
  - logEntry(Level): LogEntry
}
class LogEntry {
  - executionId: String
  - attemptNumber: Integer
  - level: Level
  - message: String
  - taskRunId: String
  - tenantId: String
  - flowId: String
  - thread: String
  - taskId: String
  - triggerId: String
  - namespace: String
  - deleted: boolean
  - timestamp: Instant
  - $default$deleted(): boolean
  + of(Execution): LogEntry
  + builder(): LogEntryBuilder
  + toBuilder(): LogEntryBuilder
  + getTenantId(): String
  + getTaskRunId(): String
  + getNamespace(): String
  + getFlowId(): String
  + isDeleted(): boolean
  + getAttemptNumber(): Integer
  + equals(Object): boolean
  + toString(): String
  + getMessage(): String
  + getTaskId(): String
  + getTriggerId(): String
  + hashCode(): int
  + getLevel(): Level
  + getThread(): String
  + getExecutionId(): String
  + getTimestamp(): Instant
  + of(TriggerContext, AbstractTrigger): LogEntry
  + of(TaskRun): LogEntry
  + toMap(): Map<String, String>
  + findLevelsByMin(Level): List<Level>
  + of(Flow, AbstractTrigger): LogEntry
  + toPrettyString(LogEntry): String
}
interface LogRepositoryInterface << interface >> {
  + findByExecutionIdAndTaskRunIdAndAttempt(String, String, String, Level, Integer, Pageable): ArrayListTotal<LogEntry>
  + deleteByQuery(String, String, String, List<Level>, ZonedDateTime, ZonedDateTime): int
  + findByExecutionIdAndTaskId(String, String, String, Level): List<LogEntry>
  + findByExecutionId(String, String, Level): List<LogEntry>
  + findByExecutionIdAndTaskRunId(String, String, String, Level, Pageable): ArrayListTotal<LogEntry>
  + purge(Execution): Integer
  + findByExecutionId(String, String, String, String, Level): List<LogEntry>
  + find(Pageable, String?, String?, String?, String?, String?, Level?, ZonedDateTime?, ZonedDateTime?): ArrayListTotal<LogEntry>
  + findByExecutionIdAndTaskRunId(String, String, String, Level): List<LogEntry>
  + findByExecutionIdAndTaskRunIdAndAttempt(String, String, String, Level, Integer): List<LogEntry>
  + findByExecutionId(String, String, Level, Pageable): ArrayListTotal<LogEntry>
  + deleteByQuery(String, String, String, String, Level, Integer): void
  + save(LogEntry): LogEntry
  + deleteByQuery(String, String, String, String): void
  + findByExecutionIdAndTaskId(String, String, String, Level, Pageable): ArrayListTotal<LogEntry>
  + findByExecutionIdAndTaskId(String, String, String, String, String, Level): List<LogEntry>
  + statistics(String?, String?, String?, String?, Level?, ZonedDateTime?, ZonedDateTime?, GroupType?): List<LogStatistics>
}
class LogService {
  - TRIGGER_PREFIX_WITH_TENANT: String
  - TRIGGER_PREFIX_NO_TENANT: String
  - TASKRUN_PREFIX_WITH_TENANT: String
  - EXECUTION_PREFIX_NO_TENANT: String
  ~ logRepository: LogRepositoryInterface
  - EXECUTION_PREFIX_WITH_TENANT: String
  - TASKRUN_PREFIX_NO_TENANT: String
  - FLOW_PREFIX_NO_TENANT: String
  - tenantEnabled: boolean
  - FLOW_PREFIX_WITH_TENANT: String
  + logTrigger(TriggerContext, Logger, Level, String, Object[]): void
  + logExecution(Execution, Logger, Level, String, Object[]): void
  + logTaskRun(TaskRun, Logger, Level, String, Object[]): void
  + purge(String, String, String, List<Level>, ZonedDateTime, ZonedDateTime): int
  + logFlow(Flow, Logger, Level, String, Object[]): void
}
class LogServiceTest {
  - log: Logger
  - logService: LogService
  ~ logTrigger(): void
  ~ logTaskRun(): void
  ~ logExecution(): void
  ~ logFlow(): void
}
class LogStatistics {
  - counts: Map<Level, Long>
  - groupBy: String
  # timestamp: Instant
  # canEqual(Object): boolean
  + getTimestamp(): Instant
  + getCounts(): Map<Level, Long>
  - $default$counts(): Map<Level, Long>
  + getGroupBy(): String
  + setTimestamp(Instant): void
  + builder(): LogStatisticsBuilder
  + setCounts(Map<Level, Long>): void
  + setGroupBy(String): void
  + equals(Object): boolean
  + toBuilder(): LogStatisticsBuilder
  + hashCode(): int
  + toString(): String
}
class LogToFileTest {
  - storage: StorageInterface
  ~ task(): void
}
class ManualConstraintViolation<T> {
  - propertyPath: Path
  - invalidValue: Object
  - message: String
  - rootBean: T
  - rootBeanClass: Class<T>
  - leafBean: Object
  + getMessage(): String
  + getRootBean(): T
  + getRootBeanClass(): Class<T>
  + getLeafBean(): Object
  + getPropertyPath(): Path
  + getInvalidValue(): Object
  + toConstraintViolationException(String, T, Class<T>, String, Object): ConstraintViolationException
  + of(String, T, Class<T>, String, Object): ManualConstraintViolation<T>
  + getMessageTemplate(): String
  + unwrap(Class<C>): C
  + getExecutableParameters(): Object[]
  + getExecutableReturnValue(): Object
  + getConstraintDescriptor(): ConstraintDescriptor<?>
}
class ManualPath {
  ~ nodes: Deque<Node>
  + toString(): String
  + iterator(): Iterator<Node>
}
class ManualPropertyNode {
  - index: Integer
  - kind: ElementKind
  - containerClass: Class<?>
  - inIterable: boolean
  - name: String
  - key: Object
  + getTypeArgumentIndex(): Integer
  + getContainerClass(): Class<?>
  + getName(): String
  + getIndex(): Integer
  + getKey(): Object
  + getKind(): ElementKind
  + isInIterable(): boolean
  + as(Class<T>): T
}
class MapUtils {
  + merge(Map<String, Object>, Map<String, Object>): Map<String, Object>
  + mergeWithNullableValues(Map<String, Object>[]): Map<String, Object>
  + emptyOnNull(Map<K, V>): Map<K, V>
  - cloneCollection(Collection): Collection
  + flattenToNestedMap(Map<String, ?>): Map<String, Object>
  + newHashMap(int): HashMap<K, V>
  - copyMap(Map): Map
  - cloneMap(Map): Map
}
class MapUtilsTest {
  ~ shouldReturnMapWhenNestingMapGivenFlattenMap(): void
  ~ emptyOnNull(): void
  ~ shouldThrowExceptionWhenNestingMapGivenFlattenMapWithConflicts(): void
  ~ shouldMergeWithNullableValuesGivenNullAndDuplicate(): void
  ~ mergeWithNull(): void
  ~ merge(): void
}
class Memory {
  - memory: String
  - memorySwap: String
  - oomKillDisable: Boolean
  - memoryReservation: String
  - kernelMemory: String
  - memorySwappiness: String
  + getMemory(): String
  + getMemorySwap(): String
  + getMemorySwappiness(): String
  + getMemoryReservation(): String
  + getKernelMemory(): String
  + getOomKillDisable(): Boolean
  + builder(): MemoryBuilder<?, ?>
}
class MemoryRepositoryTest {
  - yamlFlowParser: YamlFlowParser
  - flowRepositoryInterface: FlowRepositoryInterface
  ~ verifyMemoryFallbacksToH2(): void
}
class MessageProtectionConfiguration {
  ~ enabled: boolean
  ~ limit: Integer
  + isEnabled(): boolean
  + getLimit(): Integer
}
class MessageTooBigException {
  - serialVersionUID: long
}
entity Metric << record >> {
  - value: Object
  - type: String
  - tags: List<Tag>
  - name: String
  - baseUnit: String
  - description: String
  + name(): String
  + description(): String
  + value(): Object
  + type(): String
  + tags(): List<Tag>
  + baseUnit(): String
  + of(Meter): Metric
}
annotation Metric1 << annotation >> {
  + name(): String
  + type(): String
  + description(): String
  + unit(): String
}
class MetricAggregation {
  + name: String
  + value: Double
  + date: Instant
  + builder(): MetricAggregationBuilder
}
class MetricAggregations {
  + aggregations: List<MetricAggregation>
  + groupBy: String
  + getGroupBy(): String
  + getAggregations(): List<MetricAggregation>
  + builder(): MetricAggregationsBuilder
}
class MetricConfig {
  ~ prefix: String
  ~ tags: Map<String, String>
  + getPrefix(): String
  + getTags(): Map<String, String>
}
class MetricController {
  - metricsRepository: MetricRepositoryInterface
  - tenantService: TenantService
  # metricQueue: QueueInterface<MetricEntry>
  + tasks(String, String): List<String>
  + flowMetrics(String, String): List<String>
  + taskMetrics(String, String, String): List<String>
  + findByExecution(int, int, List<String>, String, String, String): PagedResults<MetricEntry>
  + aggregateByFlowIdAndTaskId(String, String, String, String, ZonedDateTime, ZonedDateTime, String): MetricAggregations
  + aggregateByFlowId(String, String, String, ZonedDateTime, ZonedDateTime, String): MetricAggregations
}
class MetricControllerTest {
  ~ client: ReactorHttpClient
  ~ jdbcMetricRepository: AbstractJdbcMetricRepository
  - TESTS_FLOW_NS: String
  - triggerExecution(String, String, MultipartBody, Boolean): Execution
  ~ findByExecution(): void
}
class MetricEntry {
  - flowId: String
  - value: Double
  - tenantId: String
  - taskId: String
  - type: String
  - tags: Map<String, String>
  - deleted: boolean
  - executionId: String
  - name: String
  - namespace: String
  - timestamp: Instant
  - taskRunId: String
  + getFlowId(): String
  + hashCode(): int
  + getType(): String
  + getTags(): Map<String, String>
  - $default$deleted(): boolean
  + getTimestamp(): Instant
  + equals(Object): boolean
  + toString(): String
  + builder(): MetricEntryBuilder
  + toBuilder(): MetricEntryBuilder
  + getName(): String
  + isDeleted(): boolean
  + getTenantId(): String
  + getNamespace(): String
  + getValue(): Double
  + getTaskId(): String
  + getExecutionId(): String
  + getTaskRunId(): String
  - computeValue(AbstractMetricEntry<?>): Double
  + of(TaskRun, AbstractMetricEntry<?>): MetricEntry
}
class MetricRegistry {
  + SCHEDULER_TRIGGER_COUNT: String
  - meterRegistry: MeterRegistry
  - log: Logger
  + METRIC_WORKER_ENDED_COUNT: String
  + METRIC_INDEXER_MESSAGE_IN_COUNT: String
  + TAG_WORKER_GROUP: String
  - metricConfig: MetricConfig
  + METRIC_WORKER_TRIGGER_STARTED_COUNT: String
  + METRIC_WORKER_TRIGGER_ENDED_COUNT: String
  + METRIC_WORKER_TRIGGER_DURATION: String
  + SCHEDULER_TRIGGER_DELAY_DURATION: String
  + EXECUTOR_TASKRUN_NEXT_COUNT: String
  + EXECUTOR_TASKRUN_ENDED_DURATION: String
  + METRIC_WORKER_JOB_PENDING_COUNT: String
  + EXECUTOR_EXECUTION_END_COUNT: String
  + EXECUTOR_EXECUTION_DURATION: String
  + METRIC_WORKER_TIMEOUT_COUNT: String
  + METRIC_INDEXER_MESSAGE_FAILED_COUNT: String
  + SCHEDULER_EXECUTION_RUNNING_DURATION: String
  + METRIC_WORKER_TRIGGER_EXECUTION_COUNT: String
  + JDBC_QUERY_DURATION: String
  + SCHEDULER_EXECUTION_MISSING_DURATION: String
  + TAG_TASK_TYPE: String
  + METRIC_WORKER_RUNNING_COUNT: String
  + METRIC_INDEXER_REQUEST_DURATION: String
  + TAG_STATE: String
  + TAG_TRIGGER_TYPE: String
  + TAG_ATTEMPT_COUNT: String
  + EXECUTOR_EXECUTION_STARTED_COUNT: String
  + TAG_NAMESPACE_ID: String
  + METRIC_WORKER_TRIGGER_RUNNING_COUNT: String
  + EXECUTOR_TASKRUN_ENDED_COUNT: String
  + METRIC_INDEXER_SERVER_DURATION: String
  + METRIC_INDEXER_REQUEST_COUNT: String
  + TAG_FLOW_ID: String
  + TAG_TENANT_ID: String
  + METRIC_WORKER_JOB_THREAD_COUNT: String
  + METRIC_INDEXER_MESSAGE_OUT_COUNT: String
  + METRIC_WORKER_ENDED_DURATION: String
  + METRIC_WORKER_JOB_RUNNING_COUNT: String
  + METRIC_WORKER_QUEUED_DURATION: String
  + SCHEDULER_EVALUATE_COUNT: String
  + METRIC_WORKER_STARTED_COUNT: String
  + EXECUTOR_WORKERTASKRESULT_COUNT: String
  + METRIC_INDEXER_REQUEST_RETRY_COUNT: String
  + METRIC_WORKER_TRIGGER_ERROR_COUNT: String
  + SCHEDULER_LOOP_COUNT: String
  + STREAMS_STATE_COUNT: String
  + bind(MeterBinder): void
  + gauge(String, T, String[]): T
  + tags(Execution): String[]
  + findGauge(String): Gauge
  + tags(TriggerContext): String[]
  + timer(String, String[]): Timer
  + findTimer(String): Timer
  + tags(WorkerTask, String, String[]): String[]
  + tags(AbstractTrigger): String[]
  + findCounter(String): Counter
  - metricName(String): String
  + tags(SubflowExecutionResult, String[]): String[]
  + tags(WorkerTrigger, String, String[]): String[]
  + tags(WorkerTaskResult, String[]): String[]
  + tags(String[]): Tags
  + findDistributionSummary(String): DistributionSummary
  + tags(SchedulerExecutionWithTrigger, String[]): String[]
  + counter(String, String[]): Counter
  + summary(String, String[]): DistributionSummary
  + tags(Task): String[]
}
interface MetricRepositoryInterface << interface >> {
  + findByExecutionIdAndTaskRunId(String, String, String, Pageable): ArrayListTotal<MetricEntry>
  + findByExecutionIdAndTaskId(String, String, String, Pageable): ArrayListTotal<MetricEntry>
  + findByExecutionId(String, String, Pageable): ArrayListTotal<MetricEntry>
  + taskMetrics(String, String, String, String): List<String>
  + tasksWithMetrics(String, String, String): List<String>
  + purge(Execution): Integer
  + flowMetrics(String, String, String): List<String>
  + sortMapping(): Function<String, String>
  + aggregateByFlowId(String, String, String, String, String, ZonedDateTime, ZonedDateTime, String): MetricAggregations
}
annotation Metrics << annotation >> {
  + value(): Metric[]
}
class MigrationRequiredException {
  - serialVersionUID: long
}
class MiscController {
  ~ versionProvider: VersionProvider
  # environmentName: String
  ~ executionRepository: ExecutionRepositoryInterface
  ~ collectorService: CollectorService
  ~ templateRepository: Optional<TemplateRepositoryInterface>
  - initialPreviewRows: Integer
  # isAnonymousUsageEnabled: Boolean
  ~ tenantService: TenantService
  - log: Logger
  - maxPreviewRows: Integer
  ~ basicAuthService: BasicAuthService
  ~ instanceService: InstanceService
  # environmentColor: String
  + configuration(): Configuration
  + addBasicAuth(BasicAuthCredentials): HttpResponse<Void>
  + usages(): Usage
}
class MiscControllerSecuredTest {
  ~ client: ReactorHttpClient
  - basicAuthConfiguration: BasicAuthConfiguration
  ~ configuration(): void
}
class MiscControllerTest {
  ~ client: ReactorHttpClient
  ~ basicAuthService: BasicAuthService
  ~ configuration(): void
  ~ basicAuth(): void
  ~ ping(): void
}
class MiscUsageControllerTest {
  ~ usages(): void
}
class ModelValidator {
  ~ validator: Validator
  + validate(T): void
  + isValid(T): Optional<ConstraintViolationException>
}
class MultipleCondition {
  - log: Logger
  - window: Duration
  - windowAdvance: Duration
  # id: String
  - conditions: Map<String, Condition>
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getId(): String
  + getWindow(): Duration
  + getWindowAdvance(): Duration
  + getConditions(): Map<String, Condition>
  + toString(): String
  + builder(): MultipleConditionBuilder<?, ?>
  + test(ConditionContext): boolean
}
interface MultipleConditionStorageInterface << interface >> {
  + save(List<MultipleConditionWindow>): void
  + delete(MultipleConditionWindow): void
  + get(Flow, String): Optional<MultipleConditionWindow>
  + expired(String): List<MultipleConditionWindow>
  + getOrCreate(Flow, MultipleCondition): MultipleConditionWindow
}
class MultipleConditionTest {
  ~ conditionService: ConditionService
  ~ multipleConditionStorage: MultipleConditionStorageInterface
  ~ simple(): void
}
class MultipleConditionTriggerCaseTest {
  # runnerUtils: RunnerUtils
  # flowRepository: FlowRepositoryInterface
  # applicationContext: ApplicationContext
  # executionQueue: QueueInterface<Execution>
  + failed(): void
  + trigger(): void
}
class MultipleConditionWindow {
  - tenantId: String
  - start: ZonedDateTime
  - namespace: String
  - end: ZonedDateTime
  - results: Map<String, Boolean>
  - flowId: String
  - conditionId: String
  + builder(): MultipleConditionWindowBuilder
  + getTenantId(): String
  + toString(): String
  + getNamespace(): String
  + getFlowId(): String
  + getConditionId(): String
  + getStart(): ZonedDateTime
  + getEnd(): ZonedDateTime
  + getResults(): Map<String, Boolean>
  + equals(Object): boolean
  + hashCode(): int
  + uid(): String
  + uid(Flow, String): String
  + isValid(ZonedDateTime): boolean
  + with(Map<String, Boolean>): MultipleConditionWindow
}
class MultiselectInput {
  - itemType: Type
  ~ options: List<String>
  ~ expression: String
  ~ allowCustomValue: Boolean
  ~ values: List<String>
  + getOptions(): List<String>
  + getValues(): List<String>
  + getExpression(): String
  + getItemType(): Type
  + getAllowCustomValue(): Boolean
  - $default$itemType(): Type
  - $default$allowCustomValue(): Boolean
  + builder(): MultiselectInputBuilder<?, ?>
  + render(Function<String, Object>): Input<?>
  - renderExpressionValues(Function<String, Object>): List<String>
  + validate(List<String>): void
}
class MultiselectInputTest {
  ~ runContextFactory: RunContextFactory
  ~ shouldRenderInputGivenExpressionReturningStrings(): void
  ~ shouldRenderInputGivenExpressionReturningIntegers(): void
}
class MySqlJdbcDeserializationIssuesTest
class MysqlExecutionDelayStorage
class MysqlExecutionQueuedStorage
class MysqlExecutionRepository {
  # weekFromTimestamp(Field<Timestamp>): Field<Integer>
  # findCondition(String, Map<String, String>): Condition
}
class MysqlExecutionRepositoryService {
  + findCondition(AbstractJdbcRepository<Execution>, String, Map<String, String>): Condition
}
class MysqlExecutionRepositoryTest {
  # taskRunsDailyStatistics(): void
  # findTaskRun(): void
}
class MysqlExecutionServiceTest {
  ~ jdbcTestUtils: JdbcTestUtils
  # init(): void
}
class MysqlExecutorStateStorage
class MysqlFlowListenersTest {
  ~ flowListenersService: FlowListeners
  ~ jdbcTestUtils: JdbcTestUtils
  + all(): void
  # init(): void
}
class MysqlFlowRepository {
  # findSourceCodeCondition(String): Condition
  # findCondition(String, Map<String, String>): Condition
}
class MysqlFlowRepositoryService {
  + findCondition(AbstractJdbcRepository<Flow>, String, Map<String, String>): Condition
  + findSourceCodeCondition(AbstractJdbcRepository<Flow>, String): Condition
}
class MysqlFlowRepositoryTest
class MysqlFlowTopologyRepository {
  # buildMergeStatement(DSLContext, FlowTopology): DMLQuery<Record>
}
class MysqlFlowTopologyRepositoryTest
class MysqlLogRepository {
  # findCondition(String): Condition
}
class MysqlLogRepositoryTest
class MysqlMetricRepository {
  # weekFromTimestamp(Field<Timestamp>): Field<Integer>
}
class MysqlMetricRepositoryTest
class MysqlMultipleConditionStorage
class MysqlMultipleConditionStorageTest {
  ~ repository: MysqlRepository<MultipleConditionWindow>
  ~ jdbcTestUtils: JdbcTestUtils
  ~ applicationContext: ApplicationContext
  # multipleConditionStorage(): MultipleConditionStorageInterface
  # save(MultipleConditionStorageInterface, Flow, List<MultipleConditionWindow>): void
  # init(): void
}
class MysqlQueue<T> {
  - QUEUE_CONSUMERS: MysqlQueueConsumers
  # receiveFetch(DSLContext, String, String, boolean): Result<Record>
  # updateGroupOffsets(DSLContext, String, String, List<Integer>): void
  # receiveFetch(DSLContext, String, Integer, boolean): Result<Record>
}
annotation MysqlQueueEnabled << annotation >>
class MysqlQueueFactory {
  ~ applicationContext: ApplicationContext
  + workerTaskResult(): QueueInterface<WorkerTaskResult>
  + subflowExecutionResult(): QueueInterface<SubflowExecutionResult>
  + executor(): QueueInterface<Executor>
  + workerJobRunning(): QueueInterface<WorkerJobRunning>
  + execution(): QueueInterface<Execution>
  + kill(): QueueInterface<ExecutionKilled>
  + metricEntry(): QueueInterface<MetricEntry>
  + flow(): QueueInterface<Flow>
  + workerTriggerResultQueue(): WorkerTriggerResultQueueInterface
  + logEntry(): QueueInterface<LogEntry>
  + workerJob(): QueueInterface<WorkerJob>
  + trigger(): QueueInterface<Trigger>
  + workerJobQueue(): WorkerJobQueueInterface
  + workerInstance(): QueueInterface<WorkerInstance>
  + workerTriggerResult(): QueueInterface<WorkerTriggerResult>
  + template(): QueueInterface<Template>
}
class MysqlQueueTest
class MysqlRepository<T> {
  + fullTextCondition(List<String>, String): Condition
  + fetchPage(DSLContext, SelectConditionStep<R>, Pageable, RecordMapper<R, E>): ArrayListTotal<E>
  + weekFromTimestamp(Field<Timestamp>): Field<Integer>
}
annotation MysqlRepositoryEnabled << annotation >>
class MysqlRunnerRetryTest
class MysqlRunnerTest
class MysqlSchedulerScheduleTest {
  # scheduler(FlowListeners): AbstractScheduler
}
class MysqlServiceInstanceRepository
class MysqlServiceInstanceRepositoryTest
class MysqlServiceLivenessCoordinatorTest
class MysqlSettingRepository
class MysqlSettingRepositoryTest
class MysqlSubflowExecutionStorage
class MysqlSubflowExecutionStorageTest
class MysqlTemplateRepository {
  # findCondition(String): Condition
}
class MysqlTemplateRepositoryTest {
  ~ find(): void
}
class MysqlTemplateRunnerTest
class MysqlTriggerRepository {
  # fullTextCondition(String): Condition
}
class MysqlTriggerRepositoryTest
class MysqlWorkerJobQueue {
  - jdbcworkerjobQueueService: JdbcWorkerJobQueueService
  - log: Logger
  + receive(String, Class<?>, Consumer<Either<WorkerJob, DeserializationException>>): Runnable
  + close(): void
}
class MysqlWorkerJobRunningRepository
class MysqlWorkerTriggerResultQueue {
  - jdbcWorkerTriggerResultQueueService: JdbcWorkerTriggerResultQueueService
  - log: Logger
  + close(): void
  + receive(String, Class<?>, Consumer<Either<WorkerTriggerResult, DeserializationException>>): Runnable
}
class Namespace {
  # id: String
  ~ deleted: boolean
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getId(): String
  + isDeleted(): boolean
  + toString(): String
  + toBuilder(): NamespaceBuilder<?, ?>
  - $default$deleted(): boolean
  + builder(): NamespaceBuilder<?, ?>
}
interface Namespace << interface >> {
  + createDirectory(Path): URI
  + namespace(): String
  + findAllFilesMatching(Predicate<Path>): List<NamespaceFile>
  + putFile(Path, InputStream): NamespaceFile
  + all(String, boolean): List<NamespaceFile>
  + putFile(NamespaceFile, InputStream): NamespaceFile
  + all(boolean): List<NamespaceFile>
  + delete(NamespaceFile): boolean
  + putFile(Path, InputStream, Conflicts): NamespaceFile
  + getFileContent(Path): InputStream
  + putFile(NamespaceFile, InputStream, Conflicts): NamespaceFile
  + all(): List<NamespaceFile>
  + get(Path): NamespaceFile
  + findAllFilesMatching(List<String>, List<String>): List<NamespaceFile>
  + delete(Path): boolean
}
class NamespaceCommand {
  - log: Logger
  + call(): Integer
}
class NamespaceCommandTest {
  ~ runWithNoParam(): void
}
class NamespaceController {
  - tenantService: TenantService
  - flowRepository: FlowRepositoryInterface
  - flowTopologyService: FlowTopologyService
  - namespaceUtils: NamespaceUtils
  + dependencies(String, boolean): FlowTopologyGraph
  + index(String): Namespace
  + find(String, int, int, List<String>, Boolean): PagedResults<NamespaceWithDisabled>
}
interface NamespaceControllerInterface<N, D> << interface >> {
  + dependencies(String, boolean): FlowTopologyGraph
  + index(String): N
  + find(String, int, int, List<String>, Boolean): PagedResults<D>
}
class NamespaceControllerTest {
  - client: ReactorHttpClient
  - flowRepository: FlowRepositoryInterface
  - flowTopologyRepository: FlowTopologyRepositoryInterface
  # createSimpleFlowTopology(String, String): FlowTopology
  ~ reset(): void
  ~ list(): void
  ~ get(): void
  # flow(String): Flow
  ~ namespaceTopology(): void
}
entity NamespaceFile << record >> {
  - path: String
  - uri: URI
  - namespace: String
  + uri(): URI
  + isDirectory(): boolean
  + storagePath(): Path
  + path(): String
  + namespace(): String
  + isRootDirectory(): boolean
  + of(String): NamespaceFile
  + of(String, URI?): NamespaceFile
  + of(String, Path?): NamespaceFile
  + path(boolean): Path
}
class NamespaceFileController {
  - storageInterface: StorageInterface
  - tenantService: TenantService
  + FLOWS_FOLDER: String
  - flowService: FlowService
  - forbiddenPathPatterns: List<Pattern>
  - log: Logger
  + export(String): HttpResponse<byte[]>
  + createDirectory(String, String): void
  + move(String, URI, URI): void
  + list(String, String): List<FileAttributes>
  - ensureWritableNamespaceFile(URI): void
  + delete(String, String): void
  + stats(String, String): FileAttributes
  + search(String, String): List<String>
  # importFlow(String, String): void
  - putNamespaceFile(String, String, URI, BufferedInputStream): void
  + createFile(String, String, CompletedFileUpload): void
  + file(String, String): StreamedFile
  - forbiddenPathsGuard(URI): void
}
class NamespaceFileControllerTest {
  - NAMESPACE: String
  ~ client: ReactorHttpClient
  - flowRepository: FlowRepositoryInterface
  - storageInterface: StorageInterface
  ~ createFile(): void
  ~ namespaceRootStatsWithoutPreCreation(): void
  - assertNamespaceFileContent(URI, String): void
  ~ createFile_ExtractZip(): void
  - toNamespacedStorageUri(String, URI): URI
  ~ createFile_AddFlow(): void
  - assertForbiddenErrorThrown(Executable): void
  ~ createDirectory(): void
  ~ search(): void
  ~ list(): void
  ~ file(): void
  ~ move(): void
  + init(): void
  ~ stats(): void
  ~ listWithoutPreCreation(): void
  ~ forbiddenPaths(): void
  ~ delete(): void
}
class NamespaceFileTest {
  - NAMESPACE: String
  ~ shouldCreateGivenNamespaceAndValidStorageURI(): void
  ~ shouldThrowExceptionGivenInvalidNamespace(): void
  ~ shouldCreateGivenNamespaceAndValidRelativeURI(): void
  ~ shouldCreateValidNamespaceFileGivenSlashURI(): void
  ~ shouldGetStoragePath(): void
  ~ shouldThrowExceptionGivenInvalidScheme(): void
  ~ shouldThrowExceptionGivenNullNamespace(): void
  ~ shouldCreateGivenNamespaceAndNullPath(): void
  ~ shouldCreateGivenNamespaceAndRootPath(): void
  ~ shouldReturnTrueForIsRootDirectoryGivenRootDirectory(): void
  ~ shouldReturnFalseForIsRootDirectoryGivenNonRootDirectory(): void
  ~ shouldCreateGivenNamespaceAndPath(): void
  ~ shouldPreserveTrailingSlashForUri(): void
}
class NamespaceFiles {
  - exclude: List<String>
  - include: List<String>
  - enabled: Boolean
  + getEnabled(): Boolean
  + getInclude(): List<String>
  + getExclude(): List<String>
  - $default$enabled(): Boolean
  + builder(): NamespaceFilesBuilder
}
class NamespaceFilesCommand {
  - log: Logger
  + call(): Integer
}
class NamespaceFilesCommandTest {
  ~ runWithNoParam(): void
}
interface NamespaceFilesInterface << interface >> {
  + getNamespaceFiles(): NamespaceFiles
}
class NamespaceFilesUpdateCommand {
  + namespace: String
  - KESTRA_IGNORE_FILE: String
  + from: Path
  - log: Logger
  + to: String
  + delete: boolean
  + call(): Integer
}
class NamespaceFilesUpdateCommandTest {
  ~ runWithToSpecified(): void
  - assertTransferMessage(ByteArrayOutputStream, String, String): void
  - assertTransferMessage(ByteArrayOutputStream, String, String?, boolean): void
  ~ runWithoutIgnore(): void
  ~ runWithIgnore(): void
}
interface NamespaceInterface << interface >> {
  + getId(): String
  + uid(): String
}
class NamespaceService {
  - flowRepository: Optional<FlowRepositoryInterface>
  + isNamespaceExists(String, String): boolean
}
class NamespaceUtils {
  - systemFlowNamespace: String
  + NAMESPACE_FROM_FLOW_SOURCE_PATTERN: Pattern
  + SYSTEM_FLOWS_DEFAULT_NAMESPACE: String
  + getSystemFlowNamespace(): String
  + asTree(String): List<String>
}
class NamespaceWithDisabled {
  ~ disabled: boolean
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + isDisabled(): boolean
  + toString(): String
  + builder(): NamespaceWithDisabledBuilder<?, ?>
  + toBuilder(): NamespaceWithDisabledBuilder<?, ?>
}
class Network {
  - HOSTNAME: String
  + localHostname(): String
}
class NextTaskRun {
  - taskRun: TaskRun
  - task: Task
  + getTaskRun(): TaskRun
  + getTask(): Task
  + equals(Object): boolean
  + hashCode(): int
  + toString(): String
}
class NindentFilter {
  + apply(Object, Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
}
class NindentFilterTest {
  ~ variableRenderer: VariableRenderer
  ~ nindentNull(): void
  ~ nindentStringWithLF(): void
  ~ nindentStringWithSystemNewLine(): void
  ~ nindentStringWithCRLF(): void
  ~ nindentInteger(): void
  ~ nindentEmpty(): void
  ~ nindentString(): void
  ~ nindentEmptyLines(): void
  ~ nindentWithTab(): void
  ~ nindentStringWithCR(): void
}
class NoEncryptionConfiguredTest {
  - flowRepository: FlowRepositoryInterface
  - flowIO: FlowInputOutput
  + getProperties(): Map<String, String>
  ~ secretInput(): void
  ~ encryptedStringOutput(): void
}
class NoOpStartupHook {
  + start(AbstractCommand): void
}
class NotCondition {
  - conditions: List<Condition>
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getConditions(): List<Condition>
  + toString(): String
  + builder(): NotConditionBuilder<?, ?>
  + test(ConditionContext): boolean
}
class NotConditionTest {
  ~ conditionService: ConditionService
  ~ valid(List<Condition>, boolean): void
  ~ source(): Stream<Arguments>
}
class NowFunction {
  + execute(Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
}
class NullCoalescingExpression {
  + evaluate(PebbleTemplateImpl, EvaluationContextImpl): Object
  + toString(): String
}
class NullCoalescingExpressionTest {
  ~ variableRenderer: VariableRenderer
  ~ firstDefinedEval(): void
  ~ emptyObject(): void
  ~ nullOrUndefined(): void
  ~ firstDefined(): void
}
class NumberFilter {
  + apply(Object, Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
  + getArgumentNames(): List<String>
}
class NumberFilterTest {
  ~ variableRenderer: VariableRenderer
  ~ source(): Stream<Arguments>
  ~ run(String, String): void
}
class ObjectMapperFactory {
  + objectMapper(JacksonConfiguration, JsonFactory): ObjectMapper
}
class ObjectMapperFactoryTest {
  ~ objectMapper: ObjectMapper
  ~ serialize(): void
  ~ deserialize(): void
}
class OrCondition {
  - conditions: List<Condition>
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getConditions(): List<Condition>
  + toString(): String
  + builder(): OrConditionBuilder<?, ?>
  + test(ConditionContext): boolean
}
class OrConditionTest {
  ~ conditionService: ConditionService
  ~ source(): Stream<Arguments>
  ~ valid(List<Condition>, boolean): void
}
class OssAuthEvent {
  - ossAuth: OssAuth
  + getOssAuth(): OssAuth
  + builder(): OssAuthEventBuilder
}
class OssAuthListener {
  - httpClient: HttpClient
  - log: Logger
  ~ onOssAuth(OssAuthEvent): void
}
interface Output << interface >> {
  + finalState(): Optional<Type>
  + toMap(): Map<String, Object>
  + toMap(ZoneId): Map<String, Object>
}
class Output {
  ~ id: String
  ~ value: Object
  ~ description: String
  ~ type: Type
  + getId(): String
  + getDescription(): String
  + getValue(): Object
  + getType(): Type
  + builder(): OutputBuilder<?, ?>
}
interface OutputFilesInterface << interface >> {
  + getOutputFiles(): List<String>
}
class OutputValues {
  - values: HashMap<String, String>
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getValues(): HashMap<String, String>
  + toString(): String
  + builder(): OutputValuesBuilder<?, ?>
  + run(RunContext): Output
}
class OutputValuesTest {
  ~ flowRepository: FlowRepositoryInterface
  ~ output(): void
}
class OutputWriter {
  + output(): Object
}
class OverrideRetryInterceptor {
  - LOG: Logger
  - eventPublisher: ApplicationEventPublisher<RetryEvent>
  + getOrder(): int
  - resolveIncludes(AnnotationValue<Retryable>, String): List<Class<Throwable>>
  + intercept(MethodInvocationContext<Object, Object>): Object
  - retrySync(MethodInvocationContext<Object, Object>, MutableRetryState, InterceptedMethod): Object
}
class OverrideRetryInterceptorTest {
  ~ retry: TestRetry
  ~ retryEvents: RetryEvents
  ~ test(): void
}
class PageableUtils {
  + from(int, int): Pageable
  # sort(List<String>, Function<String, String>): Sort
  + from(int, int, List<String>, Function<String, String>): Pageable
  + from(int, int, List<String>): Pageable
}
class PageableUtilsTest {
  ~ testFrom(): void
}
class PagedResults<T> {
  - total: long
  - results: ArrayListTotal<T>
  + getResults(): ArrayListTotal<T>
  + getTotal(): long
  + of(ArrayListTotal<T>): PagedResults<T>
}
class Parallel {
  - tasks: List<Task>
  - concurrent: Integer
  # errors: List<Task>
  + allChildTasks(): List<Task>
  + hashCode(): int
  + equals(Object): boolean
  # canEqual(Object): boolean
  + getConcurrent(): Integer
  + getTasks(): List<Task>
  + getErrors(): List<Task>
  + toString(): String
  - $default$concurrent(): Integer
  + builder(): ParallelBuilder<?, ?>
  + childTasks(RunContext, TaskRun): List<ResolvedTask>
  + resolveNexts(RunContext, Execution, TaskRun): List<NextTaskRun>
  + tasksTree(Execution, TaskRun, List<String>): GraphCluster
}
class ParallelTest {
  ~ parallelNested(): void
  ~ parallel(): void
}
class PathMatcherPredicate {
  - SYNTAX_GLOB: String
  - syntaxAndPatterns: List<String>
  - matchers: List<PathMatcher>
  - SYNTAX_REGEX: String
  - mayAddRecursiveMatch(String): String
  - mayAddLeadingSlash(String): String
  + matches(List<String>): PathMatcherPredicate
  + syntaxAndPatterns(): List<String>
  + builder(): Builder
  + test(Path): boolean
  + isPrefixWithSyntax(String): boolean
  + matches(Path, List<String>): PathMatcherPredicate
}
class PathMatcherPredicateTest {
  ~ shouldMatchAllGivenRecursiveGlobExpressionAndNoBasePath(): void
  ~ shouldAddBasePathForExpressionWithNoPrefix(): void
  ~ shouldMatchGivenSimpleExpressionAndBasePath(): void
  ~ shouldMatchGivenIncludeAndExcludeExpressions(): void
  ~ shouldUseGlobPatternForExpressionWithNoPrefix(): void
  ~ shouldSupportGlobExpression(): void
  ~ shouldMatchAllGivenSimpleExpressionAndNoBasePath(): void
  ~ shouldAddMissingWildcardToGlobExpressions(): void
  ~ shouldSupportRegexExpression(): void
}
class PathUtil {
  + checkLeadingSlash(String): String
}
class Pause {
  - onResume: List<Input<?>>
  - delay: Duration
  - timeout: Duration
  # errors: List<Task>
  - tasks: List<Task>
  + getTimeout(): Duration
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getDelay(): Duration
  + getOnResume(): List<Input<?>>
  + getErrors(): List<Task>
  + getTasks(): List<Task>
  + builder(): PauseBuilder<?, ?>
  + toString(): String
  + resolveState(RunContext, Execution, TaskRun): Optional<Type>
  + resolveNexts(RunContext, Execution, TaskRun): List<NextTaskRun>
  - needPause(TaskRun): boolean
  + allChildTasks(): List<Task>
  + tasksTree(Execution, TaskRun, List<String>): AbstractGraph
  + generateOutputs(Map<String, Object>): Map<String, Object>
  + childTasks(RunContext, TaskRun): List<ResolvedTask>
}
class PauseTest {
  ~ suite: Suite
  ~ runEmptyTasks(): void
  ~ runOnResumeMissingInputs(): void
  ~ runOnResumeOptionalInputs(): void
  ~ timeout(): void
  ~ parallelDelay(): void
  ~ run(): void
  ~ delay(): void
  ~ runOnResume(): void
}
class PdfFileRender
class PebbleLruCache {
  ~ cache: Cache<Object, PebbleTemplate>
  - log: Logger
  + invalidateAll(): void
  + computeIfAbsent(Object, Function<Object, PebbleTemplate>): PebbleTemplate
}
class PebbleVariableRendererTest {
  ~ variableRenderer: VariableRenderer
  ~ get(): void
  ~ macro(): void
  ~ out(): void
  ~ recursive(): void
  ~ recursiveRenderingAmountLimit(): void
  ~ raw(): void
  ~ exception(): void
  ~ eval(): void
  ~ firstDefined(): void
  ~ map(): void
  ~ firstDefinedEval(): void
  ~ numberFormat(): void
  ~ mapWithNestedNumberList(): void
  ~ autoJson(): void
}
interface Plugin << interface >> {
  + getType(): String
  + getId(Class<?>): Optional<String>
  + getAliases(Class<?>): Set<String>
  + isInternal(Class<?>): boolean
}
annotation Plugin << annotation >> {
  + aliases(): String[]
  + beta(): boolean
  + internal(): boolean
  + examples(): Example[]
  + metrics(): Metric[]
}
class Plugin {
  - storages: List<String>
  - categories: List<PluginCategory>
  - guides: List<String>
  - secrets: List<String>
  - conditions: List<String>
  - triggers: List<String>
  - name: String
  - longDescription: String
  - version: String
  - aliases: List<String>
  - taskRunners: List<String>
  - license: String
  - manifest: Map<String, String>
  - controllers: List<String>
  - subGroup: String
  - tasks: List<String>
  - title: String
  - group: String
  - description: String
  + getTitle(): String
  + getName(): String
  + getCategories(): List<PluginCategory>
  + setConditions(List<String>): void
  + setTasks(List<String>): void
  + equals(Object): boolean
  + setGroup(String): void
  + setManifest(Map<String, String>): void
  + setName(String): void
  + getTriggers(): List<String>
  + getAliases(): List<String>
  + getDescription(): String
  + getTasks(): List<String>
  + getLicense(): String
  + setTitle(String): void
  # canEqual(Object): boolean
  + setLongDescription(String): void
  + getSubGroup(): String
  + setDescription(String): void
  + setGuides(List<String>): void
  + getLongDescription(): String
  + getGroup(): String
  + getStorages(): List<String>
  + getVersion(): String
  + getConditions(): List<String>
  + getControllers(): List<String>
  + getGuides(): List<String>
  + toString(): String
  + setSecrets(List<String>): void
  + hashCode(): int
  + getSecrets(): List<String>
  + setSubGroup(String): void
  + setTaskRunners(List<String>): void
  + getManifest(): Map<String, String>
  + setLicense(String): void
  + setControllers(List<String>): void
  + setTriggers(List<String>): void
  + setAliases(List<String>): void
  + setCategories(List<PluginCategory>): void
  + setStorages(List<String>): void
  + getTaskRunners(): List<String>
  + setVersion(String): void
  - filterAndGetClassName(List<Class<?>>): List<String>
  + of(RegisteredPlugin, String): Plugin
}
class PluginClassLoader {
  - parent: ClassLoader
  - pluginLocation: URL
  - systemClassLoader: ClassLoader
  - log: Logger
  - DEFAULT_PACKAGES_TO_IGNORE: Pattern
  + of(URL, URL[], ClassLoader): PluginClassLoader
  + toString(): String
  # loadClass(String, boolean): Class<?>
  - shouldLoadFromUrls(String): boolean
  + getResource(String): URL?
  - mayLoadFromSystemClassLoader(String): Class<?>
  + location(): String
  - getResourcesFromSystem(String): Enumeration<URL>
  + getResources(String): Enumeration<URL>
  + loadClass(String): Class<?>
}
class PluginCommand {
  - log: Logger
  + call(): Integer
}
entity PluginConfiguration << record >> {
  - values: Map<String, Object>
  ~ COMPARATOR: Comparator<PluginConfiguration>
  - order: Integer
  - type: String
  + order(): Integer
  + values(): Map<String, Object>
  + type(): String
}
class PluginConfigurationTest {
  - configurations: List<PluginConfiguration>
  ~ testInjectEachProperty(): void
}
class PluginConfigurations {
  - configurations: List<PluginConfiguration>
  + getConfigurationByPluginTypeOrAliases(String, Class<Plugin>): Map<String, Object>
  + getConfigurationByPluginType(String): Map<String, Object>
}
class PluginConfigurationsTest {
  - PLUGIN_TEST: String
  ~ shouldGetOrderedMergeConfigurationProperties(): void
  ~ shouldGetConfigurationForAlias(): void
}
class PluginController {
  - CACHE_DIRECTIVE: String
  - jsonSchemaGenerator: JsonSchemaGenerator
  - pluginRegistry: PluginRegistry
  # pluginDocumentation(List<RegisteredPlugin>, String, Boolean): ClassPluginDocumentation<?>
  # loadPluginsIcon(): Map<String, PluginIcon>
  + icons(): MutableHttpResponse<Map<String, PluginIcon>>
  + subgroups(): List<Plugin>
  + schemas(SchemaType, Boolean): HttpResponse<Map<String, Object>>
  + inputs(): List<InputType>
  + inputSchemas(Type): MutableHttpResponse<DocumentationWithSchema>
  + pluginGroupIcons(): MutableHttpResponse<Map<String, PluginIcon>>
  # inputDocumentation(Type): ClassInputDocumentation
  + pluginDocumentation(String, Boolean): HttpResponse<DocumentationWithSchema>
  - alertReplacement(String): String
  # schemasCache(SchemaType, boolean): Map<String, Object>
  + search(): List<Plugin>
}
class PluginControllerTest {
  ~ returnTask(): void
  ~ plugins(): void
  ~ docs(): void
  ~ template(): void
  ~ flow(): void
  ~ input(): void
  + beforeAll(): void
  ~ taskWithBase(): void
  ~ inputs(): void
  ~ icons(): void
  ~ docWithAlert(): void
  ~ task(): void
}
class PluginDefault {
  - values: Map<String, Object>
  - type: String
  - forced: boolean
  + getType(): String
  + isForced(): boolean
  + getValues(): Map<String, Object>
  - $default$forced(): boolean
  + builder(): PluginDefaultBuilder
  + toBuilder(): PluginDefaultBuilder
}
class PluginDefaultConverter {
  + convert(Map, Class<PluginDefault>, ConversionContext): Optional<PluginDefault>
}
class PluginDefaultService {
  - pluginRegistry: PluginRegistry
  - NON_DEFAULT_OBJECT_MAPPER: ObjectMapper
  # yamlFlowParser: YamlFlowParser
  # taskGlobalDefault: TaskGlobalDefaultConfiguration
  - log: Logger
  # pluginGlobalDefault: PluginGlobalDefaultConfiguration
  # logQueue: QueueInterface<LogEntry>
  - warnOnce: AtomicBoolean
  + injectDefaults(Flow, Execution): Flow
  + injectDefaults(Flow): Flow
  + injectDefaults(Flow, Logger): Flow
  - pluginDefaultsToMap(List<PluginDefault>): Map<String, List<PluginDefault>>
  - defaults(Map<?, ?>, Map<String, List<PluginDefault>>): Map<?, ?>
  ~ recursiveDefaults(Object, Map<String, List<PluginDefault>>): Object
  - addAliases(List<PluginDefault>): void
  # mergeAllDefaults(Flow): List<PluginDefault>
}
class PluginDefaultServiceTest {
  - pluginDefaultService: PluginDefaultService
  - TEST_FLOW_AS_MAP: Map<String, Object>
  ~ shouldInjectGivenDefaultsIncludingType(): void
  + forced(): void
  + prefix(): void
  - flowDefaultsOverrideGlobalDefaults(): Stream<Arguments>
  ~ shouldInjectGivenSimpleDefaults(): void
  + injectFlowAndGlobals(): void
  ~ alias(): void
  ~ flowDefaultsOverrideGlobalDefaults(boolean, boolean, String, String, String): void
}
annotation PluginDefaultValidation << annotation >> {
  + payload(): Class<Payload>[]
  + groups(): Class<?>[]
  + message(): String
}
class PluginDefaultValidationTest {
  - modelValidator: ModelValidator
  ~ nullValue(): void
}
class PluginDefaultValidator {
  + isValid(PluginDefault, AnnotationValue<PluginDefaultValidation>, ConstraintValidatorContext): boolean
  - addConstraintViolation(ConstraintValidatorContext, List<String>): void
}
class PluginDefaultsCaseTest {
  - runnerUtils: RunnerUtils
  + taskDefaults(): void
}
class PluginDeserializer<T> {
  - TYPE: String
  - log: Logger
  - pluginRegistry: PluginRegistry
  - fromObjectNode(JsonParser, JsonNode, DeserializationContext): T?
  - throwInvalidTypeException(DeserializationContext, String): void
  + deserialize(JsonParser, DeserializationContext): T?
  - checkState(): void
  ~ extractPluginRawIdentifier(JsonNode): String?
}
class PluginDeserializerTest {
  - registry: PluginRegistry
  ~ shouldSucceededDeserializePluginGivenValidType(): void
  ~ shouldFailedDeserializePluginGivenInvalidType(): void
  ~ shouldReturnNullPluginIdentifierGivenEmptyType(): void
  ~ shouldReturnNullPluginIdentifierGivenNullType(): void
}
class PluginDocCommand {
  - core: boolean
  - applicationContext: ApplicationContext
  - output: Path
  - icons: boolean
  + call(): Integer
}
class PluginDocCommandTest {
  + PLUGIN_TEMPLATE_TEST: String
  ~ run(): void
}
class PluginDownloader {
  - repositoryConfigs: List<RepositoryConfig>
  - system: RepositorySystem
  - session: RepositorySystemSession
  - log: Logger
  + resolve(List<String>): List<URL>
  - remoteRepositories(): List<RemoteRepository>
  - resolveUrls(List<ArtifactResult>): List<URL>
  - resolveArtifacts(List<RemoteRepository>, List<String>): List<ArtifactResult>
  - repositorySystemSession(RepositorySystem, String): RepositorySystemSession
  + addRepository(RepositoryConfig): void
  - repositorySystem(): RepositorySystem
}
class PluginGlobalDefaultConfiguration {
  ~ defaults: List<PluginDefault>
  + getDefaults(): List<PluginDefault>
}
class PluginIcon {
  ~ name: String
  ~ flowable: Boolean
  ~ icon: String
  + equals(Object): boolean
  + getName(): String
  + getIcon(): String
  + getFlowable(): Boolean
  + setName(String): void
  + setIcon(String): void
  + setFlowable(Boolean): void
  # canEqual(Object): boolean
  + toString(): String
  + hashCode(): int
}
interface PluginIdentifier << interface >>
class PluginInstallCommand {
  - pluginDownloader: PluginDownloader
  ~ dependencies: List<String>
  - repositories: URI[]
  ~ spec: CommandSpec
  # loadExternalPlugins(): boolean
  + call(): Integer
}
class PluginInstallCommandTest {
  ~ rangeVersion(): void
  ~ latestVersion(): void
  ~ fixedVersion(): void
}
class PluginListCommand {
  ~ spec: CommandSpec
  - core: boolean
  + call(): Integer
}
class PluginListCommandTest {
  - PLUGIN_TEMPLATE_TEST: String
  ~ run(): void
}
class PluginModule {
  - serialVersionUID: long
  + NAME: String
}
class PluginProcessor {
  - plugins: Set<String>
  - elementUtils: Elements
  - exceptionStacks: List<String>
  + PLUGIN_RESOURCE_FILE: String
  - getBinaryNameImpl(TypeElement, String): String
  - hasNoArgConstructor(TypeElement): boolean
  - processImpl(Set<TypeElement>, RoundEnvironment): void
  + getSupportedAnnotationTypes(): Set<String>
  - asTypeElement(Element): TypeElement
  - hasAnnotation(TypeElement, Class<Annotation>): boolean
  - error(String, Element, AnnotationMirror): void
  + init(ProcessingEnvironment): void
  + getSupportedSourceVersion(): SourceVersion
  - isNotAbstract(TypeElement): boolean
  - processAnnotations(Set<TypeElement>, RoundEnvironment): void
  - getBinaryName(TypeElement): String
  - fatalError(String): void
  + process(Set<TypeElement>, RoundEnvironment): boolean
  - generatePluginConfigFiles(): void
  - log(String): void
  - warning(String, Element, AnnotationMirror): void
}
annotation PluginProperty << annotation >> {
  + dynamic(): boolean
  + additionalProperties(): Class<?>
  + beta(): boolean
}
interface PluginRegistry << interface >> {
  + externalPlugins(): List<RegisteredPlugin>
  + plugins(Predicate<RegisteredPlugin>): List<RegisteredPlugin>
  + findClassByIdentifier(PluginIdentifier): Class<Plugin>
  + findClassByIdentifier(String): Class<Plugin>
  + registerIfAbsent(Path): void
  + register(Path): void
  + plugins(): List<RegisteredPlugin>
  + clear(): void
}
class PluginResolver {
  - pluginPath: Path
  - log: Logger
  - isClassFile(Path): boolean
  + resolves(): List<ExternalPlugin>
  - resolveUrlsForPluginPath(Path): List<URL>
  - isArchiveFile(Path): boolean
}
class PluginScanner {
  - log: Logger
  ~ parent: ClassLoader
  + scan(): RegisteredPlugin
  - scanClassLoader(ClassLoader, ExternalPlugin, Manifest): RegisteredPlugin
  + scan(Path): List<RegisteredPlugin>
  + getManifest(ClassLoader): Manifest?
}
class PluginScannerTest {
  ~ scanPlugins(): void
  ~ scanCore(): void
}
annotation PluginSubGroup << annotation >> {
  + title(): String
  + categories(): PluginCategory[]
  + description(): String
}
class PluginTest {
  ~ shouldReturnPluginId(): void
  ~ shouldReturnTrueForInternal(): void
}
class PluginUsage {
  - manifest: Map<String, String>
  + getManifest(): Map<String, String>
  + builder(): PluginUsageBuilder<?, ?>
  + of(PluginRegistry): List<PluginUsage>
}
class PluginUtilsService {
  - MAPPER: ObjectMapper
  - MAP_TYPE_REFERENCE: TypeReference<Map<String, String>>
  - PATTERN: Pattern
  + executionFromTaskParameters(RunContext, String, String, String): ExecutionInfo
  + parseOut(String, Logger, RunContext, boolean): Map<String, Object>
  - validFilename(String): void
  + createInputFiles(RunContext, Path, Map<String, String>, Map<String, Object>): void
  + createOutputFiles(Path, List<String>, Map<String, Object>): Map<String, String>
  + transformInputFiles(RunContext, Object): Map<String, String>
  + createOutputFiles(Path, List<String>, Map<String, Object>, Boolean): Map<String, String>
  + transformInputFiles(RunContext, Map<String, Object>, Object): Map<String, String>
}
class PluginUtilsServiceTest {
  - runContextFactory: RunContextFactory
  ~ outputFiles(): void
  ~ executionFromTaskParameters(): void
}
class PollingTrigger {
  - duration: Long
  - $default$duration(): Long
  + builder(): PollingTriggerBuilder<?, ?>
  + getInterval(): Duration
  + evaluate(ConditionContext, TriggerContext): Optional<Execution>
}
interface PollingTriggerInterface << interface >> {
  + nextEvaluationDate(): ZonedDateTime
  + getInterval(): Duration
  + evaluate(ConditionContext, TriggerContext): Optional<Execution>
  + nextEvaluationDate(ConditionContext, Optional<TriggerContext>): ZonedDateTime
}
class PostgresExecutionDelayStorage
class PostgresExecutionQueuedStorage
class PostgresExecutionRepository {
  # statesFilter(List<Type>): Condition
  # findCondition(String, Map<String, String>): Condition
}
class PostgresExecutionRepositoryService {
  + findCondition(AbstractJdbcRepository<Execution>, String, Map<String, String>): Condition
}
class PostgresExecutionRepositoryTest {
  # findTaskRun(): void
  # taskRunsDailyStatistics(): void
}
class PostgresExecutionServiceTest {
  ~ jdbcTestUtils: JdbcTestUtils
  # init(): void
}
class PostgresExecutorStateStorage
class PostgresFlowListenersTest {
  ~ jdbcTestUtils: JdbcTestUtils
  ~ flowListenersService: FlowListeners
  # init(): void
  + all(): void
}
class PostgresFlowRepository {
  # findCondition(String, Map<String, String>): Condition
  # findSourceCodeCondition(String): Condition
}
class PostgresFlowRepositoryService {
  + findCondition(AbstractJdbcRepository<Flow>, String, Map<String, String>): Condition
  + findSourceCodeCondition(AbstractJdbcRepository<Flow>, String): Condition
}
class PostgresFlowRepositoryTest {
  + invalidFlow(): void
}
class PostgresFlowTopologyRepository {
  # buildMergeStatement(DSLContext, FlowTopology): DMLQuery<Record>
}
class PostgresFlowTopologyRepositoryTest
class PostgresJdbcDeserializationIssuesTest {
  # fields(QueueMessage): Map<Field<Object>, Object>
}
class PostgresLogRepository {
  # findCondition(String): Condition
  # levelsCondition(List<Level>): Condition
}
class PostgresLogRepositoryTest
class PostgresMetricRepository
class PostgresMetricRepositoryTest
class PostgresMultipleConditionStorage
class PostgresMultipleConditionStorageTest {
  ~ applicationContext: ApplicationContext
  ~ repository: PostgresRepository<MultipleConditionWindow>
  ~ jdbcTestUtils: JdbcTestUtils
  # save(MultipleConditionStorageInterface, Flow, List<MultipleConditionWindow>): void
  # multipleConditionStorage(): MultipleConditionStorageInterface
  # init(): void
}
class PostgresQueue<T> {
  - disableSeqScan: boolean
  # produceFields(String, String, T): Map<Field<Object>, Object>
  # map(Result<Record>): List<Either<T, DeserializationException>>
  # receiveFetch(DSLContext, String, Integer, boolean): Result<Record>
  # updateGroupOffsets(DSLContext, String, String, List<Integer>): void
  # receiveFetch(DSLContext, String, String, boolean): Result<Record>
}
annotation PostgresQueueEnabled << annotation >>
class PostgresQueueFactory {
  ~ applicationContext: ApplicationContext
  + execution(): QueueInterface<Execution>
  + template(): QueueInterface<Template>
  + trigger(): QueueInterface<Trigger>
  + kill(): QueueInterface<ExecutionKilled>
  + executor(): QueueInterface<Executor>
  + flow(): QueueInterface<Flow>
  + workerJob(): QueueInterface<WorkerJob>
  + workerTriggerResultQueue(): WorkerTriggerResultQueueInterface
  + metricEntry(): QueueInterface<MetricEntry>
  + workerTriggerResult(): QueueInterface<WorkerTriggerResult>
  + workerJobRunning(): QueueInterface<WorkerJobRunning>
  + logEntry(): QueueInterface<LogEntry>
  + workerTaskResult(): QueueInterface<WorkerTaskResult>
  + workerJobQueue(): WorkerJobQueueInterface
  + workerInstance(): QueueInterface<WorkerInstance>
  + subflowExecutionResult(): QueueInterface<SubflowExecutionResult>
}
class PostgresQueueTest
class PostgresRepository<T> {
  + fetchPage(DSLContext, SelectConditionStep<R>, Pageable, RecordMapper<R, E>): ArrayListTotal<E>
  + persistFields(T): Map<Field<Object>, Object>
  + map(R): T
  + persist(T, DSLContext, Map<Field<Object>, Object>?): void
  + fullTextCondition(List<String>, String): Condition
}
annotation PostgresRepositoryEnabled << annotation >>
class PostgresRunnerRetryTest
class PostgresRunnerTest
class PostgresSchedulerScheduleTest {
  # scheduler(FlowListeners): AbstractScheduler
}
class PostgresServiceInstanceRepository
class PostgresServiceInstanceRepositoryTest
class PostgresServiceLivenessCoordinatorTest
class PostgresSettingRepository
class PostgresSettingRepositoryTest
class PostgresSubflowExecutionStorage
class PostgresSubflowExecutionStorageTest {
  # persistFields(): Map<Field<Object>, Object>
}
class PostgresTemplateRepository {
  # findCondition(String): Condition
}
class PostgresTemplateRepositoryTest
class PostgresTemplateRunnerTest
class PostgresTriggerRepository
class PostgresTriggerRepositoryTest
class PostgresWorkerJobQueue {
  - log: Logger
  - jdbcWorkerJobQueueService: JdbcWorkerJobQueueService
  + receive(String, Class<?>, Consumer<Either<WorkerJob, DeserializationException>>): Runnable
  + close(): void
}
class PostgresWorkerJobRunningRepository
class PostgresWorkerTriggerResultQueue {
  - jdbcWorkerTriggerResultQueueService: JdbcWorkerTriggerResultQueueService
  - log: Logger
  + close(): void
  + receive(String, Class<?>, Consumer<Either<WorkerTriggerResult, DeserializationException>>): Runnable
}
class PrintContextFunction {
  + execute(Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
  + getArgumentNames(): List<String>
}
class PrintContextFunctionTest {
  ~ variableRenderer: VariableRenderer
  ~ fromString(): void
}
class Process {
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + toString(): String
  + builder(): ProcessBuilder<?, ?>
  + instance(): Process
  # runnerAdditionalVars(RunContext, TaskCommands): Map<String, Object>
  + run(RunContext, TaskCommands, List<String>): RunnerResult
  - killDescendantsOf(ProcessHandle, Logger): void
}
class ProcessTest {
  # taskRunner(): TaskRunner
}
class Property<T> {
  - expression: String
  - MAPPER: ObjectMapper
  - value: T
  + builder(): PropertyBuilder<T>
  ~ getExpression(): String
  + asList(RunContext, Class<I>, Map<String, Object>): T
  + asMap(RunContext, Class<K>, Class<V>): T
  + as(RunContext, Class<T>, Map<String, Object>): T
  + asList(RunContext, Class<I>): T
  + of(V): Property<V>
  + toString(): String
  + asMap(RunContext, Class<K>, Class<V>, Map<String, Object>): T
  + as(RunContext, Class<T>): T
}
class PropertyTest {
  - runContextFactory: RunContextFactory
  - storage: StorageInterface
  ~ withDefaultsAndMessagesFromList(): void
  ~ withMessagesFromURI(): void
  ~ test(): void
  ~ failingToRender(): void
}
class PublicHolidayCondition {
  - country: String
  - date: String
  - subDivision: String
  # canEqual(Object): boolean
  + equals(Object): boolean
  + hashCode(): int
  + getDate(): String
  + getCountry(): String
  + getSubDivision(): String
  + toString(): String
  - $default$date(): String
  + builder(): PublicHolidayConditionBuilder<?, ?>
  + test(ConditionContext): boolean
}
class PublicHolidayConditionTest {
  ~ conditionService: ConditionService
  ~ valid(): void
  ~ invalid(): void
}
enum PullPolicy << enumeration >> {
  + ALWAYS:
  + NEVER:
  + IF_NOT_PRESENT:
  + values(): PullPolicy[]
  + valueOf(String): PullPolicy
}
class PurgeCurrentExecutionFiles {
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + toString(): String
  + builder(): PurgeCurrentExecutionFilesBuilder<?, ?>
  + run(RunContext): Output
}
class PurgeCurrentExecutionFilesTest {
  - runContextFactory: RunContextFactory
  ~ run(): void
}
class PurgeExecutions {
  - purgeExecution: boolean
  - purgeLog: boolean
  - namespace: String
  - purgeStorage: boolean
  - flowId: String
  - endDate: String
  - states: List<Type>
  - startDate: String
  - purgeMetric: boolean
  + hashCode(): int
  # canEqual(Object): boolean
  + isPurgeLog(): boolean
  - $default$purgeLog(): boolean
  + equals(Object): boolean
  + getNamespace(): String
  + isPurgeStorage(): boolean
  - $default$purgeStorage(): boolean
  + getFlowId(): String
  + getStartDate(): String
  + getEndDate(): String
  + toString(): String
  + getStates(): List<Type>
  - $default$purgeMetric(): boolean
  + isPurgeMetric(): boolean
  - $default$purgeExecution(): boolean
  + builder(): PurgeExecutionsBuilder<?, ?>
  + isPurgeExecution(): boolean
  + run(RunContext): Output
}
class PurgeExecutionsTest {
  - runContextFactory: RunContextFactory
  - executionRepository: ExecutionRepositoryInterface
  ~ deleted(): void
  ~ run(): void
}
class PurgeLogs {
  - namespace: String
  - flowId: String
  - logLevels: List<Level>
  - endDate: String
  - startDate: String
  # canEqual(Object): boolean
  + run(RunContext): Output
  + equals(Object): boolean
  + hashCode(): int
  + getNamespace(): String
  + builder(): PurgeLogsBuilder<?, ?>
  + getFlowId(): String
  + getLogLevels(): List<Level>
  + getStartDate(): String
  + getEndDate(): String
  + toString(): String
}
class PurgeLogsTest {
  - runContextFactory: RunContextFactory
  - logRepository: LogRepositoryInterface
  ~ run(): void
}
class QueueException {
  - serialVersionUID: long
}
interface QueueFactoryInterface << interface >> {
  + WORKERJOBRUNNING_NAMED: String
  + FLOW_NAMED: String
  + SUBFLOWEXECUTIONRESULT_NAMED: String
  + WORKERJOB_NAMED: String
  + EXECUTION_NAMED: String
  + METRIC_QUEUE: String
  + KILL_NAMED: String
  + WORKERTASKLOG_NAMED: String
  + WORKERTRIGGERRESULT_NAMED: String
  + TEMPLATE_NAMED: String
  + TRIGGER_NAMED: String
  + WORKERINSTANCE_NAMED: String
  + EXECUTOR_NAMED: String
  + WORKERTASKRESULT_NAMED: String
  + workerJobRunning(): QueueInterface<WorkerJobRunning>
  + workerJobQueue(): WorkerJobQueueInterface
  + workerTaskResult(): QueueInterface<WorkerTaskResult>
  + flow(): QueueInterface<Flow>
  + workerTriggerResult(): QueueInterface<WorkerTriggerResult>
  + workerTriggerResultQueue(): WorkerTriggerResultQueueInterface
  + workerJob(): QueueInterface<WorkerJob>
  + trigger(): QueueInterface<Trigger>
  + executor(): QueueInterface<Executor>
  + logEntry(): QueueInterface<LogEntry>
  + workerInstance(): QueueInterface<WorkerInstance>
  + template(): QueueInterface<Template>
  + metricEntry(): QueueInterface<MetricEntry>
  + kill(): QueueInterface<ExecutionKilled>
  + subflowExecutionResult(): QueueInterface<SubflowExecutionResult>
  + execution(): QueueInterface<Execution>
}
interface QueueInterface<T> << interface >> {
  + emit(T): void
  + emit(String, T): void
  + receive(Consumer<Either<T, DeserializationException>>): Runnable
  + emitAsync(T): void
  + receive(String, Class<?>, Consumer<Either<T, DeserializationException>>): Runnable
  + delete(T): void
  + receive(String, Consumer<Either<T, DeserializationException>>, boolean): Runnable
  + receive(String, Class<?>, Consumer<Either<T, DeserializationException>>, boolean): Runnable
  + emitAsync(String, T): void
  + receive(Class<?>, Consumer<Either<T, DeserializationException>>): Runnable
  + delete(String, T): void
  + receive(String, Consumer<Either<T, DeserializationException>>): Runnable
}
class QueueService {
  + key(Object): String
}
class Random {
  - maxInterval: Duration
  - minInterval: Duration
  # type: String
  + getType(): String
  + getMinInterval(): Duration
  + getMaxInterval(): Duration
  - $default$type(): String
  + builder(): RandomBuilder<?, ?>
  + toPolicy(): RetryPolicyBuilder<T>
  + nextRetryDate(Integer, Instant): Instant
}
class Read {
  - path: String
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getPath(): String
  + toString(): String
  + builder(): ReadBuilder<?, ?>
  + run(RunContext): Output
}
class ReadFileFunction {
  - ERROR_MESSAGE: String
  - KESTRA_SCHEME: String
  - storageInterface: StorageInterface
  - serverType: String
  + getArgumentNames(): List<String>
  + execute(Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
  - validateFileUri(String, String, String, URI): boolean
  - calledOnWorker(): boolean
  - readFromNamespaceFile(EvaluationContext, String): String
  - readFromInternalStorageUri(EvaluationContext, URI): String
}
class ReadFileFunctionTest {
  ~ variableRenderer: VariableRenderer
  ~ storageInterface: StorageInterface
  ~ readNamespaceFile(): void
  ~ readInternalStorageURI(): void
  ~ readUnknownNamespaceFile(): void
  ~ readFailOnNonWorkerNodes(): void
  ~ readUnauthorizedInternalStorageFile(): void
  ~ readInternalStorageFile(): void
}
interface RealtimeTriggerInterface << interface >> {
  + evaluate(ConditionContext, TriggerContext): Publisher<Execution>
}
enum RecoverMissedSchedules << enumeration >> {
  + ALL:
  + LAST:
  + NONE:
  + valueOf(String): RecoverMissedSchedules
  + values(): RecoverMissedSchedules[]
}
class RecursivePebbleVariableRendererTest {
  ~ variableRenderer: VariableRenderer
  ~ renderFunctionNotInjectedIfRecursiveSettingsTrue(): void
  ~ renderFunctionKeepRaw(): void
  ~ recursive(): void
}
class RedirectController {
  # basePath: String
  - log: Logger
  + slash(): HttpResponse<?>
}
annotation Regex << annotation >> {
  + payload(): Class<Payload>[]
  + message(): String
  + groups(): Class<?>[]
}
class RegexTest {
  - modelValidator: ModelValidator
  ~ inputValidation(): void
}
class RegexValidator {
  + isValid(String, AnnotationValue<Regex>, ConstraintValidatorContext): boolean
}
class RegisteredPlugin {
  - externalPlugin: ExternalPlugin
  - conditions: List<Class<Condition>>
  - storages: List<Class<StorageInterface>>
  - manifest: Manifest
  - guides: List<String>
  - taskRunners: List<Class<TaskRunner>>
  - tasks: List<Class<Task>>
  - secrets: List<Class<SecretPluginInterface>>
  - aliases: Map<String, Entry<String, Class<?>>>
  - classLoader: ClassLoader
  - triggers: List<Class<AbstractTrigger>>
  + hasClass(String): boolean
  + getTasks(): List<Class<Task>>
  + license(): String
  + equals(Object): boolean
  # canEqual(Object): boolean
  + builder(): RegisteredPluginBuilder
  + getTaskRunners(): List<Class<TaskRunner>>
  + hashCode(): int
  + getStorages(): List<Class<StorageInterface>>
  + getAliases(): Map<String, Entry<String, Class<?>>>
  + getExternalPlugin(): ExternalPlugin
  + getTriggers(): List<Class<AbstractTrigger>>
  + getConditions(): List<Class<Condition>>
  + getGuides(): List<String>
  + getManifest(): Manifest
  + getClassLoader(): ClassLoader
  + getSecrets(): List<Class<SecretPluginInterface>>
  + guides(): Map<String, String>
  + path(): String
  + toString(): String
  + icon(String): String
  + baseClass(String): Class
  + icon(Class<?>): String
  + description(): String
  + allClass(): List<Class>
  + group(): String
  + findClass(String): Optional<Class>
  + version(): String
  + subGroupNames(): Set<String>
  + isValid(): boolean
  + title(): String
  + allClassGrouped(): Map<String, List<Class>>
  + longDescription(): String
  + name(): String
}
class ReindexCommand {
  - log: Logger
  - applicationContext: ApplicationContext
  - type: String
  + call(): Integer
}
class ReindexCommandTest {
  ~ reindexFlow(): void
}
class Relation {
  - relationType: RelationType
  - value: String
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getRelationType(): RelationType
  + getValue(): String
  + toString(): String
}
enum RelationType << enumeration >> {
  + SEQUENTIAL:
  + PARALLEL:
  + ERROR:
  + CHOICE:
  + DYNAMIC:
  + values(): RelationType[]
  + valueOf(String): RelationType
}
interface RemoteRunnerInterface << interface >>
class RenderFunction {
  - applicationContext: ApplicationContext
  + getArgumentNames(): List<String>
  + execute(Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
}
class RenderFunctionTest {
  ~ variableRenderer: VariableRenderer
  ~ shouldRenderForDuration(): void
  ~ shouldRenderForLong(): void
  ~ shouldRenderForBoolean(): void
  ~ shouldRenderForInteger(): void
  ~ shouldRenderForDateTime(): void
  ~ shouldRenderForString(): void
  ~ shouldRenderForNull(): void
}
class RenderOnceFunction {
  + getArgumentNames(): List<String>
  + execute(Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
}
class RenderOncerFunctionTest {
  ~ variableRenderer: VariableRenderer
  ~ noRenderNeeded(): void
  ~ twoLayerRender(): void
  ~ oneLayerRender(): void
}
interface RenderableInput << interface >> {
  + mayRenderInput(Input<?>, Function<String, Object>): Input<?>
  + render(Function<String, Object>): Input<?>
}
class ReplaceFilter {
  - ARGUMENT_PAIRS: String
  - ARGS: List<String>
  - ARGUMENT_REGEXP: String
  + FILTER_NAME: String
  - processMap(Map<String, Object>, Map<?, ?>, boolean): Object
  - processString(String, Map<?, ?>, boolean): String
  + getArgumentNames(): List<String>
  - processList(List<Object>, Map<?, ?>, boolean): Object
  + apply(Object, Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
}
class ReplaceFilterTest {
  ~ variableRenderer: VariableRenderer
  ~ regexp(): void
  ~ string(): void
}
class RepositoryConfig {
  ~ url: String
  ~ basicAuth: BasicAuth
  ~ id: String
  + getId(): String
  + getUrl(): String
  + getBasicAuth(): BasicAuth
  + builder(): RepositoryConfigBuilder
}
class Request {
  - encryptBody: boolean
  - allowFailed: boolean
  # canEqual(Object): boolean
  + equals(Object): boolean
  + hashCode(): int
  + isAllowFailed(): boolean
  + isEncryptBody(): boolean
  + toString(): String
  - $default$allowFailed(): boolean
  - $default$encryptBody(): boolean
  + builder(): RequestBuilder<?, ?>
  + run(RunContext): Output
  + output(RunContext, HttpRequest<String>, HttpResponse<String>): Output
}
class RequestTest {
  - runContextFactory: RunContextFactory
  - storageInterface: StorageInterface
  ~ head(): void
  ~ run(): void
  ~ multipartCustomFilename(): void
  ~ form(): void
  ~ selfSigned(): void
  ~ failed(): void
  ~ multipart(): void
  ~ encrypted(): void
}
class RequestUtils {
  + toMap(List<String>): Map<String, String>
}
class RequestUtilsTest {
  ~ toMap(): void
}
class ResolvedTask {
  - parentId: String
  - task: Task
  - value: String
  + of(Task): ResolvedTask
  + of(List<Task>): List<ResolvedTask>
  + builder(): ResolvedTaskBuilder
  + getTask(): Task
  + getValue(): String
  + getParentId(): String
  + equals(Object): boolean
  + hashCode(): int
  + toString(): String
  + toNextTaskRunIncrementIteration(Execution, Integer): NextTaskRun
  + toNextTaskRun(Execution): NextTaskRun
}
class ResourceExpiredException {
  - serialVersionUID: long
}
class RestartCaseTest {
  - runnerUtils: RunnerUtils
  - executionService: ExecutionService
  - flowRepository: FlowRepositoryInterface
  - executionQueue: QueueInterface<Execution>
  + restartFailedThenFailureWithGlobalErrors(): void
  + restartMultiple(): void
  + restartFailedThenSuccess(): void
  + restartFailedThenFailureWithLocalErrors(): void
  + replay(): void
}
class RestartTest {
  - restartCaseTest: RestartCaseTest
  ~ restartFailedThenSuccess(): void
  ~ restartFailedThenFailureWithLocalErrors(): void
  ~ restartFailedThenFailureWithGlobalErrors(): void
  ~ replay(): void
}
class Result {
  - uuid: String
  - status: int
  + getUuid(): String
  + getStatus(): int
  + builder(): ResultBuilder<?, ?>
}
class Resume {
  - namespace: String
  - executionId: String
  - inputs: Map<String, Object>
  - flowId: String
  + getNamespace(): String
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getFlowId(): String
  + getExecutionId(): String
  + getInputs(): Map<String, Object>
  + toString(): String
  + builder(): ResumeBuilder<?, ?>
  + run(RunContext): VoidOutput
}
class ResumeTest {
  ~ resume(): void
}
class Rethrow {
  + throwConsumer(ConsumerChecked<T, E>): Consumer<T>
  + throwFunction(FunctionChecked<T, R, E>): Function<T, R>
  + throwRunnable(RunnableChecked<E>): Runnable
  + throwBiConsumer(BiConsumerChecked<K, V, E>): BiConsumer<K, V>
  + throwSupplier(SupplierChecked<T, E>): Supplier<T>
  + throwPredicate(PredicateChecked<T, E>): Predicate<T>
  + throwCallable(CallableChecked<R, E>): Callable<R>
  - throwException(Exception): R
  + throwBiFunction(BiFunctionChecked<A, B, R, E>): BiFunction<A, B, R>
}
class RetryCaseTest {
  # runnerUtils: RunnerUtils
  - log: Logger
  - executionQueue: QueueInterface<Execution>
  + retryNewExecutionTaskDuration(): void
  + retryFlowableChild(): void
  + retryExpo(): void
  + retrySuccessAtFirstAttempt(): void
  + retryFailedTaskDuration(): void
  + retryFailedFlowAttempts(): void
  + retryRandom(): void
  + retrySuccess(): void
  + retryNewExecutionTaskAttempts(): void
  + retryDynamicTask(): void
  + retryFailedFlowDuration(): void
  + retryFailed(): void
  + retrySubflow(): void
  + retryFlowableParallel(): void
  + retryFail(): void
  + retryFlowable(): void
  + retryFlowableNestedChild(): void
  + retryNewExecutionFlowDuration(): void
  + retryNewExecutionFlowAttempts(): void
  + retryFailedTaskAttempts(): void
}
class RetryEvents {
  - log: Logger
  ~ onRetry(RetryEvent): void
}
class RetryUtils {
  + of(AbstractRetry, Logger): Instance<T, E>
  + of(): Instance<T, E>
  + of(AbstractRetry): Instance<T, E>
  + of(AbstractRetry, Function<RetryFailed, E>): Instance<T, E>
}
class RetryUtilsTest {
  ~ retryUtils: RetryUtils
  ~ resultNoExceptionRetryNotExceeded(): void
  ~ exceptionExceptionThrowRetryExceeded(): void
  ~ exceptionNoExceptionRetryNotExceeded(): void
  ~ exceptionNoRetry(): void
  - instance(): Instance<T, E>
  ~ resultExceptionThrowRetryExceeded(): void
}
annotation Retryable << annotation >> {
  + MAX_INTEGRAL_DIGITS: int
  + includes(): Class<Throwable>[]
  + multiplier(): String
  + predicate(): Class<RetryPredicate>
  + maxDelay(): String
  + attempts(): String
  + delay(): String
  + value(): Class<Throwable>[]
  + excludes(): Class<Throwable>[]
}
class Return {
  - format: String
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getFormat(): String
  + toString(): String
  + builder(): ReturnBuilder<?, ?>
  + run(RunContext): Output
}
class Reverse {
  - separator: String
  - charset: String
  - from: String
  # canEqual(Object): boolean
  + equals(Object): boolean
  + hashCode(): int
  + getFrom(): String
  + getSeparator(): String
  + getCharset(): String
  + toString(): String
  + builder(): ReverseBuilder<?, ?>
  - $default$separator(): String
  - $default$charset(): String
  + run(RunContext): Output
}
class ReverseTest {
  ~ storageInterface: StorageInterface
  ~ runContextFactory: RunContextFactory
  ~ run(): void
}
class RootController {
  + ping(): HttpResponse<?>
}
class RunContext {
  + encrypt(String): String
  + workingDir(): WorkingDir
  + getTriggerExecutionId(): String
  + logFileURI(): URI
  + version(): String
  + dynamicWorkerResult(List<WorkerTaskResult>): void
  + metrics(): List<AbstractMetricEntry<?>>
  + render(List<String>): List<String>
  + cleanup(): void
  + render(String): String
  + render(List<String>, Map<String, Object>): List<String>
  + render(Map<String, Object>, Map<String, Object>): Map<String, Object>
  + namespaceKv(String): KVStore
  + render(Map<String, Object>): Map<String, Object>
  + dynamicWorkerResults(): List<WorkerTaskResult>
  + pluginConfiguration(String): Optional<T>
  + render(String, Map<String, Object>): String
  + renderTyped(String): Object
  + logger(): Logger
  + storage(): Storage
  + getVariables(): Map<String, Object>
  + stateStore(): StateStore
  + decrypt(String): String
  + metric(AbstractMetricEntry<T>): RunContext
  + render(Set<String>, Map<String, Object>): Set<String>
  + render(Set<String>): Set<String>
  + tenantId(): String
  + renderMap(Map<String, String>, Map<String, Object>): Map<String, String>
  + getStorageOutputPrefix(): URI
  + renderMap(Map<String, String>): Map<String, String>
  + flowInfo(): FlowInfo
  + pluginConfigurations(): Map<String, Object>
}
class RunContextCache {
  - redactedEnvVar: List<String>
  - envVars: Map<String, String>
  - applicationContext: ApplicationContext
  - globalVars: Map<?, ?>
  + getGlobalVars(): Map<?, ?>
  + getEnvVars(): Map<String, String>
  ~ init(): void
  - envVariables(String): Map<String, String>
}
class RunContextFactory {
  # storageInterface: StorageInterface
  # metricRegistry: MetricRegistry
  # variableRenderer: VariableRenderer
  # runContextCache: RunContextCache
  # workingDirFactory: WorkingDirFactory
  - runContextLoggerFactory: RunContextLoggerFactory
  # flowService: FlowService
  # secretKey: Optional<String>
  # pluginConfigurations: PluginConfigurations
  # applicationContext: ApplicationContext
  - kvStoreService: KVStoreService
  + of(Flow, Task, Execution, TaskRun, boolean): RunContext
  + of(Map<String, Object>): RunContext
  # newRunVariablesBuilder(): Builder
  + of(Flow, Execution, Function<Builder, Builder>): RunContext
  + initializer(): RunContextInitializer
  + of(Flow, AbstractTrigger): RunContext
  + of(): RunContext
  + of(Flow, Execution): RunContext
  + of(Flow, Map<String, Object>): RunContext
  - newBuilder(): Builder
  + of(Flow, Task, Execution, TaskRun): RunContext
}
class RunContextInitializer {
  # pluginConfigurations: PluginConfigurations
  # storageInterface: StorageInterface
  # flowService: FlowService
  # contextLoggerFactory: RunContextLoggerFactory
  # secretKey: Optional<String>
  # applicationContext: ApplicationContext
  + forWorker(DefaultRunContext, WorkerTrigger): RunContext
  + forScheduler(DefaultRunContext, TriggerContext, AbstractTrigger): DefaultRunContext
  + forWorker(DefaultRunContext, WorkerTask): DefaultRunContext
  + forPlugin(DefaultRunContext, Plugin): DefaultRunContext
  - forWorker(DefaultRunContext, WorkerTask, Function<Map<String, Object>, Map<String, Object>>): DefaultRunContext
  + forWorker(DefaultRunContext, WorkerTaskResult, TaskRun): DefaultRunContext
  + forWorkingDirectory(DefaultRunContext, WorkerTask): DefaultRunContext
}
class RunContextLogger {
  - loggerName: String
  - logger: Logger
  - logToFile: boolean
  - MAX_MESSAGE_LENGTH: int
  - logQueue: QueueInterface<LogEntry>
  - logEntry: LogEntry
  - useSecrets: List<String>
  - loglevel: Level
  - logFileOS: OutputStream
  - logFile: File
  - logEntry(ILoggingEvent, String, Level, LogEntry): List<LogEntry>
  + getLogFile(): File
  + logger(): Logger
  + logEntries(ILoggingEvent, LogEntry): List<LogEntry>
  - throwable(ILoggingEvent): Throwable
  + usedSecret(String): void
  + get(): Logger
  + closeLogFile(): void
}
class RunContextLoggerFactory {
  - logQueue: QueueInterface<LogEntry>
  + create(Execution): RunContextLogger
  + create(Flow, AbstractTrigger): RunContextLogger
  + create(TaskRun, Task): RunContextLogger
  + create(TriggerContext, AbstractTrigger): RunContextLogger
}
class RunContextLoggerTest {
  ~ runContextFactory: RunContextFactory
  ~ logQueue: QueueInterface<LogEntry>
  ~ secrets(): void
  ~ logs(): void
  ~ emptyLogMessage(): void
}
class RunContextModule {
  - serialVersionUID: long
  + NAME: String
}
class RunContextTest {
  ~ runContextFactory: RunContextFactory
  ~ storageInterface: StorageInterface
  ~ metricRegistry: MetricRegistry
  - secretKey: String
  - logQueue: QueueInterface<LogEntry>
  - flowIO: FlowInputOutput
  ~ pluginDefaultsCaseTest: PluginDefaultsCaseTest
  ~ applicationContext: ApplicationContext
  ~ workerTaskLogQueue: QueueInterface<LogEntry>
  ~ runContextInitializer: RunContextInitializer
  ~ metricsIncrement(): void
  ~ secretTrigger(): void
  ~ withDefaultInput(): void
  ~ largeInput(): void
  ~ inputsLarge(): void
  ~ taskDefaults(): void
  ~ renderMap(): void
  ~ encrypt(): void
  ~ encryptedStringOutput(): void
  ~ withNullLabel(): void
  ~ logs(): void
  ~ variables(): void
}
class RunVariables {
  + SECRET_CONSUMER_VARIABLE_NAME: String
  ~ of(Flow): Map<String, Object>
  ~ of(AbstractTrigger): Map<String, Object>
  ~ of(Task): Map<String, Object>
  ~ of(TaskRun): Map<String, Object>
}
class RunVariablesTest {
  ~ shouldGetVariablesGivenTask(): void
  ~ shouldGetVariablesGivenTrigger(): void
  ~ shouldGetEmptyVariables(): void
  ~ shouldGetVariablesGivenFlowWithNoTenant(): void
  ~ shouldGetVariablesGivenFlowWithTenant(): void
}
interface RunnableTask<T> << interface >> {
  + run(RunContext): T
}
interface RunnerInterface << interface >> {
  + run(): void
}
class RunnerResult {
  - logConsumer: AbstractLogConsumer
  - exitCode: int
  + getExitCode(): int
  + getLogConsumer(): AbstractLogConsumer
}
enum RunnerType << enumeration >> {
  + PROCESS:
  + DOCKER:
  + values(): RunnerType[]
  + valueOf(String): RunnerType
}
class RunnerUtils {
  - conditionService: ConditionService
  + DEFAULT_MAX_WAIT_DURATION: Duration
  - flowRepository: FlowRepositoryInterface
  # executionQueue: QueueInterface<Execution>
  + awaitExecution(Predicate<Execution>, Runnable, Duration): Execution
  + runOne(String, String, String, Integer, BiFunction<Flow, Execution, Map<String, Object>>, Duration, List<Label>): Execution
  + runOneUntilPaused(String, String, String, Integer, BiFunction<Flow, Execution, Map<String, Object>>, Duration): Execution
  - isRunningExecution(Execution): Predicate<Execution>
  + runOneUntilRunning(String, String, String): Execution
  + runOne(String, String, String, Integer): Execution
  + runOneUntilPaused(String, String, String): Execution
  + runOneUntilRunning(String, String, String, Integer, BiFunction<Flow, Execution, Map<String, Object>>, Duration): Execution
  - isPausedExecution(Execution): Predicate<Execution>
  + runOne(Flow, BiFunction<Flow, Execution, Map<String, Object>>, Duration): Execution
  + runOneUntilRunning(Flow, BiFunction<Flow, Execution, Map<String, Object>>, Duration): Execution
  + runOne(String, String, String, Integer, BiFunction<Flow, Execution, Map<String, Object>>, Duration): Execution
  + runOne(Flow, BiFunction<Flow, Execution, Map<String, Object>>): Execution
  + runOne(String, String, String, Integer, BiFunction<Flow, Execution, Map<String, Object>>): Execution
  + runOneUntilPaused(Flow, BiFunction<Flow, Execution, Map<String, Object>>, Duration): Execution
  + runOne(String, String, String): Execution
  + awaitChildExecution(Flow, Execution, Runnable, Duration): Execution
  - isTerminatedExecution(Execution, Flow): Predicate<Execution>
  - isTerminatedChildExecution(Execution, Flow): Predicate<Execution>
  + runOne(Flow, BiFunction<Flow, Execution, Map<String, Object>>, Duration, List<Label>): Execution
  + runOne(String, String, String, Duration): Execution
}
class RuntimeLabelsTest {
  ~ update(): void
  ~ noNpeOnNullPreviousExecutionLabels(): void
}
interface SaveRepositoryInterface<T> << interface >> {
  + save(T): T
}
interface Schedulable << interface >> {
  + PLUGIN_PROPERTY_RECOVER_MISSED_SCHEDULES: String
  + defaultRecoverMissedSchedules(RunContext): RecoverMissedSchedules
  + previousEvaluationDate(ConditionContext): ZonedDateTime
  + getRecoverMissedSchedules(): RecoverMissedSchedules
}
class Schedule {
  - recoverMissedSchedules: RecoverMissedSchedules
  - interval: Duration
  - lateMaximumDelay: Duration
  - CRON_DEFINITION_BUILDER: CronDefinitionBuilder
  - scheduleConditions: List<ScheduleCondition>
  - cron: String
  - backfill: Map<String, Object>
  - CRON_PARSER_WITH_SECONDS: CronParser
  - inputs: Map<String, Object>
  - withSeconds: Boolean
  - log: Logger
  - executionTime: ExecutionTime
  - CRON_PARSER: CronParser
  - timezone: String
  + getCron(): String
  + equals(Object): boolean
  - $default$timezone(): String
  + getRecoverMissedSchedules(): RecoverMissedSchedules
  # canEqual(Object): boolean
  + hashCode(): int
  + getWithSeconds(): Boolean
  + builder(): ScheduleBuilder<?, ?>
  + getInputs(): Map<String, Object>
  + toString(): String
  + getTimezone(): String
  + getBackfill(): Map<String, Object>
  - $default$withSeconds(): Boolean
  + getInterval(): Duration
  - $default$interval(): Duration
  + getLateMaximumDelay(): Duration
  + getScheduleConditions(): List<ScheduleCondition>
  - computePreviousEvaluationDate(ExecutionTime, ZonedDateTime): Optional<ZonedDateTime>
  - handleMaxDelay(Output): Output
  + getConditions(): List<Condition>
  + nextEvaluationDate(ConditionContext, Optional<TriggerContext>): ZonedDateTime
  - conditionContext(ConditionContext, Output): ConditionContext
  - convertDateTime(ZonedDateTime): ZonedDateTime
  + nextEvaluationDate(): ZonedDateTime
  - computeNextEvaluationDate(ExecutionTime, ZonedDateTime): Optional<ZonedDateTime>
  - validateScheduleCondition(ConditionContext): boolean
  - generateInputs(RunContext, Backfill): Map<String, Object>
  + parseCron(): Cron
  - scheduleDates(ExecutionTime, ZonedDateTime): Optional<Output>
  - truePreviousNextDateWithCondition(ExecutionTime, ConditionContext, ZonedDateTime, boolean): Optional<ZonedDateTime>
  + evaluate(ConditionContext, TriggerContext): Optional<Execution>
  + previousEvaluationDate(ConditionContext): ZonedDateTime
  - generateLabels(RunContext, ConditionContext, Backfill): List<Label>
  - executionTime(): ExecutionTime
  - trueOutputWithCondition(ExecutionTime, ConditionContext, Output): Output
}
interface ScheduleCondition << interface >> {
  + test(ConditionContext): boolean
}
interface ScheduleContextInterface << interface >>
class ScheduleDateCaseTest {
  - flowRepository: FlowRepositoryInterface
  # executionQueue: QueueInterface<Execution>
  + shouldScheduleOnDate(): void
}
class ScheduleOnDates {
  - inputs: Map<String, Object>
  - log: Logger
  - interval: Duration
  - recoverMissedSchedules: RecoverMissedSchedules
  - dates: Property<List<ZonedDateTime>>
  - PLUGIN_PROPERTY_RECOVER_MISSED_SCHEDULES: String
  - timezone: String
  # canEqual(Object): boolean
  + equals(Object): boolean
  + hashCode(): int
  + getInterval(): Duration
  + getInputs(): Map<String, Object>
  + getTimezone(): String
  + getDates(): Property<List<ZonedDateTime>>
  - $default$timezone(): String
  + builder(): ScheduleOnDatesBuilder<?, ?>
  - $default$interval(): Duration
  + getRecoverMissedSchedules(): RecoverMissedSchedules
  + toString(): String
  - nextDate(RunContext, Predicate<ZonedDateTime>): Optional<ZonedDateTime>
  + nextEvaluationDate(ConditionContext, Optional<TriggerContext>): ZonedDateTime
  + previousEvaluationDate(ConditionContext): ZonedDateTime
  - generateLabels(RunContext, ConditionContext): List<Label>
  + evaluate(ConditionContext, TriggerContext): Optional<Execution>
  + nextEvaluationDate(): ZonedDateTime
}
class ScheduleOnDatesTest {
  ~ runContextInitializer: RunContextInitializer
  ~ runContextFactory: RunContextFactory
  + shouldReturnNextDateWhenNextEvaluationDateAndAnExistingTriggerDate(): void
  + shouldReturnPreviousDateWhenPreviousEvaluationDate(): void
  + shouldReturnFirstDateWhenNextEvaluationDateAndNoExistingTriggerDate(): void
  - conditionContext(AbstractTrigger): ConditionContext
}
class ScheduleTest {
  ~ runContextInitializer: RunContextInitializer
  ~ runContextFactory: RunContextFactory
  - conditionContext(AbstractTrigger): ConditionContext
  ~ failed(): void
  ~ conditions(): void
  - dateFromVars(String, ZonedDateTime): ZonedDateTime
  ~ everySecond(): void
  ~ timezone(): void
  ~ success_withLabels(): void
  - triggerContext(ZonedDateTime, Schedule): TriggerContext
  ~ successWithInput(): void
  ~ lateMaximumDelay(): void
  ~ everyMinute(): void
  ~ noBackfillNextDate(): void
  ~ success(): void
  ~ hourly(): void
  ~ noBackfillNextDateContext(): void
  ~ impossibleNextConditions(): void
  ~ systemBackfillChangedFromCronExpression(): void
}
annotation ScheduleValidation << annotation >> {
  + message(): String
  + groups(): Class<?>[]
  + payload(): Class<Payload>[]
}
class ScheduleValidationTest {
  - modelValidator: ModelValidator
  ~ lateMaximumDelayValidation(): void
  ~ cronValidation(): void
  ~ intervalValidation(): void
  ~ nicknameValidation(): void
  ~ withSecondsValidation(): void
}
class ScheduleValidator {
  + isValid(Schedule, AnnotationValue<ScheduleValidation>, ConstraintValidatorContext): boolean
}
interface Scheduler << interface >>
class SchedulerCommand {
  - applicationContext: ApplicationContext
  - log: Logger
  + propertiesOverrides(): Map<String, Object>
  + call(): Integer
}
class SchedulerConditionTest {
  # triggerState: SchedulerTriggerStateInterface
  # flowListenersService: FlowListeners
  - createScheduleFlow(): Flow
  ~ schedule(): void
}
class SchedulerEndpoint {
  ~ scheduler: AbstractScheduler
  + running(): SchedulerEndpointResult
}
class SchedulerExecutionWithTrigger {
  - execution: Execution
  - triggerContext: TriggerContext
  + getExecution(): Execution
  + getTriggerContext(): TriggerContext
}
class SchedulerPollingTriggerTest {
  - applicationContext: ApplicationContext
  - triggerState: SchedulerTriggerStateInterface
  - flowListenersService: FlowListeners
  - createPollingTriggerFlow(PollingTrigger): Flow
  ~ pollingTriggerStopAfter(): void
  ~ pollingTrigger(): void
  ~ failedEvaluationTest(): void
  - scheduler(FlowListeners): AbstractScheduler
  - createPollingTrigger(List<Type>): PollingTriggerBuilder<?, ?>
}
class SchedulerScheduleOnDatesTest {
  # flowListenersService: FlowListeners
  # triggerState: SchedulerTriggerStateInterface
  ~ scheduleOnDates(): void
  ~ recoverLASTMissing(): void
  # scheduler(FlowListeners): AbstractScheduler
  - createScheduleFlow(String, String): Flow
  ~ recoverNONEMissing(): void
  ~ recoverALLMissing(): void
  - createScheduleOnDatesTrigger(String, List<ZonedDateTime>, String): ScheduleOnDatesBuilder<?, ?>
}
class SchedulerScheduleTest {
  # flowListenersService: FlowListeners
  # triggerState: SchedulerTriggerStateInterface
  # logQueue: QueueInterface<LogEntry>
  ~ stopAfterSchedule(): void
  ~ schedule(): void
  # scheduler(FlowListeners): AbstractScheduler
  ~ failedEvaluationTest(): void
  ~ disabled(): void
  - createScheduleTrigger(String, String, String, boolean): ScheduleBuilder<?, ?>
  ~ backfill(): void
  - createScheduleFlow(String, String, boolean): Flow
  ~ recoverNONEMissing(): void
  ~ recoverALLMissing(): void
  ~ retroSchedule(): void
  ~ recoverLASTMissing(): void
  - date(int): ZonedDateTime
}
class SchedulerStreamingTest {
  # flowListenersService: FlowListeners
  # triggerState: SchedulerTriggerStateInterface
  # startedEvaluate: Map<Boolean, Integer>
  - run(Flow, CountDownLatch, Consumer<List<Execution>>): void
  ~ failed(): void
  - createFlow(Boolean): Flow
  ~ simple(): void
}
class SchedulerThreadTest {
  # flowListenersService: FlowListeners
  # triggerState: SchedulerTriggerStateInterface
  ~ thread(): void
}
class SchedulerTriggerChangeTest {
  # logsQueue: QueueInterface<LogEntry>
  # killedQueue: QueueInterface<ExecutionKilled>
  # flowListenersService: FlowListeners
  - STARTED_COUNT: int
  # flowQueue: QueueInterface<Flow>
  # triggerState: SchedulerTriggerStateInterface
  + createFlow(Duration): Flow
  ~ run(): void
}
interface SchedulerTriggerStateInterface << interface >> {
  + create(Trigger): Trigger
  + findByNextExecutionDateReadyForGivenFlows(List<Flow>, ZonedDateTime, ScheduleContextInterface): List<Trigger>
  + findLast(TriggerContext): Optional<Trigger>
  + update(Flow, AbstractTrigger, ConditionContext): Trigger
  + findAllForAllTenants(): List<Trigger>
  + save(Trigger, ScheduleContextInterface): Trigger
  + update(Trigger): Trigger
  + findByNextExecutionDateReadyForAllTenants(ZonedDateTime, ScheduleContextInterface): List<Trigger>
  + unlock(Trigger): void
}
class SchedulerTriggerStateInterfaceTest {
  # triggerState: SchedulerTriggerStateInterface
  - trigger(): TriggerBuilder<?, ?>
  ~ all(): void
}
class Schema {
  - properties: Map<String, Object>
  - outputs: Map<String, Object>
  - definitions: Map<String, Object>
  + equals(Object): boolean
  + getProperties(): Map<String, Object>
  + getOutputs(): Map<String, Object>
  + getDefinitions(): Map<String, Object>
  + setProperties(Map<String, Object>): void
  + setOutputs(Map<String, Object>): void
  + setDefinitions(Map<String, Object>): void
  # canEqual(Object): boolean
  + hashCode(): int
  + toString(): String
}
enum SchemaType << enumeration >> {
  + trigger:
  + task:
  + template:
  + flow:
  + plugindefault:
  + values(): SchemaType[]
  + valueOf(String): SchemaType
}
class ScriptOutput {
  - vars: Map<String, Object>
  - outputFiles: Map<String, URI>
  - stdErrLineCount: int
  - exitCode: int
  - stdOutLineCount: int
  - warningOnStdErr: Boolean
  + getVars(): Map<String, Object>
  + getExitCode(): int
  + getOutputFiles(): Map<String, URI>
  + getStdOutLineCount(): int
  + getStdErrLineCount(): int
  + getWarningOnStdErr(): Boolean
  + builder(): ScriptOutputBuilder
  + finalState(): Optional<Type>
}
class ScriptOutputFormat<T> {
  - metrics: List<AbstractMetricEntry<T>>
  - outputs: Map<String, Object>
  + getOutputs(): Map<String, Object>
  + getMetrics(): List<AbstractMetricEntry<T>>
  + setOutputs(Map<String, Object>): void
  + setMetrics(List<AbstractMetricEntry<T>>): void
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + toString(): String
}
class ScriptService {
  + ENV_BUCKET_PATH: String
  + VAR_WORKING_DIR: String
  + ENV_OUTPUT_DIR: String
  + VAR_OUTPUT_DIR: String
  - INTERNAL_STORAGE_PATTERN: Pattern
  + ENV_WORKING_DIR: String
  + VAR_BUCKET_PATH: String
  - normalizeValue(String, boolean, boolean): String
  + replaceInternalStorage(RunContext, Map<String, Object>, String, boolean): String
  - withPrefix(String, String): String
  + scriptCommands(List<String>, List<String>, String): List<String>
  + scriptCommands(List<String>, List<String>, List<String>): List<String>
  - saveOnLocalStorage(RunContext, String): String
  + normalize(String): String
  + replaceInternalStorage(RunContext, Map<String, Object>, List<String>, boolean): List<String>
  + uploadOutputFiles(RunContext, Path): Map<String, URI>
  + scriptCommands(List<String>, List<String>, List<String>, TargetOS): List<String>
  + scriptCommands(List<String>, List<String>, String, TargetOS): List<String>
  + labels(RunContext, String, boolean, boolean): Map<String, String>
  + jobName(RunContext): String
  + replaceInternalStorage(RunContext, String?, boolean): String
  + labels(RunContext, String): Map<String, String>
  + replaceInternalStorage(RunContext, List<String>): List<String>
}
class ScriptServiceTest {
  - runContextFactory: RunContextFactory
  + COMMAND_PATTERN_CAPTURE_LOCAL_PATH: Pattern
  ~ uploadOutputFiles(): void
  ~ jobName(): void
  ~ normalize(): void
  - runContext(RunContextFactory, String): RunContext
  ~ scriptCommands(): void
  ~ replaceInternalStorage(): void
  ~ uploadInputFiles(): void
  ~ labels(): void
}
class SearchResult<T> {
  ~ model: T
  ~ fragments: List<String>
  + getModel(): T
  + getFragments(): List<String>
}
class Secret {
  - logger: Supplier<Logger>
  - secretKey: Optional<String>
  ~ encrypt(String): String
  ~ decrypt(String): String
  ~ decrypt(Map<String, Object>): Map<String, Object>
}
class SecretFunction {
  - secretService: SecretService
  - log: Logger
  + execute(Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
  + getArgumentNames(): List<String>
  # getSecretKey(Map<String, Object>, PebbleTemplate, int): String
}
class SecretFunctionTest {
  - secretService: SecretService
  ~ logQueue: QueueInterface<LogEntry>
  - runnerUtils: RunnerUtils
  ~ getUnknownSecret(): void
  ~ getSecret(): void
}
class SecretInput {
  ~ validator: String
  + getValidator(): String
  + builder(): SecretInputBuilder<?, ?>
  + validate(String): void
}
class SecretNotFoundException {
  - serialVersionUID: long
}
interface SecretPluginInterface << interface >>
class SecretService {
  - SECRET_PREFIX: String
  - decodedSecrets: Map<String, String>
  - log: Logger
  + findSecret(String, String, String): String
  - postConstruct(): void
}
class SelectInput {
  ~ allowCustomValue: Boolean
  ~ values: List<String>
  ~ expression: String
  + getValues(): List<String>
  + getExpression(): String
  + getAllowCustomValue(): Boolean
  - $default$allowCustomValue(): Boolean
  + builder(): SelectInputBuilder<?, ?>
  + validate(String): void
  + render(Function<String, Object>): Input<?>
  - renderExpressionValues(Function<String, Object>): List<String>
}
class SelectInputTest {
  ~ runContextFactory: RunContextFactory
  ~ shouldRenderInputGivenExpressionReturningStrings(): void
  ~ shouldRenderInputGivenExpressionReturningIntegers(): void
}
class Sequential {
  # errors: List<Task>
  - tasks: List<Task>
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getErrors(): List<Task>
  + getTasks(): List<Task>
  + toString(): String
  + builder(): SequentialBuilder<?, ?>
  + tasksTree(Execution, TaskRun, List<String>): AbstractGraph
  + allChildTasks(): List<Task>
  + resolveNexts(RunContext, Execution, TaskRun): List<NextTaskRun>
  + childTasks(RunContext, TaskRun): List<ResolvedTask>
}
class SequentialTest {
  ~ sequentialWithGlobalErrors(): void
  ~ sequentialWithLocalErrors(): void
  ~ sequential(): void
}
class ServerCommand {
  - log: Logger
  + call(): Integer
}
interface ServerCommandInterface << interface >>
class ServerCommandValidator {
  - VALIDATED_PROPERTIES: Map<String, String>
  - log: Logger
  - environment: Environment
  ~ validate(): void
}
class ServerCommandValidatorTest {
  ~ serverCommandIssued(): void
  ~ noServerCommandIssued(): void
  - getRootException(Throwable): Throwable
}
entity ServerConfig << record >> {
  - terminationGracePeriod: Duration
  - workerTaskRestartStrategy: WorkerTaskRestartStrategy
  - liveness: Liveness
  + terminationGracePeriod(): Duration
  + liveness(): Liveness
  + workerTaskRestartStrategy(): WorkerTaskRestartStrategy
}
class ServerConfigTest {
  ~ config: ServerConfig
  ~ test(): void
}
entity ServerInfo << record >> {
  - commitDate: ZonedDateTime
  - commit: String
  - version: String
  - type: String
  + commit(): String
  + commitDate(): ZonedDateTime
  + type(): String
  + version(): String
}
entity ServerInstance << record >> {
  - metrics: Set<Metric>
  - type: Type
  - hostname: String
  - id: String
  - props: Map<String, Object>
  - version: String
  + INSTANCE_ID: String
  + type(): Type
  + metrics(): Set<Metric>
  + id(): String
  + props(): Map<String, Object>
  + version(): String
  + hostname(): String
}
class ServerInstanceFactory {
  - environment: Environment
  - context: KestraContext
  - getServerManagementPort(): int
  + newServerInstance(): ServerInstance
  - getServerPort(): int
  - getInstanceType(): Type
  - getServerType(): ServerType
}
enum ServerType << enumeration >> {
  + WORKER:
  + SCHEDULER:
  + WEBSERVER:
  + EXECUTOR:
  + STANDALONE:
  + INDEXER:
  + valueOf(String): ServerType
  + values(): ServerType[]
}
interface Service << interface >> {
  + skipGracefulTermination(boolean): void
  + close(): void
  + getId(): String
  + getType(): ServiceType
  + getMetrics(): Set<Metric>
  + unwrap(): T
  + getState(): ServiceState
}
entity ServiceInstance << record >> {
  - server: ServerInstance
  - type: ServiceType
  - events: List<TimestampedEvent>
  - config: ServerConfig
  - seqId: long
  - SERVICE_STATE_UPDATED_EVENT_TYPE: String
  - createdAt: Instant
  - updatedAt: Instant
  - props: Map<String, Object>
  - metrics: Set<Metric>
  - id: String
  - state: ServiceState
  + props(): Map<String, Object>
  + id(): String
  + server(): ServerInstance
  + createdAt(): Instant
  + updatedAt(): Instant
  + state(ServiceState, Instant, String): ServiceInstance
  + create(String, ServiceType, ServerInstance, Instant, Instant, ServerConfig, Map<String, Object>, Set<Metric>): ServiceInstance
  + type(): ServiceType
  + isSessionTimeoutElapsed(Instant): boolean
  + server(ServerInstance): ServiceInstance
  + is(ServiceType): boolean
  + metrics(Set<Metric>): ServiceInstance
  + events(): List<TimestampedEvent>
  + isTerminationGracePeriodElapsed(Instant): boolean
  + config(): ServerConfig
  + state(): ServiceState
  + is(ServiceState): boolean
  + metrics(): Set<Metric>
  + state(ServiceState, Instant): ServiceInstance
  + groupByProperty(Collection<ServiceInstance>, String): Map<String, List<ServiceInstance>>
  + seqId(): long
}
interface ServiceInstanceRepositoryInterface << interface >> {
  + findAllInstancesBetween(ServiceType, Instant, Instant): List<ServiceInstance>
  + find(Pageable, Set<ServiceState>, Set<ServiceType>): ArrayListTotal<ServiceInstance>
  + findById(String): Optional<ServiceInstance>
  + findAllInstancesInStates(Set<ServiceState>): List<ServiceInstance>
  + findAll(): List<ServiceInstance>
  + findAllInstancesInState(ServiceState): List<ServiceInstance>
  + delete(ServiceInstance): void
  + sortMapping(): Function<String, String>
  + mayTransitionServiceTo(ServiceInstance, ServiceState): Response
  + mayTransitionServiceTo(ServiceInstance, ServiceState, String): Response
  + save(ServiceInstance): ServiceInstance
}
class ServiceInstanceTest {
  + CONFIG: ServerConfig
  ~ shouldUpdateGivenReason(): void
  ~ shouldGroupInstanceGivenAnExistingProperty(): void
  - createServiceInstanceWithProperties(Map<String, Object>): ServiceInstance
  ~ shouldGetTrueForRunningAndTimeout(): void
  ~ shouldGetFalseForRunningAndNotTimeout(): void
}
class ServiceLivenessManager {
  - log: Logger
  - localServiceStateFactory: LocalServiceStateFactory
  - stateLock: ReentrantLock
  - serverInstanceFactory: ServerInstanceFactory
  - lastSucceedStateUpdated: Instant
  - serviceRepository: ServiceInstanceRepositoryInterface
  - TASK_NAME: String
  - serviceRegistry: ServiceRegistry
  # onStateTransitionFailureCallback: OnStateTransitionFailureCallback
  # getScheduleInterval(): Duration
  - localServiceState(Service): LocalServiceState
  + close(): void
  - mayDisableStateUpdate(Service, ServiceInstance): void
  - onCreateState(ServiceStateChangeEvent): void
  + updateServiceInstance(Service, ServiceInstance): void
  + onServiceStateChangeEvent(ServiceStateChangeEvent): void
  # lastSucceedStateUpdated(): Instant
  # beforeScheduledStateUpdate(Instant, Service, ServiceInstance): boolean
  + allServiceInstances(): List<ServiceInstance>
  # onSchedule(Instant): void
  # updateServiceInstanceState(Instant, Service, ServiceState?, OnStateTransitionFailureCallback): ServiceInstance
}
class ServiceLivenessManagerTest {
  + repository: ServiceInstanceRepositoryInterface
  - DEFAULT_DURATION: Duration
  ~ workerInstanceCaptor: ArgumentCaptor<ServiceInstance>
  - serviceLivenessManager: ServiceLivenessManager
  - onStateTransitionFailureCallback: OnStateTransitionFailureCallback
  + serviceInstanceFor(Service): ServiceInstance
  ~ beforeEach(): void
  ~ shouldNotRunOnStateTransitionFailureForAbortedTransition(): void
  + newServiceForState(ServiceState): Service
  ~ shouldRunOnStateTransitionFailureForFailedTransition(): void
  ~ shouldSaveWorkerInstanceOnRunningStateChange(): void
  ~ shouldUpdateStateOnScheduleForSucceedTransition(): void
}
class ServiceRegistry {
  - services: ConcurrentHashMap<ServiceType, LocalServiceState>
  + all(): List<LocalServiceState>
  + isEmpty(): boolean
  + waitForServiceAndGet(ServiceType): Service
  + get(ServiceType): LocalServiceState
  + register(LocalServiceState): void
  + containsService(ServiceType): boolean
  + unregister(LocalServiceState): void
  + getServiceByType(ServiceType): Service
  + waitForServiceInState(ServiceType, ServiceState, Duration): boolean
}
class ServiceStateChangeEvent {
  - serialVersionUID: long
  - properties: Map<String, Object>
  + properties(): Map<String, Object>
  + getService(): Service
}
class ServiceStateTransition {
  - LOG: Logger
  + logTransitionAndGetResponse(ServiceInstance, ServiceState, ImmutablePair<ServiceInstance, ServiceInstance>?): Response
}
class ServiceTest {
  ~ shouldReturnValidTransitionForPendingShutdown(): void
  ~ shouldReturnValidTransitionForForcedShutdown(): void
  ~ shouldReturnValidTransitionForRunning(): void
  ~ shouldReturnValidTransitionForDisconnected(): void
  ~ shouldReturnValidTransitionForGracefulShutdown(): void
  ~ shouldReturnTrueForDisconnectedOrPendingShutDown(): void
  ~ shouldReturnValidTransitionForNotRunning(): void
}
class ServicesFiles {
  + SERVICES_PATH: String
  ~ writeServiceFile(Collection<String>, OutputStream): void
  ~ getPath(String): String
  ~ readServiceFile(InputStream): Set<String>
}
class ServicesFilesTest {
  ~ shouldReadServiceFileFromMetaInf(): void
}
class Set {
  - data: Map<String, Object>
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getData(): Map<String, Object>
  + toString(): String
  + builder(): SetBuilder<?, ?>
  + run(RunContext): Output
}
class Set {
  - key: String
  - ttl: Duration
  - value: String
  - namespace: String
  - overwrite: boolean
  - kvType: KVType
  + getNamespace(): String
  + getKey(): String
  + getValue(): String
  + isOverwrite(): boolean
  + getTtl(): Duration
  + getKvType(): KVType
  - $default$namespace(): String
  - $default$overwrite(): boolean
  + builder(): SetBuilder<?, ?>
  + toBuilder(): SetBuilder<?, ?>
  + run(RunContext): VoidOutput
}
class SetTest {
  ~ TEST_KEY: String
  ~ storageInterface: StorageInterface
  ~ runContextFactory: RunContextFactory
  ~ shouldSetKVGivenSameNamespace(): void
  ~ shouldSetKVGivenTTL(): void
  ~ shouldSetKVGivenNoNamespace(): void
  ~ shouldFailGivenNonExistingNamespace(): void
  ~ shouldFailGivenExistingKeyAndOverwriteFalse(): void
  ~ shouldSetKVGivenChildNamespace(): void
  ~ typeSpecified(): void
}
class Setting {
  - key: String
  - value: Object
  + INSTANCE_UUID: String
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getKey(): String
  + getValue(): Object
  + toString(): String
  + builder(): SettingBuilder<?, ?>
}
interface SettingRepositoryInterface << interface >> {
  + save(Setting): Setting
  + delete(Setting): Setting
  + findByKey(String): Optional<Setting>
  + findAll(): List<Setting>
}
class Size {
  - uri: String
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getUri(): String
  + toString(): String
  + builder(): SizeBuilder<?, ?>
  + run(RunContext): Output
}
class SizeTest {
  ~ runContextFactory: RunContextFactory
  ~ storageInterface: StorageInterface
  ~ run(): void
}
class SkipExecutionCaseTest {
  - executionRepository: ExecutionRepositoryInterface
  # runnerUtils: RunnerUtils
  - skipExecutionService: SkipExecutionService
  # executionQueue: QueueInterface<Execution>
  - createFlow(): Flow
  + skipExecution(): void
}
class SkipExecutionService {
  - skipNamespaces: List<NamespaceId>
  - skipExecutions: List<String>
  - skipFlows: List<FlowId>
  - skipTenants: List<String>
  + setSkipFlows(List<String>): void
  - splitIdParts(String): String[]
  + setSkipNamespaces(List<String>): void
  ~ skipExecution(String, String, String, String): boolean
  + setSkipTenants(List<String>): void
  + setSkipExecutions(List<String>): void
  + skipExecution(String): boolean
  + skipExecution(Execution): boolean
  + skipExecution(TaskRun): boolean
}
class SkipExecutionServiceTest {
  - skipExecutionService: SkipExecutionService
  ~ skipExecutionByExecution(): void
  ~ skipExecutionByNamespace(): void
  ~ skipExecutionByFlowId(): void
  ~ skipExecutionByTenantId(): void
  ~ skipExecutionByExecutionId(): void
  ~ resetAll(): void
  ~ skipExecutionByTaskRun(): void
}
class Sleep {
  - duration: Long
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getDuration(): Long
  + toString(): String
  + builder(): SleepBuilder<?, ?>
  + run(RunContext): VoidOutput
}
class SleepTrigger {
  - duration: Long
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getDuration(): Long
  + toString(): String
  + builder(): SleepTriggerBuilder<?, ?>
  + getInterval(): Duration
  + evaluate(ConditionContext, TriggerContext): Optional<Execution>
}
class Slugify {
  - WHITESPACE: Pattern
  - DASH_PATTERN: Pattern
  - NONLATIN: Pattern
  + toStartCase(String): String
  + of(String): String
}
class SlugifyFilter {
  + apply(Object, Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
}
class SlugifyFilterTest {
  ~ variableRenderer: VariableRenderer
  ~ out(): void
}
class SlugifyTest {
  ~ merge(String, String): void
  ~ source(): Stream<Arguments>
}
class Split {
  - separator: String
  - from: String
  - rows: Integer
  - partitions: Integer
  - bytes: String
  # canEqual(Object): boolean
  + equals(Object): boolean
  + hashCode(): int
  + getFrom(): String
  + getBytes(): String
  - $default$separator(): String
  + builder(): SplitBuilder<?, ?>
  + getPartitions(): Integer
  + getRows(): Integer
  + getSeparator(): String
  + toString(): String
  + run(RunContext): Output
}
class SplitTest {
  ~ storageInterface: StorageInterface
  ~ runContextFactory: RunContextFactory
  ~ rows(): void
  ~ storageUpload(int): URI
  ~ bytes(): void
  ~ partition(): void
  - readAll(List<URI>): String
  - content(int): List<String>
}
class StackdriverJsonLayout {
  - SEVERITY_ATTRIBUTE: String
  - includeExceptionInMessage: boolean
  - TIMESTAMP_NANOS_ATTRIBUTE: String
  - TIMESTAMP_SECONDS_ATTRIBUTE: String
  - customJson: Map<String, Object>
  + isIncludeExceptionInMessage(): boolean
  + getCustomJson(): Map<String, Object>
  + setIncludeExceptionInMessage(boolean): void
  + setCustomJson(Map<String, Object>): void
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + toString(): String
  # toJsonMap(ILoggingEvent): Map<String, Object>
}
class StandAloneCommand {
  - skipExecutionService: SkipExecutionService
  - skipExecutions: List<String>
  ~ tutorialsDisabled: boolean
  - applicationContext: ApplicationContext
  - notStartExecutors: List<String>
  - flowPath: File
  - skipFlows: List<String>
  - workerThread: int
  - skipTenants: List<String>
  - startExecutors: List<String>
  ~ spec: CommandSpec
  - log: Logger
  - skipNamespaces: List<String>
  - startExecutorService: StartExecutorService
  + isFlowAutoLoadEnabled(): boolean
  + call(): Integer
  + propertiesOverrides(): Map<String, Object>
}
class StandAloneRunner {
  # workerEnabled: boolean
  - running: boolean
  - applicationContext: ApplicationContext
  - runningTimeout: Duration
  - servers: List<Service>
  # schedulerEnabled: boolean
  - executorsUtils: ExecutorsUtils
  - poolExecutor: ExecutorService
  # workerThread: int
  - log: Logger
  + close(): void
  + setWorkerThread(int): void
  + setSchedulerEnabled(boolean): void
  + setWorkerEnabled(boolean): void
  + run(): void
  + isRunning(): boolean
}
class StartExecutorService {
  - startExecutors: List<String>
  - applicationContext: ApplicationContext
  - notStartExecutors: List<String>
  + shouldStartExecutor(String): boolean
  + applyOptions(List<String>, List<String>): void
}
class StartExecutorServiceTest {
  - startExecutorService: StartExecutorService
  ~ shouldStartExecutor(): void
}
class StartsWithFilter {
  + FILTER_NAME: String
  - ARGUMENT_VALUE: String
  - ARGS: List<String>
  + getArgumentNames(): List<String>
  + apply(Object, Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
}
class StartsWithFilterTest {
  ~ variableRenderer: VariableRenderer
  ~ out(): void
}
interface StartupHookInterface << interface >> {
  + start(AbstractCommand): void
}
class State {
  - current: Type
  - histories: List<History>
  - log: Logger
  + isResumable(): boolean
  + getCurrent(): Type
  + getHistories(): List<History>
  + equals(Object): boolean
  + hashCode(): int
  + toString(): String
  + reset(): State
  + getStartDate(): Instant
  + runningTypes(): Type[]
  + isTerminated(): boolean
  + isSuccess(): boolean
  + minDate(): Instant
  + withState(Type): State
  + getDuration(): Duration
  + maxDate(): Instant
  + humanDuration(): String
  + isRetrying(): boolean
  + of(Type, List<History>): State
  + isFailed(): boolean
  + getEndDate(): Optional<Instant>
  + isRunning(): boolean
  + isCreated(): boolean
  + isRestartable(): boolean
  + isPaused(): boolean
}
class StateNamespaceTest {
  ~ runContextFactory: RunContextFactory
  - runContextFlow2(Task): RunContext
  ~ run(): void
  - runContextFlow1(Task): RunContext
}
entity StateStore << record >> {
  - hashTaskRunValue: boolean
  - runContext: RunContext
  + deleteState(String, String, String): boolean
  - oldStateStoreUri(String, boolean, String, String, String?, String): URI
  + getState(String, String?, String): InputStream
  + putState(boolean, String, String, String, byte[]): String
  + runContext(): RunContext
  + deleteState(boolean, String, String, String): boolean
  + getState(boolean, String, String?, String): InputStream
  + putState(String, String, String, byte[]): String
  - statePrefix(String, boolean, String, String, String?): String
  - nameSuffix(String): String
  + hashTaskRunValue(): boolean
}
class StateStoreCommand {
  + call(): Integer
}
class StateStoreCommandTest {
  ~ runWithNoParam(): void
}
class StateStoreMigrateCommand {
  - log: Logger
  - applicationContext: ApplicationContext
  + call(): Integer
  - runContext(RunContextFactory, Flow): RunContext
}
class StateStoreMigrateCommandTest {
  ~ runMigration(): void
}
class StateStoreTest {
  - runContextFactory: RunContextFactory
  ~ all(): void
  ~ getState_WithOldStateStore_ShouldThrowMigrationException(): void
  ~ subNameAndTaskrunValueOptional(): void
  - runContext(): RunContext
}
class StateTest {
  ~ set(): void
  ~ each(): void
}
class StateTest {
  ~ runContextFactory: RunContextFactory
  ~ deleteThrow(): void
  ~ getThrow(): void
  ~ run(): void
}
class StaticFilter {
  # googleAnalytics: String
  # htmlHead: String
  # basePath: String
  + doFilter(HttpRequest<?>, ServerFilterChain): Publisher<MutableHttpResponse<?>>
  - replace(String): String
}
class StatsController {
  # executionRepository: ExecutionRepositoryInterface
  - tenantService: TenantService
  # flowRepositoryInterface: FlowRepositoryInterface
  # logRepositoryInterface: LogRepositoryInterface
  # triggerRepositoryInterface: TriggerRepositoryInterface
  + dailyGroupByFlowStatistics(ByFlowStatisticRequest): Map<String, Map<String, List<DailyExecutionStatistics>>>
  + dailyStatistics(StatisticRequest): List<DailyExecutionStatistics>
  + summary(SummaryRequest): SummaryStatistics
  + dailyStatisticsGroupByNamespace(ByNamespaceStatisticRequest): Map<String, ExecutionCountStatistics>
  + logsDailyStatistics(LogStatisticRequest): List<LogStatistics>
  + lastExecutions(LastExecutionsRequest): List<Execution>
  + taskRunsDailyStatistics(StatisticRequest): List<DailyExecutionStatistics>
}
class StatsControllerTest {
  ~ client: ReactorHttpClient
  ~ dailyStatistics(): void
  ~ shouldGetSummary(): void
  ~ lastExecutions(): void
  ~ shouldGetDailyStatisticsGroupByNamespace(): void
  ~ logsDailyStatistics(): void
  ~ logDailyExecutions(): void
}
interface Storage << interface >> {
  + putFile(InputStream, URI): URI
  + putFile(File, String): URI
  + putFile(InputStream, String): URI
  + getCacheFile(String, String?): Optional<InputStream>
  + isFileExist(URI): boolean
  + deleteExecutionFiles(): List<URI>
  + namespace(): Namespace
  + getFile(URI): InputStream
  + putFile(File): URI
  + namespace(String): Namespace
  + deleteFile(URI): boolean
  + putCacheFile(File, String, String?): URI
  + deleteCacheFile(String, String?): Optional<Boolean>
  + getContextBaseURI(): URI
  + getCacheFile(String, String?, Duration?): Optional<InputStream>
  + getTaskStorageContext(): Optional<Task>
}
class StorageContext {
  ~ PREFIX_FORMAT_TRIGGER: String
  + KESTRA_PROTOCOL: String
  + KESTRA_SCHEME: String
  + PREFIX_MESSAGES: String
  - flowId: String
  ~ PREFIX_FORMAT_CACHE: String
  ~ PREFIX_FORMAT_KV: String
  ~ PREFIX_FORMAT_FLOWS: String
  ~ PREFIX_FORMAT_CACHE_OBJECT: String
  ~ PREFIX_FORMAT_EXECUTIONS: String
  ~ PREFIX_FORMAT_NAMESPACE_FILE: String
  ~ PREFIX_FORMAT_INPUTS: String
  - namespace: String
  - tenantId: String
  - executionId: String
  ~ PREFIX_FORMAT_TASK: String
  + getTenantId(): String
  + getNamespace(): String
  + getFlowId(): String
  + getExecutionId(): String
  + getContextStorageURI(): URI
  + toString(): String
  + forTask(String?, String, String, String, String, String, String?): Task
  + getStateStorePrefix(String, Boolean, String): String
  + getExecutionStorageURI(): URI
  + getExecutionStorageURI(String?): URI
  + forExecution(Execution): StorageContext
  + extractExecutionId(URI): Optional<String>
  + forInput(Execution, String, String): Input
  + forExecution(String?, String, String, String): StorageContext
  + forFlow(Flow): StorageContext
  + forTask(TaskRun): StorageContext
  + getCacheURI(String, String?): URI
  + getFlowStorageURI(): URI
  + kvPrefix(String): String
  + namespaceFilePrefix(String): String
  + getNamespaceAsPath(): String
  + forTrigger(String?, String, String, String, String): Trigger
}
class StorageContextTest {
  ~ shouldGetValidUriForExecutionContextWithScheme(): void
  ~ shouldGetTaskCachePrefix(): void
  ~ shouldGetValidURIForTaskContext(): void
  ~ shouldGetValidURIForTriggerContext(): void
  ~ shouldGetNamespaceFilePrefix(): void
  ~ shouldGetValidUriForFlowContext(): void
  ~ shouldGetValidUriForExecutionContext(): void
}
interface StorageInterface << interface >> {
  + getWithMetadata(String, URI): StorageObject
  + delete(String, URI): boolean
  + getAttributes(String, URI): FileAttributes
  + exists(String, URI): boolean
  + allByPrefix(String, URI, boolean): List<URI>
  + list(String, URI): List<FileAttributes>
  + createDirectory(String, URI): URI
  + deleteByPrefix(String, URI): List<URI>
  + put(String, URI, InputStream): URI
  + from(Execution, String, File): URI
  + get(String, URI): InputStream
  + init(): void
  + put(String, URI, StorageObject): URI
  + move(String, URI, URI): URI
  + close(): void
}
class StorageInterfaceFactory {
  + KESTRA_STORAGE_TYPE_CONFIG: String
  - log: Logger
  - allStorageClasses(PluginRegistry): Stream<Class<StorageInterface>>
  + make(PluginRegistry, String, Map<String, Object>, Validator): StorageInterface
  - allIdsFor(Stream<Class<StorageInterface>>): String
  + getLoggableStorageIds(PluginRegistry): String
}
class StorageInterfaceFactoryTest {
  ~ registry: DefaultPluginRegistry
  ~ validator: Validator
  ~ shouldFailedGivenInvalidConfig(): void
  ~ shouldReturnStorageGivenValidId(): void
  ~ shouldFailedGivenInvalidId(): void
}
entity StorageObject << record >> {
  - metadata: Map<String, String>
  - inputStream: InputStream
  + metadata(): Map<String, String>
  + inputStream(): InputStream
}
class StorageService {
  - split(RunContext, String, String, BufferedReader, BiFunction<Integer, Integer, Boolean>): List<Path>
  + split(RunContext, StorageSplitInterface, URI): List<URI>
  - partition(RunContext, String, String, BufferedReader, int): List<Path>
}
interface StorageSplitInterface << interface >> {
  + getBytes(): String
  + getPartitions(): Integer
  + getRows(): Integer
  + getSeparator(): String
}
class StorageTestSuite {
  - CONTENT_STRING: String
  # storageInterface: StorageInterface
  ~ deleteNoTraversal(): void
  ~ move(): void
  ~ putNoTraversal(): void
  - exists(String, String): void
  ~ sizeNotFound(): void
  ~ createDirectoryWithScheme(): void
  ~ getAttributesNoTenant(): void
  ~ deleteByPrefixNotFound(): void
  ~ getAttributesWithScheme(): void
  ~ getNoCrossTenant(): void
  - list(String, String): void
  ~ putNoTenant(): void
  ~ deleteNotFound(): void
  ~ lastModifiedTimeNoTenant(): void
  ~ listWithScheme(): void
  ~ listNotFound(): void
  ~ sizeNoCrossTenant(): void
  ~ filesByPrefix(): void
  ~ existsNoTraversal(): void
  - createDirectory(String, String): void
  ~ listNoTraversal(): void
  ~ lastModifiedTimeNoCrossTenant(): void
  ~ createDirectory(): void
  ~ sizeNoTenant(): void
  - deleteByPrefix(String, String): void
  ~ existsNoCrossTenant(): void
  ~ deleteWithScheme(): void
  ~ objectsByPrefix(): void
  ~ existsWithScheme(): void
  - putFile(String, String, Map<String, String>): URI
  ~ existsNoTenant(): void
  ~ lastModifiedTimeNoTraversal(): void
  ~ listNoCrossTenant(): void
  ~ lastModifiedTimeNotFound(): void
  ~ put(): void
  ~ lastModifiedTimeWithScheme(): void
  ~ metadata(): void
  ~ sizeNoTraversal(): void
  ~ sizeWithScheme(): void
  ~ getWithScheme(): void
  ~ getNoTraversal(): void
  ~ putWithScheme(): void
  ~ exists(): void
  ~ deleteByPrefixNoTraversal(): void
  ~ deleteByPrefixNoTenant(): void
  ~ getFileNotFound(): void
  - move(String, String): void
  ~ listNoTenant(): void
  ~ createDirectoryShouldBeRecursive(): void
  ~ getAttributes(): void
  - get(String, String): void
  - size(String, String): void
  ~ getAttributesNotFound(): void
  - getAttributes(String, String): void
  ~ deleteNoTenant(): void
  ~ moveWithScheme(): void
  ~ list(): void
  - put(String, String): void
  - putFile(String, String): URI
  ~ get(): void
  ~ getAttributesNoCrossTenant(): void
  ~ createDirectoryNoTenant(): void
  ~ delete(): void
  ~ getNoTenant(): void
  - lastModifiedTime(String, String): void
  ~ moveNoTenant(): void
  ~ getAttributesNoTraversal(): void
  ~ size(): void
  ~ deleteByPrefix(): void
  - delete(String, String): void
  ~ deleteByPrefixWithScheme(): void
  ~ createDirectoryNoTraversal(): void
  ~ lastModifiedTime(): void
  ~ moveNoTraversal(): void
  ~ moveNotFound(): void
}
class StringInput {
  ~ validator: String
  + getValidator(): String
  + builder(): StringInputBuilder<?, ?>
  + validate(String): void
}
class Subflow {
  - inputs: Map<String, Object>
  - labels: Map<String, String>
  - flowId: String
  - wait: Boolean
  - transmitFailed: Boolean
  - inheritLabels: Boolean
  - outputs: Map<String, Object>
  - namespace: String
  - scheduleDate: Property<ZonedDateTime>
  ~ PLUGIN_FLOW_OUTPUTS_ENABLED: String
  - revision: Integer
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getNamespace(): String
  + getFlowId(): String
  + getRevision(): Integer
  + getInputs(): Map<String, Object>
  + getInheritLabels(): Boolean
  - $default$wait(): Boolean
  + getOutputs(): Map<String, Object>
  + getScheduleDate(): Property<ZonedDateTime>
  + getLabels(): Map<String, String>
  - $default$inheritLabels(): Boolean
  - $default$transmitFailed(): Boolean
  + builder(): SubflowBuilder<?, ?>
  + getTransmitFailed(): Boolean
  + toString(): String
  + getWait(): Boolean
  + subflowId(): SubflowId
  + createSubflowExecutionResult(RunContext, TaskRun, Flow, Execution): Optional<SubflowExecutionResult>
  + createSubflowExecutions(RunContext, FlowExecutorInterface, Flow, Execution, TaskRun): List<SubflowExecution<?>>
  + waitForExecution(): boolean
}
class SubflowExecution<T> {
  - parentTask: T
  - execution: Execution
  - parentTaskRun: TaskRun
  + setParentTaskRun(TaskRun): void
  + getParentTaskRun(): TaskRun
  + getParentTask(): T
  + getExecution(): Execution
  + setParentTask(T): void
  + setExecution(Execution): void
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + builder(): SubflowExecutionBuilder<T>
  + toString(): String
}
class SubflowExecutionResult {
  - executionId: String
  - state: Type
  - parentTaskRun: TaskRun
  + setExecutionId(String): void
  + getParentTaskRun(): TaskRun
  + builder(): SubflowExecutionResultBuilder
  + getExecutionId(): String
  + getState(): Type
  + setParentTaskRun(TaskRun): void
  + setState(Type): void
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + toString(): String
}
class SubflowGraphCluster
class SubflowGraphTask {
  + getExecutableTask(): ExecutableTask<?>
  + withRenderedSubflowId(RunContext): SubflowGraphTask
}
class SubflowTest {
  - applicationContext: ApplicationContext
  - runContext: DefaultRunContext
  - LOG: Logger
  - DEFAULT_SUCCESS_STATE: State
  + EXECUTION_ID: String
  ~ shouldNotReturnOutputsForSubflowOutputsDisabled(): void
  ~ shouldReturnOutputsForSubflowOutputsEnabled(): void
  ~ beforeEach(): void
  ~ shouldNotReturnResultForExecutionNotTerminated(): void
  ~ shouldOnlyReturnOutputsFromFlowOutputs(): void
}
class SubmitQueuedCommand {
  - applicationContext: ApplicationContext
  - executionQueue: QueueInterface<Execution>
  - log: Logger
  + call(): Integer
}
class SubstringAfterFilter {
  - argumentNames: List<String>
  + getArgumentNames(): List<String>
  + apply(Object, Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
}
class SubstringAfterLastFilter {
  - argumentNames: List<String>
  + apply(Object, Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
  + getArgumentNames(): List<String>
}
class SubstringBeforeFilter {
  - argumentNames: List<String>
  + apply(Object, Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
  + getArgumentNames(): List<String>
}
class SubstringBeforeLastFilter {
  - argumentNames: List<String>
  + apply(Object, Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
  + getArgumentNames(): List<String>
}
class SubstringFilterTest {
  ~ variableRenderer: VariableRenderer
  ~ substringAfter(): void
  ~ substringBefore(): void
  ~ substringAfterLast(): void
  ~ substringBeforeLast(): void
}
entity SummaryStatistics << record >> {
  - flows: int
  - triggers: int
  + flows(): int
  + triggers(): int
}
class SuperclassTask {
  - someProperty: String
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getSomeProperty(): String
  + toString(): String
  + builder(): SuperclassTaskBuilder<?, ?>
  + run(RunContext): VoidOutput
}
class Switch {
  - value: String
  - cases: Map<String, List<Task>>
  # errors: List<Task>
  - defaults: List<Task>
  + getCases(): Map<String, List<Task>>
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getValue(): String
  + getDefaults(): List<Task>
  + builder(): SwitchBuilder<?, ?>
  + getErrors(): List<Task>
  + toString(): String
  + resolveState(RunContext, Execution, TaskRun): Optional<Type>
  + tasksTree(Execution, TaskRun, List<String>): GraphCluster
  + outputs(RunContext): Output
  + resolveNexts(RunContext, Execution, TaskRun): List<NextTaskRun>
  - rendererValue(RunContext): String
  + childTasks(RunContext, TaskRun): List<ResolvedTask>
  + allChildTasks(): List<Task>
}
annotation SwitchTaskValidation << annotation >> {
  + groups(): Class<?>[]
  + payload(): Class<Payload>[]
  + message(): String
}
class SwitchTaskValidator {
  + isValid(Switch, AnnotationValue<SwitchTaskValidation>, ConstraintValidatorContext): boolean
}
class SwitchTest {
  ~ switchFirst(): void
  ~ switchThird(): void
  ~ switchDefault(): void
  ~ switchSecond(): void
  ~ switchImpossible(): void
}
class SysCommand {
  - log: Logger
  + call(): Integer
}
enum TargetOS << enumeration >> {
  + WINDOWS:
  + AUTO:
  + lineSeparator: String
  + LINUX:
  + values(): TargetOS[]
  + valueOf(String): TargetOS
}
class Task {
  - allowFailure: boolean
  - description: String
  - logLevel: Level
  - workerGroup: WorkerGroup
  # retry: AbstractRetry
  - logToFile: boolean
  # id: String
  # type: String
  # timeout: Duration
  # disabled: Boolean
  + getRetry(): AbstractRetry
  + getId(): String
  + getType(): String
  - $default$logToFile(): boolean
  + getDescription(): String
  + isLogToFile(): boolean
  - $default$disabled(): Boolean
  + getTimeout(): Duration
  + getDisabled(): Boolean
  + getWorkerGroup(): WorkerGroup
  + getLogLevel(): Level
  - $default$allowFailure(): boolean
  + isAllowFailure(): boolean
  + isFlowable(): boolean
  + findById(String): Optional<Task>
  + findById(String, RunContext, TaskRun): Optional<Task>
  + isSendToWorkerTask(): boolean
}
interface TaskCommands << interface >> {
  + getCommands(): List<String>
  + outputDirectoryEnabled(): boolean
  + getTargetOS(): TargetOS
  + relativeWorkingDirectoryFilesPaths(): List<Path>
  + getWorkingDirectory(): Path
  + getContainerImage(): String
  + getAdditionalVars(): Map<String, Object>
  + getEnv(): Map<String, String>
  + getOutputDirectory(): Path
  + getEnableOutputDirectory(): Boolean
  + relativeWorkingDirectoryFilesPaths(boolean): List<Path>
  + getTimeout(): Duration
  + getLogConsumer(): AbstractLogConsumer
}
class TaskException {
  - exitCode: int
  - stdErrSize: int
  - serialVersionUID: long
  - stdOutSize: int
  + getExitCode(): int
  + getStdOutSize(): int
  + getStdErrSize(): int
  + builder(): TaskExceptionBuilder
}
class TaskForExecution {
  # id: String
  # type: String
  # subflowId: SubflowId
  # tasks: List<TaskForExecution>
  # inputs: List<Input<?>>
  + getId(): String
  + getType(): String
  + getTasks(): List<TaskForExecution>
  + getInputs(): List<Input<?>>
  + getSubflowId(): SubflowId
  + builder(): TaskForExecutionBuilder<?, ?>
  + toBuilder(): TaskForExecutionBuilder<?, ?>
  + of(TaskInterface): TaskForExecution
}
class TaskGlobalDefaultConfiguration {
  ~ defaults: List<PluginDefault>
  + getDefaults(): List<PluginDefault>
}
class TaskGlobalDefaultConfigurationTest {
  + keepCase(): void
}
interface TaskInterface << interface >> {
  + getId(): String
  + getType(): String
}
class TaskResult {
  - start: Instant
  - state: State
  - duration: Duration
  + getState(): State
  + getStart(): Instant
  + getDuration(): Duration
  + equals(Object): boolean
  + hashCode(): int
  + toString(): String
}
class TaskRun {
  ~ id: String
  ~ executionId: String
  ~ outputs: Map<String, Object>
  ~ value: String
  ~ tenantId: String
  ~ taskId: String
  ~ parentTaskRunId: String
  ~ iteration: Integer
  ~ namespace: String
  ~ flowId: String
  ~ state: State
  ~ attempts: List<TaskRunAttempt>
  + lastAttempt(): TaskRunAttempt
  + hashCode(): int
  + equals(Object): boolean
  + getTaskId(): String
  + getAttempts(): List<TaskRunAttempt>
  + withValue(String): TaskRun
  + withOutputs(Map<String, Object>): TaskRun
  # canEqual(Object): boolean
  + getTenantId(): String
  + getState(): State
  + getIteration(): Integer
  + getId(): String
  + withAttempts(List<TaskRunAttempt>): TaskRun
  + getOutputs(): Map<String, Object>
  + withIteration(Integer): TaskRun
  + getExecutionId(): String
  + getNamespace(): String
  + toBuilder(): TaskRunBuilder
  + getFlowId(): String
  + getParentTaskRunId(): String
  + toString(): String
  + builder(): TaskRunBuilder
  + getValue(): String
  + of(Execution, ResolvedTask): TaskRun
  + forChildExecution(Map<String, String>, String, State): TaskRun
  + fail(): TaskRun
  + attemptNumber(): int
  + incrementIteration(): TaskRun
  + toString(boolean): String
  + replaceState(State): TaskRun
  + nextRetryDate(AbstractRetry): Instant
  + withState(Type): TaskRun
  + toStringState(): String
  + setItems(String): void
  + shouldBeRetried(AbstractRetry): boolean
  + resetAttempts(): TaskRun
  + onRunningResend(): TaskRun
  + isSame(TaskRun): boolean
  + nextRetryDate(AbstractRetry, Execution): Instant
}
class TaskRunAttempt {
  - logFile: URI
  - state: State
  + withState(Type): TaskRunAttempt
  + builder(): TaskRunAttemptBuilder
  + getState(): State
  + getLogFile(): URI
  + equals(Object): boolean
  + hashCode(): int
  + toString(): String
  + withLogFile(URI): TaskRunAttempt
  + setMetrics(List<AbstractMetricEntry<?>>): void
}
class TaskRunController {
  # executionRepository: ExecutionRepositoryInterface
  - tenantService: TenantService
  + findTaskRun(int, int, List<String>, String, String, String, ZonedDateTime, ZonedDateTime, List<Type>, List<String>, String, ChildFilter): PagedResults<TaskRun>
  + maxTaskRunSetting(): Integer
}
class TaskRunControllerTest {
  - client: ReactorHttpClient
  ~ maxTaskRunSetting(): void
  ~ search(): void
}
class TaskRunTest {
  ~ onRunningResendNoAttempts(): void
  ~ onRunningResendTerminated(): void
  ~ onRunningResendRunning(): void
}
class TaskRunner {
  # type: String
  - killable: AtomicReference<Runnable>
  - isKilled: AtomicBoolean
  - additionalVars: Map<String, Object>
  - env: Map<String, String>
  + getType(): String
  - $default$killable(): AtomicReference<Runnable>
  - $default$isKilled(): AtomicBoolean
  # getIsKilled(): AtomicBoolean
  + kill(): void
  + run(RunContext, TaskCommands, List<String>): RunnerResult
  + additionalVars(RunContext, TaskCommands): Map<String, Object>
  + toAbsolutePath(RunContext, TaskCommands, String, TargetOS): String
  # runnerAdditionalVars(RunContext, TaskCommands): Map<String, Object>
  + env(RunContext, TaskCommands): Map<String, String>
  # runnerEnv(RunContext, TaskCommands): Map<String, String>
  # onKill(Runnable): void
}
class TaskRunnerTest {
  + ADDITIONAL_VAR_KEY: String
  + ADDITIONAL_ENV_KEY: String
  ~ applicationContext: ApplicationContext
  ~ runContextFactory: RunContextFactory
  ~ additionalVarsAndEnv(): void
}
class TaskWithAlias {
  - message: String
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getMessage(): String
  + toString(): String
  + builder(): TaskWithAliasBuilder<?, ?>
  + run(RunContext): VoidOutput
}
class TaskWithAllowFailureTest {
  - storageInterface: StorageInterface
  - flowIO: FlowInputOutput
  ~ executableTask_ForEachItem(): void
  ~ flowableTask(): void
  - storageUpload(): URI
  - content(): List<String>
  ~ runnableTask(): void
  ~ executableTask_Flow(): void
}
class Template {
  - YAML_MAPPER: ObjectMapper
  - errors: List<Task>
  ~ description: String
  - tenantId: String
  - tasks: List<Task>
  - id: String
  - deleted: boolean
  - namespace: String
  + equals(Object): boolean
  + toBuilder(): TemplateBuilder<?, ?>
  + isDeleted(): boolean
  - $default$deleted(): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getTenantId(): String
  + toString(): String
  + getId(): String
  + getNamespace(): String
  + getDescription(): String
  + getTasks(): List<Task>
  + builder(): TemplateBuilder<?, ?>
  + getErrors(): List<Task>
  + validateUpdate(Template): Optional<ConstraintViolationException>
  + uid(String, String, String): String
  + toDeleted(): Template
  + generateSource(): String
  + uid(): String
}
class Template {
  - namespace: String
  - tenantId: String
  - log: Logger
  - templateId: String
  - args: Map<String, String>
  # errors: List<Task>
  # canEqual(Object): boolean
  + equals(Object): boolean
  + hashCode(): int
  + getErrors(): List<Task>
  + getNamespace(): String
  + setTenantId(String): void
  + builder(): TemplateBuilder<?, ?>
  + getTemplateId(): String
  + getTenantId(): String
  + getArgs(): Map<String, String>
  + toString(): String
  + childTasks(RunContext, TaskRun): List<ResolvedTask>
  + injectTemplate(Flow, Execution, TriFunction<String, String, String, Template>): Flow
  # findTemplate(ApplicationContext): Template
  + resolveNexts(RunContext, Execution, TaskRun): List<NextTaskRun>
  + allChildTasks(): List<Task>
  + outputs(RunContext): Output
  + tasksTree(Execution, TaskRun, List<String>): GraphCluster
}
class TemplateCommand {
  - log: Logger
  + call(): Integer
}
class TemplateController {
  - templateRepository: TemplateRepositoryInterface
  - modelValidator: ModelValidator
  - tenantService: TenantService
  + index(String, String): Template
  + exportByIds(List<IdWithNamespace>): HttpResponse<byte[]>
  - updateCompleteNamespace(String, List<Template>, Boolean): List<Template>
  - zipTemplates(List<Template>): byte[]
  + deleteByQuery(String, String): HttpResponse<BulkResponse>
  + updateNamespace(String, List<Template>, Boolean): List<Template>
  # importTemplate(Template): void
  + find(int, int, List<String>, String, String): PagedResults<Template>
  + deleteByIds(List<IdWithNamespace>): HttpResponse<BulkResponse>
  + importTemplates(CompletedFileUpload): HttpResponse<Void>
  + validateTemplates(String): List<ValidateConstraintViolation>
  + exportByQuery(String, String): HttpResponse<byte[]>
  + delete(String, String): HttpResponse<Void>
  + listDistinctNamespace(): List<String>
  + create(Template): HttpResponse<Template>
  + update(String, String, Template): HttpResponse<Template>
}
class TemplateControllerTest {
  ~ client: ReactorHttpClient
  ~ templateRepository: AbstractJdbcTemplateRepository
  - postTemplate(String, String): Template
  ~ importTemplatesWithZip(): void
  ~ updateTemplate(): void
  ~ exportByIds(): void
  # init(): void
  ~ listDistinctNamespace(): void
  ~ deleteTemplatesByIds(): void
  - createTemplate(): Template
  ~ findAll(): void
  - createTemplate(String, String): Template
  ~ create(): void
  ~ importTemplatesWithYaml(): void
  ~ idNotFound(): void
  ~ deleteTemplatesByQuery(): void
  ~ deleteTemplate(): void
  ~ exportByQuery(): void
}
annotation TemplateEnabled << annotation >>
class TemplateExportCommand {
  - log: Logger
  + namespace: String
  - DEFAULT_FILE_NAME: String
  - applicationContext: ApplicationContext
  + directory: Path
  + call(): Integer
}
class TemplateExportCommandTest {
  ~ run(): void
}
class TemplateNamespaceCommand {
  - log: Logger
  + call(): Integer
}
class TemplateNamespaceCommandTest {
  ~ runWithNoParam(): void
}
class TemplateNamespaceUpdateCommand {
  + yamlFlowParser: YamlFlowParser
  - log: Logger
  + call(): Integer
}
class TemplateNamespaceUpdateCommandTest {
  ~ runNoDelete(): void
  ~ run(): void
  ~ invalid(): void
}
interface TemplateRepositoryInterface << interface >> {
  + create(Template): Template
  + update(Template, Template): Template
  + findAllForAllTenants(): List<Template>
  + delete(Template): void
  + findById(String, String, String): Optional<Template>
  + find(String?, String?, String?): List<Template>
  + find(Pageable, String?, String?, String?): ArrayListTotal<Template>
  + findByNamespace(String, String): List<Template>
  + findAll(String): List<Template>
  + findDistinctNamespace(String): List<String>
}
class TemplateSource {
  ~ exception: String
  ~ source: String
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getSource(): String
  + getException(): String
  + toString(): String
  + builder(): TemplateSourceBuilder<?, ?>
}
class TemplateTest {
  # templateRepository: TemplateRepositoryInterface
  # logQueue: QueueInterface<LogEntry>
  - flowIO: FlowInputOutput
  + TEMPLATE_1: Template
  + withTemplate(RunnerUtils, TemplateRepositoryInterface, LocalFlowRepositoryLoader, QueueInterface<LogEntry>, FlowInputOutput): void
  ~ withTemplate(): void
  + withFailedTemplate(RunnerUtils, TemplateRepositoryInterface, LocalFlowRepositoryLoader, QueueInterface<LogEntry>): void
  ~ withFailedTemplate(): void
}
class TemplateValidateCommand {
  - modelValidator: ModelValidator
  - yamlFlowParser: YamlFlowParser
  + call(): Integer
}
class TemplateValidateCommandTest {
  ~ runLocal(): void
  ~ runServer(): void
}
class TemplateValidateCommandTest {
  ~ runServer(): void
  ~ runLocal(): void
}
class TemplatedTask {
  - spec: String
  - OBJECT_MAPPER: ObjectMapper
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getSpec(): String
  + toString(): String
  + builder(): TemplatedTaskBuilder<?, ?>
  + run(RunContext): Output
}
class TemplatedTaskTest {
  - runContextFactory: RunContextFactory
  ~ templatedType(): void
  ~ templatedFlowable(): void
  ~ templatedTemplated(): void
}
interface TenantInterface << interface >> {
  + getTenantId(): String
}
class TenantSerializer {
  - serialVersionUID: long
  + changeProperties(SerializationConfig, BeanDescription, List<BeanPropertyWriter>): List<BeanPropertyWriter>
}
class TenantService {
  + resolveTenant(): String
}
class TenantServiceTest {
  - tenantService: TenantService
  ~ test(): void
}
class TestMethodScopedWorker {
  + close(): void
}
class TestThreadUncaughtExceptionHandlers {
  - log: Logger
  + uncaughtException(Thread, Throwable): void
}
class TestWorkingDir {
  - id: String
  - isCleaned: boolean
  - delegate: WorkingDir
  - allCreatedTempFiles: List<Path>
  - allCreatedFiles: List<Path>
  + createFile(String, InputStream): Path
  + cleanup(): void
  - captureCreateTempFileAndGet(Path): Path
  + path(): Path
  + createTempFile(byte[]): Path
  + putFile(Path, InputStream): Path
  + createTempFile(String): Path
  + createFile(String, byte[]): Path
  + resolve(Path): Path
  + getAllCreatedTempFiles(): List<Path>
  + create(): TestWorkingDir
  + id(): String
  + path(boolean): Path
  + createTempFile(byte[], String): Path
  + findAllFilesMatching(List<String>): List<Path>
  + createTempFile(): Path
  + getAllCreatedFilesAndTempFiles(): List<Path>
  - captureCreateFileAndGet(Path): Path
  + create(String): TestWorkingDir
  + getAllCreatedFiles(): List<Path>
  + createFile(String): Path
  + isCleaned(): boolean
}
class TestsUtils {
  - mapper: ObjectMapper
  + mockExecution(Flow, Map<String, Object>): Execution
  + receive(QueueInterface<T>, String, Class<?>, Consumer<Either<T, DeserializationException>>, Duration): Flux<T>
  + map(String, Class<T>): T
  + receive(QueueInterface<T>, Class<?>, Consumer<Either<T, DeserializationException>>): Flux<T>
  + loads(LocalFlowRepositoryLoader): void
  + mockFlow(): Flow
  + loads(LocalFlowRepositoryLoader, URL): void
  - mockExecution(StackTraceElement, Flow, Map<String, Object>, Map<String, Object>): Execution
  + mockTaskRun(Flow, Execution, Task): TaskRun
  - mockFlow(StackTraceElement): Flow
  - mockTaskRun(StackTraceElement, Execution, Task): TaskRun
  + mockTrigger(RunContextFactory, AbstractTrigger): Entry<ConditionContext, Trigger>
  + awaitLogs(List<LogEntry>, Integer): List<LogEntry>
  + receive(QueueInterface<T>, String, Class<?>, Consumer<Either<T, DeserializationException>>): Flux<T>
  + receive(QueueInterface<T>, String, Consumer<Either<T, DeserializationException>>): Flux<T>
  + awaitLogs(List<LogEntry>, Predicate<LogEntry>, Integer): List<LogEntry>
  + awaitLogs(List<LogEntry>, Predicate<LogEntry>, Predicate<Integer>): List<LogEntry>
  + mockExecution(Flow, Map<String, Object>, Map<String, Object>): Execution
  + filterLogs(List<LogEntry>, TaskRun): List<LogEntry>
  + mockRunContext(RunContextFactory, Task, Map<String, Object>): RunContext
  + receive(QueueInterface<T>): Flux<T>
  + awaitLog(List<LogEntry>, Predicate<LogEntry>): LogEntry?
  + receive(QueueInterface<T>, Consumer<Either<T, DeserializationException>>): Flux<T>
}
class ThreadMainFactoryBuilder {
  - uncaughtExceptionHandler: UncaughtExceptionHandler
  + build(String): ThreadFactory
}
class ThreadUncaughtExceptionHandlers {
  - runtime: Runtime
  - log: Logger
  - applicationContext: ApplicationContext
  + uncaughtException(Thread, Throwable): void
}
class TimeBetweenCondition {
  - after: OffsetTime
  - before: OffsetTime
  - date: String
  + getDate(): String
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getAfter(): OffsetTime
  + getBefore(): OffsetTime
  + toString(): String
  - $default$date(): String
  + builder(): TimeBetweenConditionBuilder<?, ?>
  + test(ConditionContext): boolean
}
class TimeBetweenConditionTest {
  ~ conditionService: ConditionService
  ~ valid(String, OffsetTime, OffsetTime, boolean): void
  ~ source(): Stream<Arguments>
}
class TimeInput {
  ~ after: LocalTime
  ~ before: LocalTime
  + validate(LocalTime): void
  + getAfter(): LocalTime
  + getBefore(): LocalTime
  + builder(): TimeInputBuilder<?, ?>
}
class TimeoutExceededException {
  - serialVersionUID: long
}
class TimeoutTest {
  ~ pluginDefaultService: PluginDefaultService
  ~ flowRepository: FlowRepositoryInterface
  - workerTaskLogQueue: QueueInterface<LogEntry>
  ~ timeout(): void
}
class Timer {
  + TYPE: String
  - type: String
  - value: Duration
  + increment(Duration): void
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getType(): String
  + getValue(): Duration
  + toString(): String
  + register(MetricRegistry, String, Map<String, String>): void
  + of(String, Duration, String[]): Timer
}
class TimestampFilter {
  + apply(Object, Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
  + getArgumentNames(): List<String>
}
class TimestampMicroFilter {
  + getArgumentNames(): List<String>
  + apply(Object, Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
}
class TimestampNanoFilter {
  + getArgumentNames(): List<String>
  + apply(Object, Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
}
annotation TimezoneId << annotation >> {
  + message(): String
  + groups(): Class<?>[]
  + payload(): Class<Payload>[]
}
class TimezoneIdTest {
  - modelValidator: ModelValidator
  ~ inputValidation(): void
}
class TimezoneIdValidator {
  + isValid(String, AnnotationValue<TimezoneId>, ConstraintValidatorContext): boolean
}
class ToIonFilter {
  - MAPPER: ObjectMapper
  + apply(Object, Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
  + getArgumentNames(): List<String>
}
class ToIonFilterTest {
  ~ variableRenderer: VariableRenderer
  ~ exception(): void
  ~ toIonFilter(): void
}
class ToJsonFilter {
  - MAPPER: ObjectMapper
  + apply(Object, Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
  + getArgumentNames(): List<String>
}
class ToJsonFilterTest {
  ~ variableRenderer: VariableRenderer
  ~ exception(): void
  ~ jsonFilter(): void
  ~ toJsonFilter(): void
}
class Toggle {
  - trigger: String
  - enabled: Boolean
  - flowId: String
  - namespace: String
  + hashCode(): int
  + equals(Object): boolean
  # canEqual(Object): boolean
  + getFlowId(): String
  + builder(): ToggleBuilder<?, ?>
  + getNamespace(): String
  + getTrigger(): String
  + getEnabled(): Boolean
  + toString(): String
  - $default$enabled(): Boolean
  + run(RunContext): VoidOutput
}
class ToggleTest {
  - triggerRepository: TriggerRepositoryInterface
  - scheduler: AbstractScheduler
  - triggerQueue: QueueInterface<Trigger>
  ~ toggle(): void
}
class Trigger {
  - sslOptions: SslOptions
  - headers: Map<CharSequence, CharSequence>
  - options: RequestOptions
  - uri: String
  - method: HttpMethod
  - interval: Duration
  - encryptBody: boolean
  - responseCondition: String
  - formData: Map<String, Object>
  - body: String
  - contentType: String
  + getMethod(): HttpMethod
  + getSslOptions(): SslOptions
  + getOptions(): RequestOptions
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + toString(): String
  - $default$method(): HttpMethod
  + getContentType(): String
  + getInterval(): Duration
  - $default$interval(): Duration
  + getResponseCondition(): String
  - $default$responseCondition(): String
  + getUri(): String
  + isEncryptBody(): boolean
  - $default$encryptBody(): boolean
  + getBody(): String
  + getFormData(): Map<String, Object>
  + getHeaders(): Map<CharSequence, CharSequence>
  + builder(): TriggerBuilder<?, ?>
  + evaluate(ConditionContext, TriggerContext): Optional<Execution>
}
class Trigger {
  - workerId: String
  - executionCurrentState: Type
  - executionId: String
  - updatedDate: Instant
  - evaluateRunningDate: ZonedDateTime
  + getExecutionId(): String
  + equals(Object): boolean
  + toBuilder(): TriggerBuilder<?, ?>
  # canEqual(Object): boolean
  + setWorkerId(String): void
  + hashCode(): int
  + getExecutionCurrentState(): Type
  + toString(): String
  + getUpdatedDate(): Instant
  + getEvaluateRunningDate(): ZonedDateTime
  + getWorkerId(): String
  + of(Trigger, ZonedDateTime): Trigger
  + of(Flow, AbstractTrigger, ConditionContext, Optional<Trigger>): Trigger
  + uid(Execution): String
  + flowUid(): String
  + of(TriggerContext, ZonedDateTime): Trigger
  + resetExecution(Type, ZonedDateTime): Trigger
  + of(TriggerContext, Execution, ZonedDateTime): Trigger
  + update(Trigger, Trigger, ZonedDateTime): Trigger
  + uid(): String
  + unlock(): Trigger
  + uid(Flow, AbstractTrigger): String
  + uid(Trigger): String
  + builder(): TriggerBuilder<?, ?>
  - fromContext(TriggerContext): TriggerBuilder<?, ?>
  + of(Execution, Trigger): Trigger
  + of(Flow, AbstractTrigger): Trigger
  + fromEvaluateFailed(TriggerContext, ZonedDateTime): Trigger
  + resetExecution(Type): Trigger
  + initBackfill(Trigger): Trigger
  + checkBackfill(): Trigger
}
class TriggerContext {
  - flowId: String
  - tenantId: String
  - namespace: String
  - triggerId: String
  - disabled: Boolean
  - backfill: Backfill
  - stopAfter: List<Type>
  - date: ZonedDateTime
  - nextExecutionDate: ZonedDateTime
  + getNextExecutionDate(): ZonedDateTime
  + getTenantId(): String
  + getNamespace(): String
  + getFlowId(): String
  + getTriggerId(): String
  + getDate(): ZonedDateTime
  + getBackfill(): Backfill
  + toBuilder(): TriggerContextBuilder<?, ?>
  + getStopAfter(): List<Type>
  + toString(): String
  + getDisabled(): Boolean
  + builder(): TriggerContextBuilder<?, ?>
  + uid(): String
  + uid(TriggerContext): String
}
class TriggerController {
  - conditionService: ConditionService
  - tenantService: TenantService
  - executionKilledQueue: QueueInterface<ExecutionKilled>
  - triggerRepository: TriggerRepositoryInterface
  - log: Logger
  - triggerQueue: QueueInterface<Trigger>
  - runContextFactory: RunContextFactory
  - flowRepository: FlowRepositoryInterface
  + find(int, int, List<String>, String, String, String): PagedResults<Trigger>
  + unlockByQuery(String, String): MutableHttpResponse<?>
  + pauseBackfill(Trigger): HttpResponse<Trigger>
  + unpauseBackfill(Trigger): HttpResponse<Trigger>
  + setDisabledByIds(SetDisabledRequest): MutableHttpResponse<?>
  + backfillsAction(List<Trigger>, BACKFILL_ACTION): int
  + setDisabled(Trigger, Boolean): void
  + unlock(String, String, String): HttpResponse<Trigger>
  + unlockByIds(List<Trigger>): MutableHttpResponse<?>
  + restart(Trigger): void
  + pauseBackfillByQuery(String, String): MutableHttpResponse<?>
  + deleteBackfill(Trigger): HttpResponse<Trigger>
  + search(int, int, List<String>, String, String, String, String): PagedResults<Triggers>
  + update(Trigger): HttpResponse<Trigger>
  + setDisabledByQuery(String, String, Boolean): MutableHttpResponse<?>
  + setBackfillPaused(Trigger, Boolean): HttpResponse<Trigger>
  + restart(String, String, String): HttpResponse<?>
  + unpauseBackfillByIds(List<Trigger>): MutableHttpResponse<?>
  + deleteBackfillByIds(List<Trigger>): MutableHttpResponse<?>
  + pauseBackfillByIds(List<Trigger>): MutableHttpResponse<?>
  + unpauseBackfillByQuery(String, String): MutableHttpResponse<?>
  + deleteBackfillByQuery(String, String): MutableHttpResponse<?>
}
class TriggerControllerTest {
  - jdbcTestUtils: JdbcTestUtils
  ~ client: ReactorHttpClient
  ~ jdbcFlowRepository: AbstractJdbcFlowRepository
  ~ jdbcTriggerRepository: AbstractJdbcTriggerRepository
  ~ unlockByQuery(): void
  ~ nextExecutionDate(): void
  ~ disableByQuery(): void
  ~ restart(): void
  ~ unlockByTriggers(): void
  ~ enableByQuery(): void
  - generateFlow(String): Flow
  ~ unlock(): void
  ~ disableByTriggers(): void
  ~ enableByTriggers(): void
  # setup(): void
  ~ search(): void
  ~ updated(): void
}
interface TriggerInterface << interface >> {
  + getId(): String
  + getType(): String
}
interface TriggerOutput<T> << interface >>
interface TriggerRepositoryInterface << interface >> {
  + count(String?): int
  + lock(String, Function<Trigger, Trigger>): Trigger
  + save(Trigger): Trigger
  + update(Trigger): Trigger
  + findAllForAllTenants(): List<Trigger>
  + delete(Trigger): void
  + findAll(String): List<Trigger>
  + findLast(TriggerContext): Optional<Trigger>
  + countForNamespace(String?, String?): int
  + find(String, String, String): Flux<Trigger>
  + find(Pageable, String, String, String, String, String): ArrayListTotal<Trigger>
  + findByExecution(Execution): Optional<Trigger>
  + sortMapping(): Function<String, String>
}
class TriggerService {
  + generateExecution(AbstractTrigger, ConditionContext, TriggerContext, Output): Execution
  + generateScheduledExecution(AbstractTrigger, ConditionContext, TriggerContext, List<Label>, Map<String, Object>, Map<String, Object>, Optional<ZonedDateTime>): Execution
  + generateExecution(AbstractTrigger, ConditionContext, TriggerContext, Map<String, Object>): Execution
  + generateRealtimeExecution(AbstractTrigger, ConditionContext, TriggerContext, Output): Execution
  - generateExecution(String, AbstractTrigger, TriggerContext, ExecutionTrigger, Integer): Execution
}
class TriggerTest {
  - executionQueue: QueueInterface<Execution>
  - applicationContext: ApplicationContext
  - triggerState: SchedulerTriggerStateInterface
  - repositoryLoader: LocalFlowRepositoryLoader
  - flowListenersService: FlowListenersInterface
  ~ trigger_EncryptedBody(): void
  ~ trigger(): void
}
class TriggerWithAlias {
  + builder(): TriggerWithAliasBuilder<?, ?>
  + getInterval(): Duration
  + evaluate(ConditionContext, TriggerContext): Optional<Execution>
}
class TruthUtils {
  - FALSE_VALUES: List<String>
  + isTruthy(String): boolean
}
enum Type << enumeration >> {
  + DATETIME:
  + ARRAY:
  + FILE:
  + URI:
  + YAML:
  + TIME:
  + FLOAT:
  + SELECT:
  + DATE:
  + BOOLEAN:
  + MULTISELECT:
  + STRING:
  + INT:
  + JSON:
  + ENUM:
  - clsName: String
  + DURATION:
  + SECRET:
  + cls(): Class<Input<?>>
  + values(): Type[]
  + valueOf(String): Type
}
class TypedObjectWriter {
  - current: Object
  + flush(): void
  - throwIllegalAddition(Object, Class<T>): void
  + writeSpecialized(long): void
  + writeSpecialized(double): void
  + close(): void
  + writeSpecialized(String): void
  + write(char[], int, int): void
  + writeSpecialized(int): void
  + writeSpecialized(byte): void
  + output(): Object
  + writeSpecialized(short): void
  + writeSpecialized(float): void
  + writeSpecialized(char): void
  + write(Object): void
  - ofSameTypeOrThrow(Object, Class<T>): T?
}
class TypedObjectWriterTest {
  ~ writeFloats(): void
  ~ writeChars(): void
  ~ writeStrings(): void
  ~ writeDoubles(): void
  ~ writeObjects(): void
  ~ writeInts(): void
  ~ writeLongs(): void
  ~ invalidAddition(): void
  ~ writeShorts(): void
  ~ writeBytes(): void
}
class URIInput {
  + validate(String): void
  + builder(): URIInputBuilder<?, ?>
}
class UndefinedCoalescingExpression {
  + evaluate(PebbleTemplateImpl, EvaluationContextImpl): Object
  + toString(): String
}
class UndefinedCoalescingExpressionTest {
  ~ variableRenderer: VariableRenderer
  ~ nullOrUndefined(): void
}
class UploadFiles {
  - conflict: Conflicts
  - filesMap: Object
  - files: List<String>
  - destination: String
  - namespace: String
  + getNamespace(): String
  + getFiles(): List<String>
  + getFilesMap(): Object
  + toBuilder(): UploadFilesBuilder<?, ?>
  + getDestination(): String
  + getConflict(): Conflicts
  - $default$destination(): String
  - $default$conflict(): Conflicts
  + builder(): UploadFilesBuilder<?, ?>
  - uploadFiles(RunContext, List<String>, Namespace, String): void
  + run(RunContext): Output
  - uploadFilesMap(RunContext, Map<String, Object>, Namespace, String): void
}
class UploadFilesTest {
  ~ storageInterface: StorageInterface
  ~ runContextFactory: RunContextFactory
  ~ shouldPutFileFromRegex(): void
  ~ shouldThrowExceptionGivenAlreadyExistingFileWhenConflictError(): void
  ~ shouldPutFileGivenAlreadyExistingFileWhenConflictSkip(): void
  - addToStorage(String): URI
  ~ shouldPutFileGivenAlreadyExistingFileWhenConflictOverwrite(): void
}
class UriProvider {
  ~ uri: String
  + rootUrl(): URI
  + flowUrl(Execution): URI
  + resetPasswordUrl(String): URI
  - build(String): URI?
  + executionUrl(Execution): URI
  + flowUrl(Flow): URI
}
class UriProviderTest {
  ~ uriProvider: UriProvider
  ~ root(): void
  ~ flowUrl(): void
  ~ tenant(): void
  ~ executionUrl(): void
}
class UrlDecodeFilter {
  ~ variableRenderer: VariableRenderer
  ~ urldecode(): void
}
class UrlDecoderFilter {
  + getArgumentNames(): List<String>
  + apply(Object, Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
}
class Usage {
  - instanceUuid: String
  - startUuid: String
  - plugins: List<PluginUsage>
  - serverType: ServerType
  - uuid: String
  - version: String
  - configurations: ConfigurationUsage
  - executions: ExecutionUsage
  - uri: String
  - zoneId: ZoneId
  - host: HostUsage
  - flows: FlowUsage
  - startTime: Instant
  - environments: Set<String>
  + getStartUuid(): String
  + getUuid(): String
  + getInstanceUuid(): String
  + getPlugins(): List<PluginUsage>
  + getServerType(): ServerType
  + getVersion(): String
  + getZoneId(): ZoneId
  + toBuilder(): UsageBuilder<?, ?>
  + getUri(): String
  + getExecutions(): ExecutionUsage
  + getEnvironments(): Set<String>
  + builder(): UsageBuilder<?, ?>
  + getFlows(): FlowUsage
  + getConfigurations(): ConfigurationUsage
  + getStartTime(): Instant
  + getHost(): HostUsage
}
class ValidateConstraintViolation {
  - log: Logger
  - index: int
  - deprecationPaths: List<String>
  - flow: String
  - outdated: boolean
  - constraints: String
  - namespace: String
  - warnings: List<String>
  + getFlow(): String
  + getNamespace(): String
  + getIndex(): int
  + getConstraints(): String
  + builder(): ValidateConstraintViolationBuilder<?, ?>
  + isOutdated(): boolean
  + getDeprecationPaths(): List<String>
  + toBuilder(): ValidateConstraintViolationBuilder<?, ?>
  + getWarnings(): List<String>
  + toString(): String
  + getFlowId(): String
  - getPath(Path): String
  + getIdentity(): String
  + getIdentity(Path): String
}
class ValuesFilter {
  + getArgumentNames(): List<String>
  + apply(Object, Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
}
class ValuesFilterTest {
  ~ variableRenderer: VariableRenderer
  ~ map(): void
}
class VariableRenderer {
  + MAX_RENDERING_AMOUNT: int
  - RAW_PATTERN: Pattern
  - pebbleEngine: PebbleEngine
  - variableConfiguration: VariableConfiguration
  + render(String, Map<String, Object>, boolean): String
  + renderObject(Object, Map<String, Object>, boolean): Optional<Object>
  # alternativeRender(Exception, String, Map<String, Object>): String
  + renderList(List<Object>, Map<String, Object>, boolean): List<Object>
  + render(Set<String>, Map<String, Object>): Set<String>
  + renderObject(Object, Map<String, Object>): Optional<Object>
  + properPebbleException(PebbleException): IllegalVariableEvaluationException
  - replaceRawTags(Matcher, Map<String, String>): String
  + render(Map<String, Object>, Map<String, Object>, boolean): Map<String, Object>
  + render(List<String>, Map<String, Object>, boolean): List<String>
  + render(Map<String, Object>, Map<String, Object>): Map<String, Object>
  + renderRecursively(Object, Map<String, Object>, boolean): Object
  - renderRecursively(int, Object, Map<String, Object>, boolean): Object
  + renderOnce(Object, Map<String, Object>, boolean): Object
  + render(List<String>, Map<String, Object>): List<String>
  - putBackRawTags(Map<String, String>, String): String
  + renderTyped(String, Map<String, Object>): Object
  + render(Object, Map<String, Object>, boolean, boolean): Object
  + render(Set<String>, Map<String, Object>, boolean): Set<String>
  + render(String, Map<String, Object>): String
  + renderList(List<Object>, Map<String, Object>): List<Object>
}
class VariableRendererTest {
  ~ applicationContext: ApplicationContext
  ~ variableConfiguration: VariableConfiguration
  ~ variableRenderer: VariableRenderer
  ~ shouldRenderUsingAlternativeRendering(): void
  ~ shouldKeepKeyOrderWhenRenderingMap(): void
}
class VariablesTest {
  ~ workerTaskLogQueue: QueueInterface<LogEntry>
  ~ recursiveVars(): void
  ~ invalidVars(): void
  ~ failedFirst(): void
}
class VersionEndpoint {
  - serverType: String
  - VERSION_SUFFIX: String
  - version: VersionProvider
  + DEFAULT_SENSITIVE: boolean
  + NAME: String
  + version(): Publisher<ServerInfo>
  # versionSuffix(): String
}
class VersionProvider {
  - versionProvider: VersionProvider
  + getVersion(): String[]
}
class VersionProvider {
  - environment: Environment
  - date: ZonedDateTime
  - version: String
  - revision: String
  + getVersion(): String
  + getRevision(): String
  + getDate(): ZonedDateTime
  - loadRevision(Optional<PropertySource>): String
  - loadTime(Optional<PropertySource>): ZonedDateTime
  - loadVersion(Optional<PropertySource>, Optional<PropertySource>): String
  - getVersion(Object): Optional<String>
  + start(): void
}
class VoidOutput
class VueStaticResourceResolver {
  - uiResourceLoader: List<ResourceLoader>
  + resolve(String): Optional<URL>
}
class WaitFor {
  - condition: String
  - failOnMaxReached: Boolean
  - INITIAL_LOOP_VALUE: int
  - tasks: List<Task>
  - checkFrequency: CheckFrequency
  # errors: List<Task>
  + equals(Object): boolean
  # canEqual(Object): boolean
  - $default$failOnMaxReached(): Boolean
  + hashCode(): int
  + getErrors(): List<Task>
  + getTasks(): List<Task>
  - $default$checkFrequency(): CheckFrequency
  + getCondition(): String
  + getFailOnMaxReached(): Boolean
  + getCheckFrequency(): CheckFrequency
  + builder(): WaitForBuilder<?, ?>
  + toString(): String
  + childTaskRunExecuted(Execution, TaskRun): boolean
  + allChildTasks(): List<Task>
  - reachedMaximums(RunContext, Execution, TaskRun, Boolean): boolean
  + childTasks(RunContext, TaskRun): List<ResolvedTask>
  + nextExecutionDate(RunContext, Execution, TaskRun): Instant
  + tasksTree(Execution, TaskRun, List<String>): AbstractGraph
  + resolveNexts(RunContext, Execution, TaskRun): List<NextTaskRun>
  + resolveState(RunContext, Execution, TaskRun): Optional<Type>
  + outputs(RunContext): Output
  + outputs(TaskRun): Output
}
class WaitForCaseTest {
  ~ flowRepository: FlowRepositoryInterface
  # runnerUtils: RunnerUtils
  + waitforMultipleTasksFailed(): void
  + waitfor(): void
  + waitforMaxDuration(): void
  + waitforNoSuccess(): void
  + waitforMultipleTasks(): void
  + waitforMaxIterations(): void
}
class WebServerCommand {
  ~ tutorialsDisabled: boolean
  - applicationContext: ApplicationContext
  - log: Logger
  + call(): Integer
  + isFlowAutoLoadEnabled(): boolean
  + propertiesOverrides(): Map<String, Object>
}
annotation WebServerEnabled << annotation >>
class Webhook {
  - key: String
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getKey(): String
  + toString(): String
  + builder(): WebhookBuilder<?, ?>
  - tryArray(ObjectMapper, String): Optional<Object>
  + evaluate(HttpRequest<String>, Flow): Optional<Execution>
  - tryMap(ObjectMapper, String): Optional<Object>
}
class WebhookTest {
  - modelValidator: ModelValidator
  ~ webhookValidation(): void
}
annotation WebhookValidation << annotation >> {
  + groups(): Class<?>[]
  + payload(): Class<Payload>[]
  + message(): String
}
class WebhookValidator {
  + isValid(Webhook, AnnotationValue<WebhookValidation>, ConstraintValidatorContext): boolean
}
class WebserverService {
  - shutdown: AtomicBoolean
  - eventPublisher: ApplicationEventPublisher<ServiceStateChangeEvent>
  - id: String
  - state: AtomicReference<ServiceState>
  + getState(): ServiceState
  + onServerStartup(ServerStartupEvent): void
  - setState(ServiceState): void
  + getType(): ServiceType
  + close(): void
  + getId(): String
  + onServeShutdown(ServerShutdownEvent): void
  + postConstruct(): void
}
class WeekendCondition {
  - date: String
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + getDate(): String
  + toString(): String
  - $default$date(): String
  + builder(): WeekendConditionBuilder<?, ?>
  + test(ConditionContext): boolean
}
class WeekendConditionTest {
  ~ conditionService: ConditionService
  ~ source(): Stream<Arguments>
  ~ valid(String, boolean): void
}
class WindowsUtils {
  + windowsToUnixPath(String): String
}
class Worker {
  - runContextLoggerFactory: RunContextLoggerFactory
  - killedExecution: Set<String>
  - state: AtomicReference<ServiceState>
  - shutdown: AtomicBoolean
  - runningJobCount: AtomicInteger
  - workerTaskResultQueue: QueueInterface<WorkerTaskResult>
  - executionKilledQueue: QueueInterface<ExecutionKilled>
  - log: Logger
  - metricEntryQueue: QueueInterface<MetricEntry>
  - workerGroup: String
  - numThreads: Integer
  - id: String
  - SERVICE_PROPS_WORKER_GROUP: String
  - receiveCancellations: List<Runnable>
  - runContextInitializer: RunContextInitializer
  - serverConfig: ServerConfig
  - workerThreadReferences: List<AbstractWorkerThread>
  - workerJobQueue: WorkerJobQueueInterface
  - workerTriggerResultQueue: QueueInterface<WorkerTriggerResult>
  - metricRunningCount: Map<Long, AtomicInteger>
  - executorService: ExecutorService
  - pendingJobCount: AtomicInteger
  - triggerQueue: QueueInterface<Trigger>
  - skipGracefulTermination: AtomicBoolean
  - evaluateTriggerRunningCount: Map<String, AtomicInteger>
  - eventPublisher: ApplicationEventPublisher<ServiceStateChangeEvent>
  - metricRegistry: MetricRegistry
  - MAPPER: ObjectMapper
  - logService: LogService
  + getMetricRunningCount(): Map<Long, AtomicInteger>
  + getEvaluateTriggerRunningCount(): Map<String, AtomicInteger>
  + getWorkerGroup(): String
  + close(): void
  - publishTriggerExecution(WorkerTrigger, Optional<Execution>): void
  + run(): void
  - addAttempt(WorkerTask, TaskRunAttempt): List<TaskRunAttempt>
  - awaitForRealtimeTriggers(List<AbstractWorkerThread>, Duration): void
  + getType(): ServiceType
  - now(): ZonedDateTime
  - runAttempt(WorkerTask): WorkerTask
  - setState(ServiceState): void
  - handleRealtimeTriggerError(WorkerTrigger, Throwable): void
  + closeWorker(Duration): void
  - handleTask(WorkerTask): void
  + skipGracefulTermination(boolean): void
  ~ initMetrics(): void
  - run(WorkerTask, Boolean): WorkerTaskResult
  - logTerminated(WorkerTask): void
  + getMetrics(): Set<Metric>
  + shutdown(): void
  - handleTrigger(WorkerTrigger): void
  - runThread(AbstractWorkerThread, Logger): Type
  - cleanUpTransient(WorkerTask): WorkerTask
  + getWorkerThreadTasks(): List<WorkerJob>
  + getId(): String
  - handleTriggerError(WorkerTrigger, Throwable): void
  - waitForTasksCompletion(Duration): boolean
  - handleDeserializationError(DeserializationException): void
  + getMetricRunningCount(WorkerTask): AtomicInteger
  - logError(WorkerTrigger, Throwable): void
  + getState(): ServiceState
  - closeQueue(): void
}
class WorkerCommand {
  - thread: int
  - log: Logger
  - workerGroupKey: String
  - applicationContext: ApplicationContext
  + workerGroupKey(): String
  + propertiesOverrides(): Map<String, Object>
  + call(): Integer
}
class WorkerEndpoint {
  ~ worker: Worker
  + running(): WorkerEndpointResult
}
class WorkerGroup {
  - key: String
  + getKey(): String
}
interface WorkerGroupExecutorInterface << interface >> {
  + isWorkerGroupExistForKey(String): boolean
  + isWorkerGroupAvailableForKey(String): boolean
  + listAllWorkerGroupKeys(): Set<String>
}
class WorkerGroupService {
  - log: Logger
  + resolveGroupFromKey(String): String
  + resolveGroupFromJob(WorkerJob): String
}
annotation WorkerGroupValidation << annotation >> {
  + groups(): Class<?>[]
  + message(): String
  + payload(): Class<Payload>[]
}
class WorkerGroupValidator {
  - EE_PACKAGE: Package
  + isValid(WorkerGroup, AnnotationValue<WorkerGroupValidation>, ConstraintValidatorContext): boolean
}
class WorkerInstance {
  - workerGroup: String
  - partitions: List<Integer>
  - workerUuid: String
  + equals(Object): boolean
  + setWorkerUuid(String): void
  + setWorkerGroup(String): void
  + setPartitions(List<Integer>): void
  # canEqual(Object): boolean
  + hashCode(): int
  + builder(): WorkerInstanceBuilder<?, ?>
  + getWorkerUuid(): String
  + toBuilder(): WorkerInstanceBuilder<?, ?>
  + getWorkerGroup(): String
  - $default$partitions(): List<Integer>
  + getPartitions(): List<Integer>
  + toString(): String
}
class WorkerJob {
  + uid(): String
  + taskRunId(): String
  + getType(): String
}
interface WorkerJobLifecycle << interface >> {
  + stop(): void
  + kill(): void
}
interface WorkerJobQueueInterface << interface >> {
  + close(): void
  + receive(String, Class<?>, Consumer<Either<WorkerJob, DeserializationException>>): Runnable
}
class WorkerJobResubmit
class WorkerJobRunning {
  - partition: int
  - workerInstance: WorkerInstance
  + getWorkerInstance(): WorkerInstance
  + getPartition(): int
  + setWorkerInstance(WorkerInstance): void
  + setPartition(int): void
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + toString(): String
  + getType(): String
  + uid(): String
}
interface WorkerJobRunningRepositoryInterface << interface >> {
  + deleteByKey(String): void
  + findByKey(String): Optional<WorkerJobRunning>
}
class WorkerTask {
  + TYPE: String
  - taskRun: TaskRun
  - type: String
  - runContext: RunContext
  - task: Task
  + setTaskRun(TaskRun): void
  + getTaskRun(): TaskRun
  + getType(): String
  + withTaskRun(TaskRun): WorkerTask
  + getTask(): Task
  + getRunContext(): RunContext
  + setTask(Task): void
  + setRunContext(RunContext): void
  + toString(): String
  + equals(Object): boolean
  + hashCode(): int
  # canEqual(Object): boolean
  + builder(): WorkerTaskBuilder
  + uid(): String
  + fail(): WorkerTask
  + taskRunId(): String
  + logger(): Logger
}
enum WorkerTaskRestartStrategy << enumeration >> {
  + NEVER:
  + IMMEDIATELY:
  + AFTER_TERMINATION_GRACE_PERIOD:
  + isRestartable(): boolean
  + valueOf(String): WorkerTaskRestartStrategy
  + values(): WorkerTaskRestartStrategy[]
}
class WorkerTaskResult {
  - taskRun: TaskRun
  - dynamicTaskRuns: List<TaskRun>
  + builder(): WorkerTaskResultBuilder
  + getTaskRun(): TaskRun
  + getDynamicTaskRuns(): List<TaskRun>
  + equals(Object): boolean
  + hashCode(): int
  + toString(): String
}
class WorkerTaskResultTooLarge {
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + toString(): String
  + builder(): WorkerTaskResultTooLargeBuilder<?, ?>
  + run(RunContext): Output
}
class WorkerTaskRunning {
  + TYPE: String
  - task: Task
  - type: String
  - taskRun: TaskRun
  - runContext: RunContext
  + getTaskRun(): TaskRun
  + getType(): String
  + toString(): String
  + getTask(): Task
  + getRunContext(): RunContext
  + setTaskRun(TaskRun): void
  + setTask(Task): void
  + setRunContext(RunContext): void
  + builder(): WorkerTaskRunningBuilder<?, ?>
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + uid(): String
  + of(WorkerTask, WorkerInstance, int): WorkerTaskRunning
}
class WorkerTaskRunningTest {
  # MAPPER: ObjectMapper
  ~ deserializeOldWorkerTask(): void
}
class WorkerTaskTest {
  # MAPPER: ObjectMapper
  ~ deserializeOldWorkerTask(): void
}
class WorkerTaskThread {
  ~ workerTask: WorkerTask
  ~ task: RunnableTask<?>
  ~ taskOutput: Output
  ~ metricRegistry: MetricRegistry
  # kill(boolean): void
  + doRun(): void
  + getWorkerTask(): WorkerTask
  + getTaskOutput(): Output
  + signalStop(): void
}
class WorkerTest {
  ~ applicationContext: ApplicationContext
  ~ workerTaskQueue: QueueInterface<WorkerJob>
  ~ workerTaskResultQueue: QueueInterface<WorkerTaskResult>
  ~ workerTaskLogQueue: QueueInterface<LogEntry>
  ~ executionKilledQueue: QueueInterface<ExecutionKilled>
  ~ runContextFactory: RunContextFactory
  - workerTask(long): WorkerTask
  ~ killed(): void
  ~ success(): void
  ~ workerGroup(): void
  ~ failOnWorkerTaskWithFlowable(): void
  ~ shouldCreateInstanceGivenApplicationContext(): void
}
class WorkerTrigger {
  + TYPE: String
  - type: String
  - conditionContext: ConditionContext
  - trigger: AbstractTrigger
  - triggerContext: Trigger
  + getTriggerContext(): Trigger
  + getType(): String
  + getTrigger(): AbstractTrigger
  + getConditionContext(): ConditionContext
  + setTrigger(AbstractTrigger): void
  + builder(): WorkerTriggerBuilder
  + setTriggerContext(Trigger): void
  + setConditionContext(ConditionContext): void
  + equals(Object): boolean
  # canEqual(Object): boolean
  + hashCode(): int
  + toString(): String
  + taskRunId(): String
  + uid(): String
}
interface WorkerTriggerInterface << interface >>
class WorkerTriggerRealtimeThread {
  ~ onError: Consumer<Throwable>
  ~ streamingTrigger: RealtimeTriggerInterface
  ~ onNext: Consumer<Execution>
  + doRun(): void
}
class WorkerTriggerResult {
  - trigger: AbstractTrigger
  - success: Boolean
  - execution: Optional<Execution>
  - triggerContext: TriggerContext
  - $default$success(): Boolean
  + builder(): WorkerTriggerResultBuilder
  + getExecution(): Optional<Execution>
  + getTriggerContext(): TriggerContext
  + getTrigger(): AbstractTrigger
  + getSuccess(): Boolean
  + equals(Object): boolean
  + hashCode(): int
  + toString(): String
}
interface WorkerTriggerResultQueueInterface << interface >> {
  + receive(String, Class<?>, Consumer<Either<WorkerTriggerResult, DeserializationException>>): Runnable
}
class WorkerTriggerRunning {
  - trigger: AbstractTrigger
  - triggerContext: Trigger
  - conditionContext: ConditionContext
  + TYPE: String
  - type: String
  + getType(): String
  + getTrigger(): AbstractTrigger
  + getTriggerContext(): Trigger
  + getConditionContext(): ConditionContext
  + setTrigger(AbstractTrigger): void
  + setTriggerContext(Trigger): void
  + setConditionContext(ConditionContext): void
  + equals(Object): boolean
  + toString(): String
  # canEqual(Object): boolean
  + hashCode(): int
  + builder(): WorkerTriggerRunningBuilder<?, ?>
  + of(WorkerTrigger, WorkerInstance, int): WorkerTriggerRunning
  + uid(): String
}
class WorkerTriggerThread {
  ~ pollingTrigger: PollingTriggerInterface
  ~ evaluate: Optional<Execution>
  + getEvaluate(): Optional<Execution>
  + doRun(): void
}
interface WorkingDir << interface >> {
  + createTempFile(): Path
  + createTempFile(String): Path
  + createFile(String): Path
  + resolve(Path): Path
  + cleanup(): void
  + path(): Path
  + createTempFile(byte[], String): Path
  + createFile(String, InputStream): Path
  + id(): String
  + createTempFile(byte[]): Path
  + putFile(Path, InputStream): Path
  + path(boolean): Path
  + findAllFilesMatching(List<String>): List<Path>
  + createFile(String, byte[]): Path
}
class WorkingDirFactory {
  # tmpdirPath: Optional<String>
  - getTmpDir(): Path
  + createWorkingDirectory(): WorkingDir
}
class WorkingDirFactoryTest {
  ~ workingDirFactory: WorkingDirFactory
  ~ shouldCreateWorkingDirGivenKestraTmpDir(): void
}
class WorkingDirectory {
  - cache: Cache
  - namespaceFiles: NamespaceFiles
  - outputFiles: List<String>
  - OUTPUTS_FILE: String
  - cacheDownloadedTime: long
  - inputFiles: Object
  # canEqual(Object): boolean
  - $default$cacheDownloadedTime(): long
  + toBuilder(): WorkingDirectoryBuilder<?, ?>
  + equals(Object): boolean
  + hashCode(): int
  + getCache(): Cache
  - getCacheDownloadedTime(): long
  + getNamespaceFiles(): NamespaceFiles
  + getInputFiles(): Object
  + getOutputFiles(): List<String>
  + builder(): WorkingDirectoryBuilder<?, ?>
  + toString(): String
  + workerTask(TaskRun, Task, RunContext): WorkerTask
  + outputs(RunContext): Outputs
  + postExecuteTasks(RunContext, TaskRun): void
  + preExecuteTasks(RunContext, TaskRun): void
  + resolveNexts(RunContext, Execution, TaskRun): List<NextTaskRun>
}
annotation WorkingDirectoryTaskValidation << annotation >> {
  + groups(): Class<?>[]
  + message(): String
  + payload(): Class<Payload>[]
}
class WorkingDirectoryTaskValidator {
  + isValid(WorkingDirectory, AnnotationValue<WorkingDirectoryTaskValidation>, ConstraintValidatorContext): boolean
}
class WorkingDirectoryTest {
  ~ suite: Suite
  ~ runContextFactory: RunContextFactory
  ~ encryption(): void
  ~ success(): void
  ~ taskrun(): void
  ~ taskrunNested(): void
  ~ cache(): void
  ~ namespaceFiles(): void
  ~ failed(): void
  ~ each(): void
  ~ inputFiles(): void
  ~ outputFiles(): void
}
class WorkingDirectoryTest {
  - modelValidator: ModelValidator
  ~ workingDirectoryInvalid(): void
  ~ workingDirectoryValid(): void
}
class YamlFilter {
  - MAPPER: ObjectMapper
  + getArgumentNames(): List<String>
  + apply(Object, Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
}
class YamlFilterTest {
  ~ variableRenderer: VariableRenderer
  ~ map(): void
}
class YamlFlowParser {
  - MAPPER: ObjectMapper
  + parse(File, Class<T>): T
  - jsonProcessingExceptionHandler(T, String, JsonProcessingException): void
  - type(Class<T>): String
  - readFlow(String, Class<T>, String): T?
  + isValidExtension(Path): boolean
  + parse(String, Class<T>): T
  + parse(Map<String, Object>, Class<T>, Boolean): T
}
class YamlFlowParserTest {
  - mapper: ObjectMapper
  - yamlFlowParser: YamlFlowParser
  - modelValidator: ModelValidator
  ~ allFlowable(): void
  ~ listeners(): void
  - parseString(String): Flow
  ~ parseString(): void
  ~ duplicateKey(): void
  ~ inputsFailed(): void
  ~ inputsOld(): void
  ~ parse(): void
  ~ invalidPropertyOk(): void
  ~ invalidProperty(): void
  ~ serialization(): void
  ~ validation(): void
  ~ invalidTask(): void
  - parse(String): Flow
  ~ empty(): void
  ~ inputs(): void
  ~ noDefault(): void
  ~ inputsBadType(): void
  ~ invalidParallel(): void
}
class YamlFunction {
  ~ MAPPER: ObjectMapper
  - TYPE_REFERENCE: TypeReference<Object>
  + execute(Map<String, Object>, PebbleTemplate, EvaluationContext, int): Object
  + getArgumentNames(): List<String>
}
class YamlFunctionTest {
  ~ variableRenderer: VariableRenderer
  ~ fromString(): void
}
class YamlInput {
  + builder(): YamlInputBuilder<?, ?>
  + validate(Object): void
}

AbstractApiCommand                           -[#000082,plain]-^  AbstractCommand
AbstractCommand                             "1" *-[#595959,plain]-> "pluginRegistry\n1" PluginRegistry
AbstractCommand                             "1" *-[#595959,plain]-> "startupHook\n1" StartupHookInterface
AbstractCommand                             "1" *-[#595959,plain]-> "versionProvider\n1" VersionProvider
AbstractExecScript                           -[#595959,dashed]->  CommandsWrapper                             : "create"
AbstractExecScript                          "1" *-[#595959,plain]-> "docker\n1" DockerOptions
AbstractExecScript                           -[#008200,dashed]-^  InputFilesInterface
AbstractExecScript                          "1" *-[#595959,plain]-> "namespaceFiles\n1" NamespaceFiles
AbstractExecScript                           -[#008200,dashed]-^  NamespaceFilesInterface
AbstractExecScript                           -[#008200,dashed]-^  OutputFilesInterface
AbstractExecScript                           -[#008200,dashed]-^  RunnableTask
AbstractExecScript                          "1" *-[#595959,plain]-> "runner\n1" RunnerType
AbstractExecScript                          "1" *-[#595959,plain]-> "targetOS\n1" TargetOS
AbstractExecScript                           -[#000082,plain]-^  Task
AbstractExecScript                          "1" *-[#595959,plain]-> "taskRunner\n1" TaskRunner
AbstractExecutionRepositoryTest             "1" *-[#595959,plain]-> "executionRepository\n1" ExecutionRepositoryInterface
AbstractExecutionRepositoryTest              -[#595959,dashed]->  Flow                                        : "create"
AbstractExecutionRepositoryTest              -[#999900,dotted]-  KestraTest
AbstractExecutionRepositoryTest              -[#595959,dashed]->  Label                                       : "create"
AbstractExecutionRepositoryTest              -[#595959,dashed]->  State                                       : "create"
AbstractExecutionServiceTest                "1" *-[#595959,plain]-> "executionRepository\n1" ExecutionRepositoryInterface
AbstractExecutionServiceTest                "1" *-[#595959,plain]-> "executionService\n1" ExecutionService
AbstractExecutionServiceTest                 -[#999900,dotted]-  KestraTest
AbstractExecutionServiceTest                "1" *-[#595959,plain]-> "logRepository\n1" LogRepositoryInterface
AbstractExecutionServiceTest                "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
AbstractExecutionServiceTest                 -[#595959,dashed]->  State                                       : "create"
AbstractExecutionServiceTest                "1" *-[#595959,plain]-> "storageInterface\n1" StorageInterface
AbstractFlow                                 -[#008200,dashed]-^  DeletedInterface
AbstractFlow                                "1" *-[#595959,plain]-> "inputs\n*" Input
AbstractFlow                                 -[#008200,dashed]-^  TenantInterface
AbstractFlowRepositoryTest                  "1" *-[#595959,plain]-> "executionRepository\n1" ExecutionRepositoryInterface
AbstractFlowRepositoryTest                  "1" *-[#595959,plain]-> "flowRepository\n1" FlowRepositoryInterface
AbstractFlowRepositoryTest                   -[#999900,dotted]-  KestraTest
AbstractFlowRepositoryTest                  "1" *-[#595959,plain]-> "repositoryLoader\n1" LocalFlowRepositoryLoader
AbstractFlowRepositoryTest                  "1" *-[#595959,plain]-> "pluginDefaultService\n1" PluginDefaultService
AbstractFlowRepositoryTest                  "1" *-[#595959,plain]-> "triggerQueue\n1" QueueInterface
AbstractFlowRepositoryTest                   -[#595959,dashed]->  State                                       : "create"
AbstractFlowTopologyRepositoryTest          "1" *-[#595959,plain]-> "flowTopologyRepository\n1" FlowTopologyRepositoryInterface
AbstractFlowTopologyRepositoryTest           -[#999900,dotted]-  KestraTest
AbstractGraphTask                            -[#000082,plain]-^  AbstractGraph
AbstractGraphTask                           "1" *-[#595959,plain]-> "relationType\n1" RelationType
AbstractGraphTask                           "1" *-[#595959,plain]-> "task\n1" TaskInterface
AbstractGraphTask                           "1" *-[#595959,plain]-> "taskRun\n1" TaskRun
AbstractGraphTrigger                         -[#000082,plain]-^  AbstractGraph
AbstractGraphTrigger                        "1" *-[#595959,plain]-> "trigger\n1" Trigger
AbstractGraphTrigger                        "1" *-[#595959,plain]-> "triggerDeclaration\n1" TriggerInterface
AbstractHttp                                 -[#008200,dashed]-^  HttpInterface
AbstractHttp                                 -[#000082,plain]-^  Task
AbstractJdbcDeserializationIssuesTest       "1" *-[#595959,plain]-> "deserializationIssuesCaseTest\n1" DeserializationIssuesCaseTest
AbstractJdbcDeserializationIssuesTest       "1" *-[#595959,plain]-> "jdbcTableConfigs\n1" JdbcTableConfigs
AbstractJdbcDeserializationIssuesTest       "1" *-[#595959,plain]-> "jdbcTestUtils\n1" JdbcTestUtils
AbstractJdbcDeserializationIssuesTest       "1" *-[#595959,plain]-> "dslContextWrapper\n1" JooqDSLContextWrapper
AbstractJdbcDeserializationIssuesTest        -[#999900,dotted]-  KestraTest
AbstractJdbcDeserializationIssuesTest       "1" *-[#595959,plain]-> "runner\n1" StandAloneRunner
AbstractJdbcExecutionDelayStorage            -[#000082,plain]-^  AbstractJdbcRepository
AbstractJdbcExecutionDelayStorage           "1" *-[#595959,plain]-> "jdbcRepository\n1" AbstractJdbcRepository
AbstractJdbcExecutionQueuedStorage           -[#000082,plain]-^  AbstractJdbcRepository
AbstractJdbcExecutionQueuedStorage          "1" *-[#595959,plain]-> "jdbcRepository\n1" AbstractJdbcRepository
AbstractJdbcExecutionRepository             "1" *-[#595959,plain]-> "executorStateStorage\n1" AbstractJdbcExecutorStateStorage
AbstractJdbcExecutionRepository              -[#000082,plain]-^  AbstractJdbcRepository
AbstractJdbcExecutionRepository             "1" *-[#595959,plain]-> "jdbcRepository\n1" AbstractJdbcRepository
AbstractJdbcExecutionRepository              -[#595959,dashed]->  CrudEvent                                   : "create"
AbstractJdbcExecutionRepository              -[#595959,dashed]->  ExecutionCount                              : "create"
AbstractJdbcExecutionRepository              -[#595959,dashed]->  ExecutionCountStatistics                    : "create"
AbstractJdbcExecutionRepository              -[#008200,dashed]-^  ExecutionRepositoryInterface
AbstractJdbcExecutionRepository              -[#008200,dashed]-^  JdbcIndexerInterface
AbstractJdbcExecutionRepository             "1" *-[#595959,plain]-> "namespaceUtils\n1" NamespaceUtils
AbstractJdbcExecutionRepository             "1" *-[#595959,plain]-> "executionQueue\n1" QueueInterface
AbstractJdbcExecutionRepositoryTest          -[#000082,plain]-^  AbstractExecutionRepositoryTest
AbstractJdbcExecutionRepositoryTest         "1" *-[#595959,plain]-> "jdbcTestUtils\n1" JdbcTestUtils
AbstractJdbcExecutorStateStorage            "1" *-[#595959,plain]-> "jdbcRepository\n1" AbstractJdbcRepository
AbstractJdbcExecutorStateStorage             -[#595959,dashed]->  ExecutorState                               : "create"
AbstractJdbcFlowRepository                   -[#000082,plain]-^  AbstractJdbcRepository
AbstractJdbcFlowRepository                  "1" *-[#595959,plain]-> "jdbcRepository\n1" AbstractJdbcRepository
AbstractJdbcFlowRepository                   -[#595959,dashed]->  CrudEvent                                   : "create"
AbstractJdbcFlowRepository                   -[#595959,dashed]->  DeserializationException                    : "create"
AbstractJdbcFlowRepository                   -[#008200,dashed]-^  FlowRepositoryInterface
AbstractJdbcFlowRepository                  "1" *-[#595959,plain]-> "modelValidator\n1" ModelValidator
AbstractJdbcFlowRepository                  "1" *-[#595959,plain]-> "namespaceUtils\n1" NamespaceUtils
AbstractJdbcFlowRepository                  "1" *-[#595959,plain]-> "flowQueue\n1" QueueInterface
AbstractJdbcFlowRepository                   -[#595959,dashed]->  SearchResult                                : "create"
AbstractJdbcFlowRepositoryTest               -[#000082,plain]-^  AbstractFlowRepositoryTest
AbstractJdbcFlowRepositoryTest              "1" *-[#595959,plain]-> "flowRepository\n1" AbstractJdbcFlowRepository
AbstractJdbcFlowRepositoryTest              "1" *-[#595959,plain]-> "jdbcTestUtils\n1" JdbcTestUtils
AbstractJdbcFlowRepositoryTest              "1" *-[#595959,plain]-> "dslContextWrapper\n1" JooqDSLContextWrapper
AbstractJdbcFlowTopologyRepository           -[#000082,plain]-^  AbstractJdbcRepository
AbstractJdbcFlowTopologyRepository          "1" *-[#595959,plain]-> "jdbcRepository\n1" AbstractJdbcRepository
AbstractJdbcFlowTopologyRepository           -[#008200,dashed]-^  FlowTopologyRepositoryInterface
AbstractJdbcFlowTopologyRepository           -[#008200,dashed]-^  JdbcIndexerInterface
AbstractJdbcFlowTopologyRepositoryTest       -[#000082,plain]-^  AbstractFlowTopologyRepositoryTest
AbstractJdbcFlowTopologyRepositoryTest      "1" *-[#595959,plain]-> "flowTopologyRepository\n1" AbstractJdbcFlowTopologyRepository
AbstractJdbcFlowTopologyRepositoryTest      "1" *-[#595959,plain]-> "jdbcTestUtils\n1" JdbcTestUtils
AbstractJdbcLogRepository                    -[#000082,plain]-^  AbstractJdbcRepository
AbstractJdbcLogRepository                   "1" *-[#595959,plain]-> "jdbcRepository\n1" AbstractJdbcRepository
AbstractJdbcLogRepository                    -[#008200,dashed]-^  JdbcIndexerInterface
AbstractJdbcLogRepository                    -[#008200,dashed]-^  LogRepositoryInterface
AbstractJdbcLogRepositoryTest                -[#000082,plain]-^  AbstractLogRepositoryTest
AbstractJdbcLogRepositoryTest               "1" *-[#595959,plain]-> "jdbcTestUtils\n1" JdbcTestUtils
AbstractJdbcMetricRepository                 -[#000082,plain]-^  AbstractJdbcRepository
AbstractJdbcMetricRepository                "1" *-[#595959,plain]-> "jdbcRepository\n1" AbstractJdbcRepository
AbstractJdbcMetricRepository                 -[#008200,dashed]-^  JdbcIndexerInterface
AbstractJdbcMetricRepository                 -[#008200,dashed]-^  MetricRepositoryInterface
AbstractJdbcMetricRepositoryTest             -[#000082,plain]-^  AbstractMetricRepositoryTest
AbstractJdbcMetricRepositoryTest            "1" *-[#595959,plain]-> "jdbcTestUtils\n1" JdbcTestUtils
AbstractJdbcMultipleConditionStorage         -[#000082,plain]-^  AbstractJdbcRepository
AbstractJdbcMultipleConditionStorage        "1" *-[#595959,plain]-> "jdbcRepository\n1" AbstractJdbcRepository
AbstractJdbcMultipleConditionStorage         -[#008200,dashed]-^  MultipleConditionStorageInterface
AbstractJdbcRepository                       -[#595959,dashed]->  DeserializationException                    : "create"
AbstractJdbcRepository                      "1" *-[#595959,plain]-> "dslContextWrapper\n1" JooqDSLContextWrapper
AbstractJdbcRepository                      "1" *-[#595959,plain]-> "queueService\n1" QueueService
AbstractJdbcServiceInstanceRepository        -[#000082,plain]-^  AbstractJdbcRepository
AbstractJdbcServiceInstanceRepository       "1" *-[#595959,plain]-> "jdbcRepository\n1" AbstractJdbcRepository
AbstractJdbcServiceInstanceRepository        -[#008200,dashed]-^  ServiceInstanceRepositoryInterface
AbstractJdbcServiceInstanceRepositoryTest   "1" *-[#595959,plain]-> "repository\n1" AbstractJdbcServiceInstanceRepository
AbstractJdbcServiceInstanceRepositoryTest   "1" *-[#595959,plain]-> "jdbcTestUtils\n1" JdbcTestUtils
AbstractJdbcServiceInstanceRepositoryTest    -[#999900,dotted]-  KestraTest
AbstractJdbcSettingRepository                -[#000082,plain]-^  AbstractJdbcRepository
AbstractJdbcSettingRepository               "1" *-[#595959,plain]-> "jdbcRepository\n1" AbstractJdbcRepository
AbstractJdbcSettingRepository                -[#595959,dashed]->  CrudEvent                                   : "create"
AbstractJdbcSettingRepository                -[#008200,dashed]-^  SettingRepositoryInterface
AbstractJdbcSettingRepositoryTest            -[#000082,plain]-^  AbstractSettingRepositoryTest
AbstractJdbcSettingRepositoryTest           "1" *-[#595959,plain]-> "jdbcTestUtils\n1" JdbcTestUtils
AbstractJdbcSubflowExecutionStorage          -[#000082,plain]-^  AbstractJdbcRepository
AbstractJdbcSubflowExecutionStorage         "1" *-[#595959,plain]-> "jdbcRepository\n1" AbstractJdbcRepository
AbstractJdbcTemplateRepository               -[#000082,plain]-^  AbstractJdbcRepository
AbstractJdbcTemplateRepository              "1" *-[#595959,plain]-> "jdbcRepository\n1" AbstractJdbcRepository
AbstractJdbcTemplateRepository               -[#595959,dashed]->  CrudEvent                                   : "create"
AbstractJdbcTemplateRepository              "1" *-[#595959,plain]-> "templateQueue\n1" QueueInterface
AbstractJdbcTemplateRepository               -[#008200,dashed]-^  TemplateRepositoryInterface
AbstractJdbcTemplateRepositoryTest           -[#000082,plain]-^  AbstractTemplateRepositoryTest
AbstractJdbcTemplateRepositoryTest          "1" *-[#595959,plain]-> "jdbcTestUtils\n1" JdbcTestUtils
AbstractJdbcTriggerRepository                -[#000082,plain]-^  AbstractJdbcRepository
AbstractJdbcTriggerRepository               "1" *-[#595959,plain]-> "jdbcRepository\n1" AbstractJdbcRepository
AbstractJdbcTriggerRepository                -[#008200,dashed]-^  JdbcIndexerInterface
AbstractJdbcTriggerRepository                -[#008200,dashed]-^  TriggerRepositoryInterface
AbstractJdbcTriggerRepositoryTest           "1" *-[#595959,plain]-> "repository\n1" AbstractJdbcTriggerRepository
AbstractJdbcTriggerRepositoryTest            -[#000082,plain]-^  AbstractTriggerRepositoryTest
AbstractJdbcTriggerRepositoryTest           "1" *-[#595959,plain]-> "jdbcTestUtils\n1" JdbcTestUtils
AbstractJdbcWorkerJobRunningRepository       -[#000082,plain]-^  AbstractJdbcRepository
AbstractJdbcWorkerJobRunningRepository      "1" *-[#595959,plain]-> "jdbcRepository\n1" AbstractJdbcRepository
AbstractJdbcWorkerJobRunningRepository       -[#008200,dashed]-^  WorkerJobRunningRepositoryInterface
AbstractLogRepositoryTest                    -[#999900,dotted]-  KestraTest
AbstractLogRepositoryTest                   "1" *-[#595959,plain]-> "logRepository\n1" LogRepositoryInterface
AbstractMemoryRunnerTest                     -[#999900,dotted]-  KestraTest
AbstractMemoryRunnerTest                    "1" *-[#595959,plain]-> "repositoryLoader\n1" LocalFlowRepositoryLoader
AbstractMemoryRunnerTest                    "1" *-[#595959,plain]-> "runnerUtils\n1" RunnerUtils
AbstractMemoryRunnerTest                    "1" *-[#595959,plain]-> "runner\n1" StandAloneRunner
AbstractMetricRepositoryTest                 -[#999900,dotted]-  KestraTest
AbstractMetricRepositoryTest                "1" *-[#595959,plain]-> "metricRepository\n1" MetricRepositoryInterface
AbstractMultipleConditionStorageTest         -[#999900,dotted]-  KestraTest
AbstractScheduler                           "1" *-[#595959,plain]-> "conditionService\n1" ConditionService
AbstractScheduler                           "1" *-[#595959,plain]-> "flowListeners\n1" FlowListenersInterface
AbstractScheduler                           "1" *-[#595959,plain]-> "logService\n1" LogService
AbstractScheduler                           "1" *-[#595959,plain]-> "metricRegistry\n1" MetricRegistry
AbstractScheduler                           "1" *-[#595959,plain]-> "pluginDefaultService\n1" PluginDefaultService
AbstractScheduler                           "1" *-[#595959,plain]-> "executionQueue\n1" QueueInterface
AbstractScheduler                           "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
AbstractScheduler                           "1" *-[#595959,plain]-> "runContextInitializer\n1" RunContextInitializer
AbstractScheduler                            -[#008200,dashed]-^  Scheduler
AbstractScheduler                            -[#595959,dashed]->  SchedulerExecutionWithTrigger               : "create"
AbstractScheduler                           "1" *-[#595959,plain]-> "triggerState\n1" SchedulerTriggerStateInterface
AbstractScheduler                            -[#008200,dashed]-^  Service
AbstractScheduler                            -[#595959,dashed]->  ServiceStateChangeEvent                     : "create"
AbstractScheduler                            -[#595959,dashed]->  State                                       : "create"
AbstractScheduler                           "1" *-[#595959,plain]-> "workerGroupService\n1" WorkerGroupService
AbstractScheduler                           "1" *-[#595959,plain]-> "workerTriggerResultQueue\n1" WorkerTriggerResultQueueInterface
AbstractSchedulerTest                        -[#999900,dotted]-  KestraTest
AbstractSchedulerTest                        -[#595959,dashed]->  Label                                       : "create"
AbstractSchedulerTest                       "1" *-[#595959,plain]-> "executionQueue\n1" QueueInterface
AbstractSchedulerTest                        -[#595959,dashed]->  WorkerGroup                                 : "create"
AbstractServerCommand                        -[#000082,plain]-^  AbstractCommand
AbstractServerCommand                        -[#008200,dashed]-^  ServerCommandInterface
AbstractServiceLivenessCoordinator           -[#000082,plain]-^  AbstractServiceLivenessTask
AbstractServiceLivenessCoordinator          "1" *-[#595959,plain]-> "serviceInstanceRepository\n1" ServiceInstanceRepositoryInterface
AbstractServiceLivenessTask                 "1" *-[#595959,plain]-> "serverConfig\n1" ServerConfig
AbstractServiceNamespaceUpdateCommand        -[#000082,plain]-^  AbstractApiCommand
AbstractSettingRepositoryTest                -[#999900,dotted]-  KestraTest
AbstractSettingRepositoryTest               "1" *-[#595959,plain]-> "settingRepository\n1" SettingRepositoryInterface
AbstractState                                -[#000082,plain]-^  Task
AbstractSubflowExecutionTest                "1" *-[#595959,plain]-> "subflowExecutionStorage\n1" AbstractJdbcSubflowExecutionStorage
AbstractSubflowExecutionTest                "1" *-[#595959,plain]-> "jdbcTestUtils\n1" JdbcTestUtils
AbstractSubflowExecutionTest                 -[#999900,dotted]-  KestraTest
AbstractTaskRunnerTest                       -[#595959,dashed]->  DefaultLogConsumer                          : "create"
AbstractTaskRunnerTest                       -[#999900,dotted]-  KestraTest
AbstractTaskRunnerTest                      "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
AbstractTaskRunnerTest                       -[#595959,dashed]->  State                                       : "create"
AbstractTaskRunnerTest                      "1" *-[#595959,plain]-> "storage\n1" StorageInterface
AbstractTemplateRepositoryTest               -[#999900,dotted]-  KestraTest
AbstractTemplateRepositoryTest              "1" *-[#595959,plain]-> "templateRepository\n1" TemplateRepositoryInterface
AbstractTrigger                             "1" *-[#595959,plain]-> "conditions\n*" Condition
AbstractTrigger                             "1" *-[#595959,plain]-> "labels\n*" Label
AbstractTrigger                              -[#999900,dotted]-  Plugin
AbstractTrigger                              -[#008200,dashed]-^  TriggerInterface
AbstractTrigger                             "1" *-[#595959,plain]-> "workerGroup\n1" WorkerGroup
AbstractTriggerForExecution                  -[#008200,dashed]-^  TriggerInterface
AbstractTriggerRepositoryTest                -[#999900,dotted]-  KestraTest
AbstractTriggerRepositoryTest               "1" *-[#595959,plain]-> "triggerRepository\n1" TriggerRepositoryInterface
AbstractValidateCommand                      -[#000082,plain]-^  AbstractApiCommand
AbstractWorkerThread                        "1" *-[#595959,plain]-> "runContext\n1" RunContext
AbstractWorkerTriggerThread                  -[#000082,plain]-^  AbstractWorkerThread
AbstractWorkerTriggerThread                 "1" *-[#595959,plain]-> "workerTrigger\n1" WorkerTrigger
AliasTest                                    -[#000082,plain]-^  AbstractMemoryRunnerTest
AllowFailure                                 -[#595959,dashed]->  Example                                     : "create"
AllowFailure                                 -[#008200,dashed]-^  FlowableTask
AllowFailure                                 -[#999900,dotted]-  Plugin
AllowFailure                                 -[#000082,plain]-^  Sequential
AllowFailureTest                             -[#000082,plain]-^  AbstractMemoryRunnerTest
AllowFailureTest                            "1" *-[#595959,plain]-> "flowIO\n1" FlowInputOutput
ArrayInput                                   -[#999900,dotted]-  ArrayInputValidation
ArrayInput                                   -[#000082,plain]-^  Input
ArrayInput                                   -[#008200,dashed]-^  ItemTypeInterface
ArrayInput                                  "1" *-[#595959,plain]-> "itemType\n1" Type
AuthenticationFilter                        "1" *-[#595959,plain]-> "basicAuthService\n1" BasicAuthService
AuthenticationFilterTest                     -[#999900,dotted]-  KestraTest
Backfill                                    "1" *-[#595959,plain]-> "labels\n*" Label
BadExecutable                                -[#595959,dashed]->  Example                                     : "create"
BadExecutable                                -[#999900,dotted]-  Plugin
BadExecutable                                -[#000082,plain]-^  Subflow
BadExecutableTest                            -[#000082,plain]-^  AbstractMemoryRunnerTest
BadFlowableTest                              -[#000082,plain]-^  AbstractMemoryRunnerTest
BadSequential                                -[#595959,dashed]->  Example                                     : "create"
BadSequential                                -[#999900,dotted]-  Plugin
BadSequential                                -[#000082,plain]-^  Sequential
Base64Render                                 -[#000082,plain]-^  FileRender
BasicAuthEndpointsFilter                    "1" *-[#595959,plain]-> "endpointBasicAuthConfiguration\n1" EndpointBasicAuthConfiguration
BasicAuthService                            "1" *-[#595959,plain]-> "instanceService\n1" InstanceService
BasicAuthService                            "1" *-[#595959,plain]-> "settingRepository\n1" SettingRepositoryInterface
BasicAuthServiceTest                        "1" *-[#595959,plain]-> "basicAuthService\n1" BasicAuthService
BasicAuthServiceTest                        "1" *-[#595959,plain]-> "instanceService\n1" InstanceService
BasicAuthServiceTest                        "1" *-[#595959,plain]-> "settingRepositoryInterface\n1" SettingRepositoryInterface
BlueprintControllerTest                      -[#999900,dotted]-  KestraTest
BooleanInput                                 -[#000082,plain]-^  Input
ChunkFilterTest                              -[#999900,dotted]-  KestraTest
ChunkFilterTest                             "1" *-[#595959,plain]-> "variableRenderer\n1" VariableRenderer
ClassInputDocumentation                      -[#000082,plain]-^  AbstractClassDocumentation
ClassPluginDocumentation                     -[#000082,plain]-^  AbstractClassDocumentation
ClassPluginDocumentationTest                 -[#595959,dashed]->  PluginScanner                               : "create"
CollectorScheduler                          "1" *-[#595959,plain]-> "collectorService\n1" CollectorService
CollectorService                            "1" *-[#595959,plain]-> "executionRepository\n1" ExecutionRepositoryInterface
CollectorService                            "1" *-[#595959,plain]-> "flowRepository\n1" FlowRepositoryInterface
CollectorService                            "1" *-[#595959,plain]-> "instanceService\n1" InstanceService
CollectorService                            "1" *-[#595959,plain]-> "pluginRegistry\n1" PluginRegistry
CollectorService                            "1" *-[#595959,plain]-> "serverType\n1" ServerType
CollectorService                            "1" *-[#595959,plain]-> "defaultUsage\n1" Usage
CollectorService                            "1" *-[#595959,plain]-> "versionProvider\n1" VersionProvider
CollectorServiceTest                         -[#999900,dotted]-  KestraTest
CommandsWrapper                             "1" *-[#595959,plain]-> "logConsumer\n1" AbstractLogConsumer
CommandsWrapper                              -[#595959,dashed]->  DefaultLogConsumer                          : "create"
CommandsWrapper                             "1" *-[#595959,plain]-> "dockerOptions\n1" DockerOptions
CommandsWrapper                             "1" *-[#595959,plain]-> "namespaceFiles\n1" NamespaceFiles
CommandsWrapper                              -[#595959,dashed]->  Process                                     : "create"
CommandsWrapper                             "1" *-[#595959,plain]-> "runContext\n1" RunContext
CommandsWrapper                             "1" *-[#595959,plain]-> "runnerType\n1" RunnerType
CommandsWrapper                             "1" *-[#595959,plain]-> "targetOS\n1" TargetOS
CommandsWrapper                              -[#008200,dashed]-^  TaskCommands
CommandsWrapper                             "1" *-[#595959,plain]-> "taskRunner\n1" TaskRunner
Concat                                       -[#595959,dashed]->  Example                                     : "create"
Concat                                       -[#999900,dotted]-  Plugin
Concat                                       -[#008200,dashed]-^  RunnableTask
Concat                                       -[#000082,plain]-^  Task
ConcatTest                                   -[#999900,dotted]-  KestraTest
ConcatTest                                  "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
ConcatTest                                  "1" *-[#595959,plain]-> "storageInterface\n1" StorageInterface
Condition                                    -[#008200,dashed]-^  Plugin
Condition                                    -[#999900,dotted]-  Plugin
ConditionContext                            "1" *-[#595959,plain]-> "execution\n1" Execution
ConditionContext                            "1" *-[#595959,plain]-> "flow\n1" Flow
ConditionContext                            "1" *-[#595959,plain]-> "multipleConditionStorage\n1" MultipleConditionStorageInterface
ConditionContext                            "1" *-[#595959,plain]-> "runContext\n1" RunContext
ConditionService                            "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
ConditionServiceTest                        "1" *-[#595959,plain]-> "conditionService\n1" ConditionService
ConditionServiceTest                         -[#999900,dotted]-  KestraTest
ConditionServiceTest                        "1" *-[#595959,plain]-> "logQueue\n1" QueueInterface
ConditionServiceTest                        "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
ConfigCommand                                -[#000082,plain]-^  AbstractCommand
ConfigPropertiesCommand                      -[#000082,plain]-^  AbstractCommand
Constant                                     -[#000082,plain]-^  AbstractRetry
Count                                        -[#595959,dashed]->  Example                                     : "create"
Count                                       "1" *-[#595959,plain]-> "flows\n*" Flow
Count                                        -[#999900,dotted]-  Plugin
Count                                        -[#008200,dashed]-^  RunnableTask
Count                                        -[#000082,plain]-^  Task
Counter                                      -[#000082,plain]-^  AbstractMetricEntry
CrudEvent                                   "1" *-[#595959,plain]-> "type\n1" CrudEventType
CurrentEachOutputFunctionTest                -[#000082,plain]-^  AbstractMemoryRunnerTest
Dag                                          -[#999900,dotted]-  DagTaskValidation
Dag                                          -[#595959,dashed]->  Example                                     : "create"
Dag                                          -[#008200,dashed]-^  FlowableTask
Dag                                          -[#595959,dashed]->  GraphCluster                                : "create"
Dag                                          -[#595959,dashed]->  IllegalVariableEvaluationException          : "create"
Dag                                          -[#999900,dotted]-  Plugin
Dag                                          -[#000082,plain]-^  Task
Dag                                         "1" *-[#595959,plain]-> "errors\n*" Task
DagTest                                      -[#000082,plain]-^  AbstractMemoryRunnerTest
DagTest                                     "1" *-[#595959,plain]-> "modelValidator\n1" ModelValidator
DagTest                                     "1" *-[#595959,plain]-> "yamlFlowParser\n1" YamlFlowParser
DagTest                                      -[#595959,dashed]->  YamlFlowParser                              : "create"
Data                                         -[#999900,dotted]-  DataValidation
Data                                        "1" *-[#595959,plain]-> "fromURI\n1" Property
DataValidationTest                           -[#999900,dotted]-  KestraTest
DataValidationTest                          "1" *-[#595959,plain]-> "modelValidator\n1" ModelValidator
DataValidationTest                           -[#595959,dashed]->  Property                                    : "create"
DatabaseCommand                              -[#000082,plain]-^  AbstractCommand
DatabaseMigrateCommand                       -[#000082,plain]-^  AbstractCommand
DateAddFilter                                -[#000082,plain]-^  AbstractDate
DateFilter                                   -[#000082,plain]-^  AbstractDate
DateFilterTest                               -[#999900,dotted]-  KestraTest
DateFilterTest                              "1" *-[#595959,plain]-> "variableRenderer\n1" VariableRenderer
DateFormatTest                               -[#999900,dotted]-  KestraTest
DateFormatTest                              "1" *-[#595959,plain]-> "modelValidator\n1" ModelValidator
DateInput                                    -[#000082,plain]-^  Input
DateTimeBetweenCondition                     -[#000082,plain]-^  Condition
DateTimeBetweenCondition                     -[#595959,dashed]->  Example                                     : "create"
DateTimeBetweenCondition                     -[#595959,dashed]->  IllegalConditionEvaluation                  : "create"
DateTimeBetweenCondition                     -[#999900,dotted]-  Plugin
DateTimeBetweenCondition                     -[#008200,dashed]-^  ScheduleCondition
DateTimeBetweenConditionTest                "1" *-[#595959,plain]-> "conditionService\n1" ConditionService
DateTimeBetweenConditionTest                 -[#999900,dotted]-  KestraTest
DateTimeInput                                -[#000082,plain]-^  Input
DateUtils                                    -[#595959,dashed]->  InternalException                           : "create"
DayWeekCondition                             -[#000082,plain]-^  Condition
DayWeekCondition                             -[#595959,dashed]->  Example                                     : "create"
DayWeekCondition                             -[#999900,dotted]-  Plugin
DayWeekCondition                             -[#008200,dashed]-^  ScheduleCondition
DayWeekConditionTest                        "1" *-[#595959,plain]-> "conditionService\n1" ConditionService
DayWeekConditionTest                         -[#999900,dotted]-  KestraTest
DayWeekInMonthCondition                      -[#000082,plain]-^  Condition
DayWeekInMonthCondition                      -[#595959,dashed]->  Example                                     : "create"
DayWeekInMonthCondition                      -[#999900,dotted]-  Plugin
DayWeekInMonthCondition                      -[#008200,dashed]-^  ScheduleCondition
DayWeekInMonthConditionTest                 "1" *-[#595959,plain]-> "conditionService\n1" ConditionService
DayWeekInMonthConditionTest                  -[#999900,dotted]-  KestraTest
DeduplicateItems                             -[#595959,dashed]->  Example                                     : "create"
DeduplicateItems                             -[#999900,dotted]-  Plugin
DeduplicateItems                             -[#008200,dashed]-^  RunnableTask
DeduplicateItems                             -[#000082,plain]-^  Task
DeduplicateItemsTest                         -[#999900,dotted]-  KestraTest
DeduplicateItemsTest                        "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
DeduplicateItemsTest                        "1" *-[#595959,plain]-> "storageInterface\n1" StorageInterface
DefaultFileRender                            -[#000082,plain]-^  FileRender
DefaultFileRenderTest                        -[#595959,dashed]->  DefaultFileRender                           : "create"
DefaultFlowExecutor                         "1" *-[#595959,plain]-> "allFlows\n*" Flow
DefaultFlowExecutor                          -[#008200,dashed]-^  FlowExecutorInterface
DefaultFlowExecutor                         "1" *-[#595959,plain]-> "flowRepository\n1" FlowRepositoryInterface
DefaultLogConsumer                           -[#000082,plain]-^  AbstractLogConsumer
DefaultLogConsumer                          "1" *-[#595959,plain]-> "runContext\n1" RunContext
DefaultPluginRegistry                       "1" *-[#595959,plain]-> "pluginClassByIdentifier\n*" PluginIdentifier
DefaultPluginRegistry                        -[#008200,dashed]-^  PluginRegistry
DefaultPluginRegistry                        -[#595959,dashed]->  PluginScanner                               : "create"
DefaultPluginRegistry                       "1" *-[#595959,plain]-> "scanner\n1" PluginScanner
DefaultPluginRegistry                       "1" *-[#595959,plain]-> "plugins\n*" RegisteredPlugin
DefaultRunContext                           "1" *-[#595959,plain]-> "metrics\n*" AbstractMetricEntry
DefaultRunContext                           "1" *-[#595959,plain]-> "kvStoreService\n1" KVStoreService
DefaultRunContext                           "1" *-[#595959,plain]-> "meterRegistry\n1" MetricRegistry
DefaultRunContext                            -[#000082,plain]-^  RunContext
DefaultRunContext                           "1" *-[#595959,plain]-> "logger\n1" RunContextLogger
DefaultRunContext                            -[#595959,dashed]->  Secret                                      : "create"
DefaultRunContext                           "1" *-[#595959,plain]-> "storage\n1" Storage
DefaultRunContext                           "1" *-[#595959,plain]-> "variableRenderer\n1" VariableRenderer
DefaultRunContext                           "1" *-[#595959,plain]-> "dynamicWorkerTaskResult\n*" WorkerTaskResult
DefaultRunContext                           "1" *-[#595959,plain]-> "workingDir\n1" WorkingDir
DefaultRunContextTest                        -[#595959,dashed]->  DefaultRunContext                           : "create"
Delete                                       -[#000082,plain]-^  AbstractState
Delete                                       -[#595959,dashed]->  Example                                     : "create"
Delete                                       -[#595959,dashed]->  Example                                     : "create"
Delete                                       -[#595959,dashed]->  Example                                     : "create"
Delete                                       -[#999900,dotted]-  Plugin
Delete                                       -[#999900,dotted]-  Plugin
Delete                                       -[#999900,dotted]-  Plugin
Delete                                       -[#008200,dashed]-^  RunnableTask
Delete                                       -[#008200,dashed]-^  RunnableTask
Delete                                       -[#008200,dashed]-^  RunnableTask
Delete                                       -[#000082,plain]-^  Task
Delete                                       -[#000082,plain]-^  Task
DeleteFiles                                  -[#595959,dashed]->  Example                                     : "create"
DeleteFiles                                  -[#999900,dotted]-  Plugin
DeleteFiles                                  -[#008200,dashed]-^  RunnableTask
DeleteFiles                                  -[#000082,plain]-^  Task
DeleteFilesTest                              -[#999900,dotted]-  KestraTest
DeleteFilesTest                             "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
DeleteFilesTest                             "1" *-[#595959,plain]-> "storageInterface\n1" StorageInterface
DeleteTest                                   -[#595959,dashed]->  KVValueAndMetadata                          : "create"
DeleteTest                                   -[#999900,dotted]-  KestraTest
DeleteTest                                   -[#999900,dotted]-  KestraTest
DeleteTest                                  "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
DeleteTest                                  "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
DeleteTest                                  "1" *-[#595959,plain]-> "storageInterface\n1" StorageInterface
DeprecatedTask                               -[#000082,plain]-^  SuperclassTask
DeserializationIssuesCaseTest               "1" *-[#595959,plain]-> "flowListeners\n1" FlowListenersInterface
DeserializationIssuesCaseTest               "1" *-[#595959,plain]-> "workerTaskResultQueue\n1" QueueInterface
DisabledTest                                 -[#000082,plain]-^  AbstractMemoryRunnerTest
Docker                                      "1" *-[#595959,plain]-> "cpu\n1" Cpu
Docker                                      "1" *-[#595959,plain]-> "credentials\n1" Credentials
Docker                                      "1" *-[#595959,plain]-> "deviceRequests\n*" DeviceRequest
Docker                                       -[#595959,dashed]->  Example                                     : "create"
Docker                                      "1" *-[#595959,plain]-> "memory\n1" Memory
Docker                                       -[#999900,dotted]-  Plugin
Docker                                      "1" *-[#595959,plain]-> "pullPolicy\n1" PullPolicy
Docker                                       -[#595959,dashed]->  RetryUtils                                  : "create"
Docker                                       -[#595959,dashed]->  RunnerResult                                : "create"
Docker                                       -[#595959,dashed]->  TaskException                               : "create"
Docker                                       -[#000082,plain]-^  TaskRunner
DockerOptions                               "1" *-[#595959,plain]-> "cpu\n1" Cpu
DockerOptions                               "1" *-[#595959,plain]-> "credentials\n1" Credentials
DockerOptions                               "1" *-[#595959,plain]-> "deviceRequests\n*" DeviceRequest
DockerOptions                               "1" *-[#595959,plain]-> "memory\n1" Memory
DockerOptions                               "1" *-[#595959,plain]-> "pullPolicy\n1" PullPolicy
DockerTest                                   -[#000082,plain]-^  AbstractTaskRunnerTest
DocumentationGenerator                       -[#595959,dashed]->  Document                                    : "create"
DocumentationGenerator                       -[#595959,dashed]->  Extension                                   : "create"
DocumentationGenerator                      "1" *-[#595959,plain]-> "jsonSchemaGenerator\n1" JsonSchemaGenerator
DocumentationGenerator                       -[#595959,dashed]->  JsonWriter                                  : "create"
DocumentationGenerator                       -[#595959,dashed]->  ToJsonFilter                                : "create"
DocumentationGeneratorTest                  "1" *-[#595959,plain]-> "documentationGenerator\n1" DocumentationGenerator
DocumentationGeneratorTest                  "1" *-[#595959,plain]-> "jsonSchemaGenerator\n1" JsonSchemaGenerator
DocumentationGeneratorTest                   -[#999900,dotted]-  KestraTest
DocumentationGeneratorTest                   -[#595959,dashed]->  PluginScanner                               : "create"
DocumentationWithSchema                     "1" *-[#595959,plain]-> "schema\n1" Schema
Download                                     -[#000082,plain]-^  AbstractHttp
Download                                     -[#595959,dashed]->  Example                                     : "create"
Download                                     -[#595959,dashed]->  Metric                                      : "create"
Download                                     -[#999900,dotted]-  Plugin
Download                                     -[#008200,dashed]-^  RunnableTask
DownloadFiles                                -[#595959,dashed]->  Example                                     : "create"
DownloadFiles                                -[#999900,dotted]-  Plugin
DownloadFiles                                -[#008200,dashed]-^  RunnableTask
DownloadFiles                                -[#000082,plain]-^  Task
DownloadFilesTest                            -[#999900,dotted]-  KestraTest
DownloadFilesTest                           "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
DownloadFilesTest                           "1" *-[#595959,plain]-> "storageInterface\n1" StorageInterface
DownloadTest                                 -[#999900,dotted]-  KestraTest
DownloadTest                                "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
DownloadTest                                "1" *-[#595959,plain]-> "storageInterface\n1" StorageInterface
DurationInput                                -[#000082,plain]-^  Input
DurationOrSizeTriggerTest                   "1" *-[#595959,plain]-> "trigger\n1" DurationOrSizeTrigger
DurationOrSizeTriggerTest                    -[#595959,dashed]->  DurationOrSizeTrigger                       : "create"
DynamicPropertyExampleTask                  "1" *-[#595959,plain]-> "data\n1" Data
DynamicPropertyExampleTask                   -[#999900,dotted]-  Plugin
DynamicPropertyExampleTask                  "1" *-[#595959,plain]-> "number\n1" Property
DynamicPropertyExampleTask                   -[#008200,dashed]-^  RunnableTask
DynamicPropertyExampleTask                   -[#000082,plain]-^  Task
DynamicTask                                  -[#008200,dashed]-^  RunnableTask
DynamicTask                                  -[#595959,dashed]->  State                                       : "create"
DynamicTask                                  -[#000082,plain]-^  Task
EachParallel                                 -[#595959,dashed]->  Example                                     : "create"
EachParallel                                 -[#008200,dashed]-^  FlowableTask
EachParallel                                 -[#595959,dashed]->  GraphCluster                                : "create"
EachParallel                                 -[#000082,plain]-^  Parallel
EachParallel                                 -[#999900,dotted]-  Plugin
EachParallelTest                             -[#000082,plain]-^  AbstractMemoryRunnerTest
EachSequential                               -[#595959,dashed]->  Example                                     : "create"
EachSequential                               -[#008200,dashed]-^  FlowableTask
EachSequential                               -[#595959,dashed]->  GraphCluster                                : "create"
EachSequential                               -[#999900,dotted]-  Plugin
EachSequential                               -[#000082,plain]-^  Sequential
EachSequentialTest                           -[#000082,plain]-^  AbstractMemoryRunnerTest
EachSequentialTest                          "1" *-[#595959,plain]-> "logQueue\n1" QueueInterface
Echo                                         -[#595959,dashed]->  Example                                     : "create"
Echo                                         -[#999900,dotted]-  Plugin
Echo                                         -[#008200,dashed]-^  RunnableTask
Echo                                         -[#000082,plain]-^  Task
EmptyVariablesTest                           -[#000082,plain]-^  AbstractMemoryRunnerTest
EmptyVariablesTest                          "1" *-[#595959,plain]-> "flowIO\n1" FlowInputOutput
EncryptDecryptFunctionTest                   -[#999900,dotted]-  KestraTest
EncryptDecryptFunctionTest                  "1" *-[#595959,plain]-> "variableRenderer\n1" VariableRenderer
Encrypted                                    -[#595959,dashed]->  Example                                     : "create"
Encrypted                                    -[#999900,dotted]-  Plugin
Encrypted                                    -[#008200,dashed]-^  RunnableTask
Encrypted                                    -[#000082,plain]-^  Task
EndsWithFilterTest                           -[#999900,dotted]-  KestraTest
EndsWithFilterTest                          "1" *-[#595959,plain]-> "variableRenderer\n1" VariableRenderer
EnumInput                                    -[#000082,plain]-^  Input
ErrorControllerTest                          -[#999900,dotted]-  KestraTest
EscapeCharFilterTest                         -[#999900,dotted]-  KestraTest
EscapeCharFilterTest                        "1" *-[#595959,plain]-> "variableRenderer\n1" VariableRenderer
ExecutableTask                               -[#595959,dashed]->  Output
ExecutableUtils                              -[#595959,dashed]->  State                                       : "create"
Execution                                    -[#008200,dashed]-^  DeletedInterface
Execution                                   "1" *-[#595959,plain]-> "metadata\n1" ExecutionMetadata
Execution                                   "1" *-[#595959,plain]-> "trigger\n1" ExecutionTrigger
Execution                                    -[#595959,dashed]->  InternalException                           : "create"
Execution                                   "1" *-[#595959,plain]-> "labels\n*" Label
Execution                                    -[#595959,dashed]->  State                                       : "create"
Execution                                   "1" *-[#595959,plain]-> "state\n1" State
Execution                                   "1" *-[#595959,plain]-> "taskRunList\n*" TaskRun
Execution                                    -[#008200,dashed]-^  TenantInterface
ExecutionController                         "1" *-[#595959,plain]-> "conditionService\n1" ConditionService
ExecutionController                          -[#595959,dashed]->  CrudEvent                                   : "create"
ExecutionController                         "1" *-[#595959,plain]-> "executionRepository\n1" ExecutionRepositoryInterface
ExecutionController                         "1" *-[#595959,plain]-> "executionService\n1" ExecutionService
ExecutionController                         "1" *-[#595959,plain]-> "flowInputOutput\n1" FlowInputOutput
ExecutionController                         "1" *-[#595959,plain]-> "flowRepository\n1" FlowRepositoryInterface
ExecutionController                         "1" *-[#595959,plain]-> "flowService\n1" FlowService
ExecutionController                         "1" *-[#595959,plain]-> "graphService\n1" GraphService
ExecutionController                          -[#595959,dashed]->  Label                                       : "create"
ExecutionController                         "1" *-[#595959,plain]-> "executionQueue\n1" QueueInterface
ExecutionController                         "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
ExecutionController                         "1" *-[#595959,plain]-> "storageInterface\n1" StorageInterface
ExecutionController                         "1" *-[#595959,plain]-> "tenantService\n1" TenantService
ExecutionControllerTest                     "1" *-[#595959,plain]-> "executionController\n1" ExecutionController
ExecutionControllerTest                     "1" *-[#595959,plain]-> "executionRepositoryInterface\n1" ExecutionRepositoryInterface
ExecutionControllerTest                     "1" *-[#595959,plain]-> "flowIO\n1" FlowInputOutput
ExecutionControllerTest                     "1" *-[#595959,plain]-> "flowRepositoryInterface\n1" FlowRepositoryInterface
ExecutionControllerTest                      -[#000082,plain]-^  JdbcH2ControllerTest
ExecutionControllerTest                      -[#595959,dashed]->  Label                                       : "create"
ExecutionControllerTest                     "1" *-[#595959,plain]-> "executionQueue\n1" QueueInterface
ExecutionFixture                            "1" *-[#595959,plain]-> "EXECUTION_1\n1" Execution
ExecutionFixture                             -[#595959,dashed]->  State                                       : "create"
ExecutionFlowCondition                       -[#000082,plain]-^  Condition
ExecutionFlowCondition                       -[#595959,dashed]->  Example                                     : "create"
ExecutionFlowCondition                       -[#595959,dashed]->  IllegalConditionEvaluation                  : "create"
ExecutionFlowCondition                       -[#999900,dotted]-  Plugin
ExecutionFlowConditionTest                  "1" *-[#595959,plain]-> "conditionService\n1" ConditionService
ExecutionFlowConditionTest                   -[#999900,dotted]-  KestraTest
ExecutionKilled                              -[#008200,dashed]-^  TenantInterface
ExecutionKilledExecution                     -[#000082,plain]-^  ExecutionKilled
ExecutionKilledExecution                     -[#008200,dashed]-^  TenantInterface
ExecutionKilledTrigger                       -[#000082,plain]-^  ExecutionKilled
ExecutionKilledTrigger                       -[#008200,dashed]-^  TenantInterface
ExecutionLabelsCondition                     -[#000082,plain]-^  Condition
ExecutionLabelsCondition                     -[#595959,dashed]->  Example                                     : "create"
ExecutionLabelsCondition                    "1" *-[#595959,plain]-> "labels\n*" Label
ExecutionLabelsCondition                     -[#999900,dotted]-  Plugin
ExecutionLabelsConditionTest                "1" *-[#595959,plain]-> "conditionService\n1" ConditionService
ExecutionLabelsConditionTest                 -[#999900,dotted]-  KestraTest
ExecutionLabelsConditionTest                 -[#595959,dashed]->  Label                                       : "create"
ExecutionNamespaceCondition                  -[#000082,plain]-^  Condition
ExecutionNamespaceCondition                  -[#595959,dashed]->  Example                                     : "create"
ExecutionNamespaceCondition                  -[#595959,dashed]->  IllegalConditionEvaluation                  : "create"
ExecutionNamespaceCondition                  -[#999900,dotted]-  Plugin
ExecutionNamespaceConditionTest             "1" *-[#595959,plain]-> "conditionService\n1" ConditionService
ExecutionNamespaceConditionTest              -[#999900,dotted]-  KestraTest
ExecutionOutputsCondition                    -[#000082,plain]-^  Condition
ExecutionOutputsCondition                    -[#595959,dashed]->  Example                                     : "create"
ExecutionOutputsCondition                    -[#999900,dotted]-  Plugin
ExecutionOutputsCondition                    -[#008200,dashed]-^  ScheduleCondition
ExecutionOutputsConditionTest               "1" *-[#595959,plain]-> "conditionService\n1" ConditionService
ExecutionOutputsConditionTest                -[#999900,dotted]-  KestraTest
ExecutionQueued                             "1" *-[#595959,plain]-> "execution\n1" Execution
ExecutionRepositoryInterface                 -[#008200,plain]-^  SaveRepositoryInterface
ExecutionRunning                            "1" *-[#595959,plain]-> "execution\n1" Execution
ExecutionService                             -[#595959,dashed]->  CrudEvent                                   : "create"
ExecutionService                            "1" *-[#595959,plain]-> "executionRepository\n1" ExecutionRepositoryInterface
ExecutionService                            "1" *-[#595959,plain]-> "flowInputOutput\n1" FlowInputOutput
ExecutionService                            "1" *-[#595959,plain]-> "flowRepositoryInterface\n1" FlowRepositoryInterface
ExecutionService                            "1" *-[#595959,plain]-> "logRepository\n1" LogRepositoryInterface
ExecutionService                            "1" *-[#595959,plain]-> "metricRepository\n1" MetricRepositoryInterface
ExecutionService                            "1" *-[#595959,plain]-> "executionQueue\n1" QueueInterface
ExecutionService                             -[#595959,dashed]->  State                                       : "create"
ExecutionService                            "1" *-[#595959,plain]-> "storageInterface\n1" StorageInterface
ExecutionServiceTest                         -[#000082,plain]-^  AbstractMemoryRunnerTest
ExecutionServiceTest                        "1" *-[#595959,plain]-> "executionRepository\n1" ExecutionRepositoryInterface
ExecutionServiceTest                        "1" *-[#595959,plain]-> "executionService\n1" ExecutionService
ExecutionServiceTest                        "1" *-[#595959,plain]-> "flowRepository\n1" FlowRepositoryInterface
ExecutionServiceTest                        "1" *-[#595959,plain]-> "logRepository\n1" LogRepositoryInterface
ExecutionServiceTest                        "1" *-[#595959,plain]-> "pluginDefaultService\n1" PluginDefaultService
ExecutionStatusCondition                     -[#000082,plain]-^  Condition
ExecutionStatusCondition                     -[#595959,dashed]->  Example                                     : "create"
ExecutionStatusCondition                     -[#595959,dashed]->  IllegalConditionEvaluation                  : "create"
ExecutionStatusCondition                     -[#999900,dotted]-  Plugin
ExecutionStatusConditionTest                "1" *-[#595959,plain]-> "conditionService\n1" ConditionService
ExecutionStatusConditionTest                 -[#999900,dotted]-  KestraTest
ExecutionTest                                -[#595959,dashed]->  Label                                       : "create"
ExecutionTest                                -[#595959,dashed]->  State                                       : "create"
ExecutionUsage                              "1" *-[#595959,plain]-> "dailyExecutionsCount\n*" DailyExecutionStatistics
Executor                                    "1" *-[#595959,plain]-> "execution\n1" Execution
Executor                                    "1" *-[#595959,plain]-> "executionDelays\n*" ExecutionDelay
Executor                                    "1" *-[#595959,plain]-> "executionKilled\n*" ExecutionKilledExecution
Executor                                    "1" *-[#595959,plain]-> "executionResumed\n1" ExecutionResumed
Executor                                    "1" *-[#595959,plain]-> "executionRunning\n1" ExecutionRunning
Executor                                    "1" *-[#595959,plain]-> "flow\n1" Flow
Executor                                    "1" *-[#595959,plain]-> "subflowExecutions\n*" SubflowExecution
Executor                                    "1" *-[#595959,plain]-> "subflowExecutionResults\n*" SubflowExecutionResult
Executor                                    "1" *-[#595959,plain]-> "nexts\n*" TaskRun
Executor                                    "1" *-[#595959,plain]-> "workerJobToResubmit\n1" WorkerJob
Executor                                    "1" *-[#595959,plain]-> "workerTasks\n*" WorkerTask
Executor                                    "1" *-[#595959,plain]-> "workerTaskResults\n*" WorkerTaskResult
Executor                                    "1" *-[#595959,plain]-> "workerTriggers\n*" WorkerTrigger
ExecutorCommand                              -[#000082,plain]-^  AbstractServerCommand
ExecutorCommand                             "1" *-[#595959,plain]-> "skipExecutionService\n1" SkipExecutionService
ExecutorCommand                             "1" *-[#595959,plain]-> "startExecutorService\n1" StartExecutorService
ExecutorService                             "1" *-[#595959,plain]-> "conditionService\n1" ConditionService
ExecutorService                              -[#595959,dashed]->  ExecutionRunning                            : "create"
ExecutorService                             "1" *-[#595959,plain]-> "executionService\n1" ExecutionService
ExecutorService                             "1" *-[#595959,plain]-> "flowExecutorInterface\n1" FlowExecutorInterface
ExecutorService                             "1" *-[#595959,plain]-> "flowInputOutput\n1" FlowInputOutput
ExecutorService                             "1" *-[#595959,plain]-> "logService\n1" LogService
ExecutorService                             "1" *-[#595959,plain]-> "metricRegistry\n1" MetricRegistry
ExecutorService                             "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
ExecutorService                              -[#595959,dashed]->  State                                       : "create"
ExecutorService                             "1" *-[#595959,plain]-> "workerGroupExecutorInterface\n1" WorkerGroupExecutorInterface
ExecutorService                              -[#595959,dashed]->  WorkerTaskResult                            : "create"
ExecutorsUtils                              "1" *-[#595959,plain]-> "threadFactoryBuilder\n1" ThreadMainFactoryBuilder
Exponential                                  -[#000082,plain]-^  AbstractRetry
ExpressionCondition                          -[#000082,plain]-^  Condition
ExpressionCondition                          -[#595959,dashed]->  Example                                     : "create"
ExpressionCondition                          -[#999900,dotted]-  Plugin
ExpressionCondition                          -[#008200,dashed]-^  ScheduleCondition
ExpressionConditionTest                     "1" *-[#595959,plain]-> "conditionService\n1" ConditionService
ExpressionConditionTest                      -[#999900,dotted]-  KestraTest
Extension                                    -[#595959,dashed]->  ChunkFilter                                 : "create"
Extension                                    -[#595959,dashed]->  ClassNameFilter                             : "create"
Extension                                    -[#595959,dashed]->  CurrentEachOutputFunction                   : "create"
Extension                                    -[#595959,dashed]->  DateAddFilter                               : "create"
Extension                                    -[#595959,dashed]->  DateFilter                                  : "create"
Extension                                    -[#595959,dashed]->  DecryptFunction                             : "create"
Extension                                    -[#595959,dashed]->  EncryptFunction                             : "create"
Extension                                    -[#595959,dashed]->  EndsWithFilter                              : "create"
Extension                                    -[#595959,dashed]->  EscapeCharFilter                            : "create"
Extension                                    -[#595959,dashed]->  FlattenFilter                               : "create"
Extension                                    -[#595959,dashed]->  FromIonFunction                             : "create"
Extension                                    -[#595959,dashed]->  FromJsonFunction                            : "create"
Extension                                    -[#595959,dashed]->  IndentFilter                                : "create"
Extension                                    -[#595959,dashed]->  JqFilter                                    : "create"
Extension                                    -[#595959,dashed]->  JsonFilter                                  : "create"
Extension                                    -[#595959,dashed]->  JsonFunction                                : "create"
Extension                                    -[#595959,dashed]->  JsonTest                                    : "create"
Extension                                    -[#595959,dashed]->  KeysFilter                                  : "create"
Extension                                   "1" *-[#595959,plain]-> "kvFunction\n1" KvFunction
Extension                                    -[#595959,dashed]->  NindentFilter                               : "create"
Extension                                    -[#595959,dashed]->  NowFunction                                 : "create"
Extension                                    -[#595959,dashed]->  NumberFilter                                : "create"
Extension                                    -[#595959,dashed]->  PrintContextFunction                        : "create"
Extension                                   "1" *-[#595959,plain]-> "readFileFunction\n1" ReadFileFunction
Extension                                   "1" *-[#595959,plain]-> "renderFunction\n1" RenderFunction
Extension                                   "1" *-[#595959,plain]-> "renderOnceFunction\n1" RenderOnceFunction
Extension                                   "1" *-[#595959,plain]-> "secretFunction\n1" SecretFunction
Extension                                    -[#595959,dashed]->  SlugifyFilter                               : "create"
Extension                                    -[#595959,dashed]->  StartsWithFilter                            : "create"
Extension                                    -[#595959,dashed]->  SubstringAfterFilter                        : "create"
Extension                                    -[#595959,dashed]->  SubstringAfterLastFilter                    : "create"
Extension                                    -[#595959,dashed]->  SubstringBeforeFilter                       : "create"
Extension                                    -[#595959,dashed]->  SubstringBeforeLastFilter                   : "create"
Extension                                    -[#595959,dashed]->  TimestampFilter                             : "create"
Extension                                    -[#595959,dashed]->  TimestampMicroFilter                        : "create"
Extension                                    -[#595959,dashed]->  TimestampNanoFilter                         : "create"
Extension                                    -[#595959,dashed]->  ToIonFilter                                 : "create"
Extension                                    -[#595959,dashed]->  ToJsonFilter                                : "create"
Extension                                    -[#595959,dashed]->  UrlDecoderFilter                            : "create"
Extension                                    -[#595959,dashed]->  ValuesFilter                                : "create"
Extension                                    -[#595959,dashed]->  YamlFilter                                  : "create"
Extension                                    -[#595959,dashed]->  YamlFunction                                : "create"
ExtensionCustomizer                          -[#595959,dashed]->  ReplaceFilter                               : "create"
Fail                                         -[#595959,dashed]->  Example                                     : "create"
Fail                                         -[#999900,dotted]-  Plugin
Fail                                         -[#008200,dashed]-^  RunnableTask
Fail                                         -[#000082,plain]-^  Task
FailTest                                     -[#000082,plain]-^  AbstractMemoryRunnerTest
Fetch                                        -[#595959,dashed]->  Example                                     : "create"
Fetch                                        -[#999900,dotted]-  Plugin
Fetch                                        -[#008200,dashed]-^  RunnableTask
Fetch                                        -[#000082,plain]-^  Task
FetchOutput                                  -[#008200,dashed]-^  Output
FetchTest                                    -[#000082,plain]-^  AbstractMemoryRunnerTest
FetchTest                                   "1" *-[#595959,plain]-> "flowRepository\n1" FlowRepositoryInterface
FileInput                                    -[#999900,dotted]-  FileInputValidation
FileInput                                    -[#000082,plain]-^  Input
FileRenderBuilder                            -[#595959,dashed]->  DefaultFileRender                           : "create"
FileRenderBuilder                            -[#595959,dashed]->  ImageFileRender                             : "create"
FileRenderBuilder                            -[#595959,dashed]->  IonFileRender                               : "create"
FileRenderBuilder                            -[#595959,dashed]->  PdfFileRender                               : "create"
FilesServiceTest                             -[#999900,dotted]-  KestraTest
FilesServiceTest                            "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
FilterItems                                  -[#595959,dashed]->  Example                                     : "create"
FilterItems                                  -[#595959,dashed]->  IllegalVariableEvaluationException          : "create"
FilterItems                                  -[#999900,dotted]-  Plugin
FilterItems                                  -[#008200,dashed]-^  RunnableTask
FilterItems                                  -[#000082,plain]-^  Task
FilterItemsTest                              -[#999900,dotted]-  KestraTest
FilterItemsTest                             "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
FilterItemsTest                             "1" *-[#595959,plain]-> "storageInterface\n1" StorageInterface
FlattenFilterTest                            -[#999900,dotted]-  KestraTest
FlattenFilterTest                           "1" *-[#595959,plain]-> "variableRenderer\n1" VariableRenderer
FloatInput                                   -[#000082,plain]-^  Input
Flow                                         -[#000082,plain]-^  AbstractFlow
Flow                                        "1" *-[#595959,plain]-> "retry\n1" AbstractRetry
Flow                                         -[#000082,plain]-^  AbstractTrigger
Flow                                        "1" *-[#595959,plain]-> "triggers\n*" AbstractTrigger
Flow                                        "1" *-[#595959,plain]-> "concurrency\n1" Concurrency
Flow                                         -[#999900,dotted]-  FlowValidation
Flow                                         -[#595959,dashed]->  InternalException                           : "create"
Flow                                        "1" *-[#595959,plain]-> "labels\n*" Label
Flow                                         -[#595959,dashed]->  Label                                       : "create"
Flow                                        "1" *-[#595959,plain]-> "listeners\n*" Listener
Flow                                        "1" *-[#595959,plain]-> "outputs\n*" Output
Flow                                         -[#999900,dotted]-  Plugin
Flow                                        "1" *-[#595959,plain]-> "pluginDefaults\n*" PluginDefault
Flow                                         -[#595959,dashed]->  State                                       : "create"
Flow                                        "1" *-[#595959,plain]-> "tasks\n*" Task
Flow                                         -[#008200,dashed]-^  TriggerOutput
FlowAutoLoaderService                       "1" *-[#595959,plain]-> "repository\n1" FlowRepositoryInterface
FlowAutoLoaderService                       "1" *-[#595959,plain]-> "namespaceUtils\n1" NamespaceUtils
FlowAutoLoaderService                       "1" *-[#595959,plain]-> "pluginDefaultService\n1" PluginDefaultService
FlowAutoLoaderService                        -[#999900,dotted]-  WebServerEnabled
FlowAutoLoaderService                       "1" *-[#595959,plain]-> "yamlFlowParser\n1" YamlFlowParser
FlowCaseTest                                 -[#595959,dashed]->  Label                                       : "create"
FlowCaseTest                                "1" *-[#595959,plain]-> "executionQueue\n1" QueueInterface
FlowCaseTest                                "1" *-[#595959,plain]-> "runnerUtils\n1" RunnerUtils
FlowCommand                                  -[#000082,plain]-^  AbstractCommand
FlowConcurrencyCaseTest                     "1" *-[#595959,plain]-> "flowRepository\n1" FlowRepositoryInterface
FlowConcurrencyCaseTest                     "1" *-[#595959,plain]-> "executionQueue\n1" QueueInterface
FlowConcurrencyCaseTest                     "1" *-[#595959,plain]-> "runnerUtils\n1" RunnerUtils
FlowCondition                                -[#000082,plain]-^  Condition
FlowCondition                                -[#595959,dashed]->  Example                                     : "create"
FlowCondition                                -[#999900,dotted]-  Plugin
FlowController                              "1" *-[#595959,plain]-> "flowRepository\n1" FlowRepositoryInterface
FlowController                              "1" *-[#595959,plain]-> "flowService\n1" FlowService
FlowController                              "1" *-[#595959,plain]-> "flowTopologyRepository\n1" FlowTopologyRepositoryInterface
FlowController                              "1" *-[#595959,plain]-> "flowTopologyService\n1" FlowTopologyService
FlowController                              "1" *-[#595959,plain]-> "graphService\n1" GraphService
FlowController                              "1" *-[#595959,plain]-> "modelValidator\n1" ModelValidator
FlowController                              "1" *-[#595959,plain]-> "pluginDefaultService\n1" PluginDefaultService
FlowController                              "1" *-[#595959,plain]-> "tenantService\n1" TenantService
FlowController                              "1" *-[#595959,plain]-> "yamlFlowParser\n1" YamlFlowParser
FlowControllerTest                          "1" *-[#595959,plain]-> "jdbcFlowRepository\n1" AbstractJdbcFlowRepository
FlowControllerTest                           -[#595959,dashed]->  IdWithNamespace                             : "create"
FlowControllerTest                           -[#000082,plain]-^  JdbcH2ControllerTest
FlowControllerTest                           -[#595959,dashed]->  YamlFlowParser                              : "create"
FlowDotCommand                               -[#000082,plain]-^  AbstractCommand
FlowExpandCommand                            -[#000082,plain]-^  AbstractCommand
FlowExpandCommand                           "1" *-[#595959,plain]-> "modelValidator\n1" ModelValidator
FlowExpandCommand                           "1" *-[#595959,plain]-> "yamlFlowParser\n1" YamlFlowParser
FlowExportCommand                            -[#000082,plain]-^  AbstractApiCommand
FlowForExecution                             -[#000082,plain]-^  AbstractFlow
FlowForExecution                            "1" *-[#595959,plain]-> "triggers\n*" AbstractTriggerForExecution
FlowForExecution                            "1" *-[#595959,plain]-> "tasks\n*" TaskForExecution
FlowGraph                                   "1" *-[#595959,plain]-> "nodes\n*" AbstractGraph
FlowGraphTest                                -[#000082,plain]-^  AbstractMemoryRunnerTest
FlowGraphTest                               "1" *-[#595959,plain]-> "graphService\n1" GraphService
FlowGraphTest                               "1" *-[#595959,plain]-> "runnerUtils\n1" RunnerUtils
FlowGraphTest                               "1" *-[#595959,plain]-> "triggerRepositoryInterface\n1" TriggerRepositoryInterface
FlowGraphTest                               "1" *-[#595959,plain]-> "yamlFlowParser\n1" YamlFlowParser
FlowGraphTest                                -[#595959,dashed]->  YamlFlowParser                              : "create"
FlowInputOutput                             "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
FlowInputOutput                             "1" *-[#595959,plain]-> "storageInterface\n1" StorageInterface
FlowInputOutputTest                          -[#595959,dashed]->  DependsOn                                   : "create"
FlowInputOutputTest                         "1" *-[#595959,plain]-> "DEFAULT_TEST_EXECUTION\n1" Execution
FlowInputOutputTest                         "1" *-[#595959,plain]-> "flowInputOutput\n1" FlowInputOutput
FlowInputOutputTest                          -[#595959,dashed]->  InputAndValue                               : "create"
FlowInputOutputTest                          -[#999900,dotted]-  KestraTest
FlowInputOutputTest                         "1" *-[#595959,plain]-> "storageInterface\n1" StorageInterface
FlowListeners                               "1" *-[#595959,plain]-> "flows\n*" Flow
FlowListeners                                -[#008200,dashed]-^  FlowListenersInterface
FlowListeners                               "1" *-[#595959,plain]-> "flowQueue\n1" QueueInterface
FlowListenersTest                           "1" *-[#595959,plain]-> "flowRepository\n1" FlowRepositoryInterface
FlowListenersTest                            -[#999900,dotted]-  KestraTest
FlowListenersTest                           "1" *-[#595959,plain]-> "pluginDefaultService\n1" PluginDefaultService
FlowNamespaceCommand                         -[#000082,plain]-^  AbstractCommand
FlowNamespaceCondition                       -[#000082,plain]-^  Condition
FlowNamespaceCondition                       -[#595959,dashed]->  Example                                     : "create"
FlowNamespaceCondition                       -[#999900,dotted]-  Plugin
FlowNamespaceUpdateCommand                   -[#000082,plain]-^  AbstractServiceNamespaceUpdateCommand
FlowNamespaceUpdateCommand                  "1" *-[#595959,plain]-> "yamlFlowParser\n1" YamlFlowParser
FlowNode                                     -[#008200,dashed]-^  TenantInterface
FlowOutputTest                               -[#000082,plain]-^  AbstractMemoryRunnerTest
FlowService                                 "1" *-[#595959,plain]-> "pluginDefaultService\n1" PluginDefaultService
FlowService                                 "1" *-[#595959,plain]-> "pluginRegistry\n1" PluginRegistry
FlowService                                 "1" *-[#595959,plain]-> "yamlFlowParser\n1" YamlFlowParser
FlowServiceTest                             "1" *-[#595959,plain]-> "flowRepository\n1" FlowRepositoryInterface
FlowServiceTest                             "1" *-[#595959,plain]-> "flowService\n1" FlowService
FlowServiceTest                              -[#999900,dotted]-  KestraTest
FlowTest                                     -[#000082,plain]-^  AbstractMemoryRunnerTest
FlowTest                                    "1" *-[#595959,plain]-> "flowCaseTest\n1" FlowCaseTest
FlowTest                                     -[#999900,dotted]-  KestraTest
FlowTest                                     -[#999900,dotted]-  KestraTest
FlowTest                                     -[#595959,dashed]->  Label                                       : "create"
FlowTest                                    "1" *-[#595959,plain]-> "modelValidator\n1" ModelValidator
FlowTest                                    "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
FlowTest                                    "1" *-[#595959,plain]-> "yamlFlowParser\n1" YamlFlowParser
FlowTest                                     -[#595959,dashed]->  YamlFlowParser                              : "create"
FlowTestCommand                              -[#000082,plain]-^  AbstractCommand
FlowTopology                                "1" *-[#595959,plain]-> "source\n1" FlowNode
FlowTopology                                "1" *-[#595959,plain]-> "relation\n1" FlowRelation
FlowTopologyGraph                           "1" *-[#595959,plain]-> "nodes\n*" FlowNode
FlowTopologyService                         "1" *-[#595959,plain]-> "conditionService\n1" ConditionService
FlowTopologyService                         "1" *-[#595959,plain]-> "flowRepository\n1" FlowRepositoryInterface
FlowTopologyService                         "1" *-[#595959,plain]-> "flowTopologyRepository\n1" FlowTopologyRepositoryInterface
FlowTopologyService                          -[#595959,dashed]->  Graph                                       : "create"
FlowTopologyServiceTest                     "1" *-[#595959,plain]-> "flowTopologyService\n1" FlowTopologyService
FlowTopologyServiceTest                      -[#999900,dotted]-  KestraTest
FlowTopologyServiceTest                     "1" *-[#595959,plain]-> "yamlFlowParser\n1" YamlFlowParser
FlowTopologyServiceTest                      -[#595959,dashed]->  YamlFlowParser                              : "create"
FlowTriggerCaseTest                         "1" *-[#595959,plain]-> "executionQueue\n1" QueueInterface
FlowTriggerCaseTest                         "1" *-[#595959,plain]-> "runnerUtils\n1" RunnerUtils
FlowTriggerService                          "1" *-[#595959,plain]-> "conditionService\n1" ConditionService
FlowTriggerService                          "1" *-[#595959,plain]-> "flowService\n1" FlowService
FlowTriggerService                          "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
FlowValidateCommand                          -[#000082,plain]-^  AbstractValidateCommand
FlowValidateCommand                         "1" *-[#595959,plain]-> "flowService\n1" FlowService
FlowValidateCommand                         "1" *-[#595959,plain]-> "modelValidator\n1" ModelValidator
FlowValidateCommand                         "1" *-[#595959,plain]-> "yamlFlowParser\n1" YamlFlowParser
FlowValidationTest                           -[#999900,dotted]-  KestraTest
FlowValidationTest                          "1" *-[#595959,plain]-> "modelValidator\n1" ModelValidator
FlowValidationTest                           -[#595959,dashed]->  YamlFlowParser                              : "create"
FlowValidationTest                          "1" *-[#595959,plain]-> "yamlFlowParser\n1" YamlFlowParser
FlowWithException                            -[#000082,plain]-^  FlowWithSource
FlowWithSource                               -[#000082,plain]-^  Flow
FlowWithSourceTest                           -[#595959,dashed]->  Label                                       : "create"
FlowableTask                                 -[#595959,dashed]->  Output
FlowableUtils                                -[#595959,dashed]->  IllegalVariableEvaluationException          : "create"
ForEach                                      -[#595959,dashed]->  Example                                     : "create"
ForEach                                      -[#008200,dashed]-^  FlowableTask
ForEach                                      -[#595959,dashed]->  GraphCluster                                : "create"
ForEach                                      -[#999900,dotted]-  Plugin
ForEach                                      -[#000082,plain]-^  Sequential
ForEachItem                                  -[#008200,dashed]-^  ChildFlowInterface
ForEachItem                                  -[#595959,dashed]->  Example                                     : "create"
ForEachItem                                  -[#008200,dashed]-^  FlowableTask
ForEachItem                                  -[#595959,dashed]->  GraphCluster                                : "create"
ForEachItem                                  -[#999900,dotted]-  Plugin
ForEachItem                                 "1" *-[#595959,plain]-> "scheduleDate\n1" Property
ForEachItem                                  -[#000082,plain]-^  Task
ForEachItem                                 "1" *-[#595959,plain]-> "errors\n*" Task
ForEachItemCaseTest                         "1" *-[#595959,plain]-> "flowIO\n1" FlowInputOutput
ForEachItemCaseTest                         "1" *-[#595959,plain]-> "executionQueue\n1" QueueInterface
ForEachItemCaseTest                         "1" *-[#595959,plain]-> "runnerUtils\n1" RunnerUtils
ForEachItemCaseTest                         "1" *-[#595959,plain]-> "storageInterface\n1" StorageInterface
ForEachTest                                  -[#000082,plain]-^  AbstractMemoryRunnerTest
FromIonFunctionTest                          -[#999900,dotted]-  KestraTest
FromIonFunctionTest                         "1" *-[#595959,plain]-> "variableRenderer\n1" VariableRenderer
FromJsonFunctionTest                         -[#999900,dotted]-  KestraTest
FromJsonFunctionTest                        "1" *-[#595959,plain]-> "variableRenderer\n1" VariableRenderer
Get                                          -[#000082,plain]-^  AbstractState
Get                                          -[#595959,dashed]->  Example                                     : "create"
Get                                          -[#595959,dashed]->  Example                                     : "create"
Get                                          -[#999900,dotted]-  Plugin
Get                                          -[#999900,dotted]-  Plugin
Get                                          -[#008200,dashed]-^  RunnableTask
Get                                          -[#008200,dashed]-^  RunnableTask
Get                                          -[#000082,plain]-^  Task
GetKeys                                      -[#595959,dashed]->  Example                                     : "create"
GetKeys                                      -[#999900,dotted]-  Plugin
GetKeys                                      -[#008200,dashed]-^  RunnableTask
GetKeys                                      -[#000082,plain]-^  Task
GetKeysTest                                  -[#595959,dashed]->  KVValueAndMetadata                          : "create"
GetKeysTest                                  -[#999900,dotted]-  KestraTest
GetKeysTest                                 "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
GetTest                                      -[#595959,dashed]->  KVValueAndMetadata                          : "create"
GetTest                                      -[#999900,dotted]-  KestraTest
GetTest                                     "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
GlobalTagsConfigurer                        "1" *-[#595959,plain]-> "metricConfig\n1" MetricConfig
GraphCluster                                 -[#000082,plain]-^  AbstractGraph
GraphCluster                                "1" *-[#595959,plain]-> "taskNode\n1" AbstractGraphTask
GraphCluster                                 -[#595959,dashed]->  Graph                                       : "create"
GraphCluster                                "1" *-[#595959,plain]-> "graph\n1" Graph
GraphCluster                                 -[#595959,dashed]->  GraphClusterEnd                             : "create"
GraphCluster                                "1" *-[#595959,plain]-> "end\n1" GraphClusterEnd
GraphCluster                                "1" *-[#595959,plain]-> "root\n1" GraphClusterRoot
GraphCluster                                 -[#595959,dashed]->  GraphClusterRoot                            : "create"
GraphCluster                                 -[#595959,dashed]->  GraphTask                                   : "create"
GraphCluster                                 -[#595959,dashed]->  Relation                                    : "create"
GraphCluster                                "1" *-[#595959,plain]-> "relationType\n1" RelationType
GraphClusterEnd                              -[#000082,plain]-^  AbstractGraph
GraphClusterRoot                             -[#000082,plain]-^  AbstractGraph
GraphService                                "1" *-[#595959,plain]-> "flowRepository\n1" FlowRepositoryInterface
GraphService                                "1" *-[#595959,plain]-> "pluginDefaultService\n1" PluginDefaultService
GraphService                                "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
GraphService                                 -[#595959,dashed]->  SubflowGraphCluster                         : "create"
GraphService                                "1" *-[#595959,plain]-> "triggerRepository\n1" TriggerRepositoryInterface
GraphTask                                    -[#000082,plain]-^  AbstractGraphTask
GraphTrigger                                 -[#000082,plain]-^  AbstractGraphTrigger
GraphUtils                                   -[#595959,dashed]->  GraphCluster                                : "create"
GraphUtils                                   -[#595959,dashed]->  GraphTask                                   : "create"
GraphUtils                                   -[#595959,dashed]->  GraphTrigger                                : "create"
GraphUtils                                   -[#595959,dashed]->  Relation                                    : "create"
GraphUtils                                   -[#595959,dashed]->  SubflowGraphTask                            : "create"
H2ExecutionDelayStorage                      -[#000082,plain]-^  AbstractJdbcExecutionDelayStorage
H2ExecutionDelayStorage                      -[#999900,dotted]-  H2QueueEnabled
H2ExecutionQueuedStorage                     -[#000082,plain]-^  AbstractJdbcExecutionQueuedStorage
H2ExecutionQueuedStorage                     -[#999900,dotted]-  H2QueueEnabled
H2ExecutionRepository                        -[#000082,plain]-^  AbstractJdbcExecutionRepository
H2ExecutionRepository                        -[#999900,dotted]-  H2RepositoryEnabled
H2ExecutionRepositoryTest                    -[#000082,plain]-^  AbstractJdbcExecutionRepositoryTest
H2ExecutionServiceTest                       -[#000082,plain]-^  AbstractExecutionServiceTest
H2ExecutionServiceTest                      "1" *-[#595959,plain]-> "jdbcTestUtils\n1" JdbcTestUtils
H2ExecutorStateStorage                       -[#000082,plain]-^  AbstractJdbcExecutorStateStorage
H2ExecutorStateStorage                       -[#999900,dotted]-  H2QueueEnabled
H2FlowListenersTest                          -[#595959,dashed]->  FlowListeners                               : "create"
H2FlowListenersTest                          -[#000082,plain]-^  FlowListenersTest
H2FlowListenersTest                         "1" *-[#595959,plain]-> "flowRepository\n1" FlowRepositoryInterface
H2FlowListenersTest                         "1" *-[#595959,plain]-> "jdbcTestUtils\n1" JdbcTestUtils
H2FlowListenersTest                         "1" *-[#595959,plain]-> "dslContextWrapper\n1" JooqDSLContextWrapper
H2FlowListenersTest                         "1" *-[#595959,plain]-> "flowQueue\n1" QueueInterface
H2FlowRepository                             -[#000082,plain]-^  AbstractJdbcFlowRepository
H2FlowRepository                             -[#999900,dotted]-  H2RepositoryEnabled
H2FlowRepositoryTest                         -[#000082,plain]-^  AbstractJdbcFlowRepositoryTest
H2FlowTopologyRepository                     -[#000082,plain]-^  AbstractJdbcFlowTopologyRepository
H2FlowTopologyRepository                     -[#999900,dotted]-  H2RepositoryEnabled
H2FlowTopologyRepositoryTest                 -[#000082,plain]-^  AbstractJdbcFlowTopologyRepositoryTest
H2JdbcDeserializationIssuesTest              -[#000082,plain]-^  AbstractJdbcDeserializationIssuesTest
H2JdbcTestUtils                              -[#000082,plain]-^  JdbcTestUtils
H2LogRepository                              -[#000082,plain]-^  AbstractJdbcLogRepository
H2LogRepository                              -[#999900,dotted]-  H2RepositoryEnabled
H2LogRepositoryTest                          -[#000082,plain]-^  AbstractJdbcLogRepositoryTest
H2MetricRepository                           -[#000082,plain]-^  AbstractJdbcMetricRepository
H2MetricRepository                           -[#999900,dotted]-  H2RepositoryEnabled
H2MetricRepositoryTest                       -[#000082,plain]-^  AbstractJdbcMetricRepositoryTest
H2MultipleConditionStorage                   -[#000082,plain]-^  AbstractJdbcMultipleConditionStorage
H2MultipleConditionStorage                   -[#999900,dotted]-  H2QueueEnabled
H2MultipleConditionStorageTest               -[#000082,plain]-^  AbstractMultipleConditionStorageTest
H2MultipleConditionStorageTest               -[#595959,dashed]->  H2MultipleConditionStorage                  : "create"
H2MultipleConditionStorageTest              "1" *-[#595959,plain]-> "repository\n1" H2Repository
H2MultipleConditionStorageTest              "1" *-[#595959,plain]-> "jdbcTestUtils\n1" JdbcTestUtils
H2Queue                                      -[#000082,plain]-^  JdbcQueue
H2QueueFactory                               -[#595959,dashed]->  H2Queue                                     : "create"
H2QueueFactory                               -[#999900,dotted]-  H2QueueEnabled
H2QueueFactory                               -[#595959,dashed]->  H2WorkerJobQueue                            : "create"
H2QueueFactory                               -[#595959,dashed]->  H2WorkerTriggerResultQueue                  : "create"
H2QueueFactory                               -[#008200,dashed]-^  QueueFactoryInterface
H2QueueTest                                  -[#000082,plain]-^  JdbcQueueTest
H2Repository                                 -[#000082,plain]-^  AbstractJdbcRepository
H2Repository                                 -[#595959,dashed]->  ArrayListTotal                              : "create"
H2Repository                                 -[#999900,dotted]-  H2RepositoryEnabled
H2RunnerRetryTest                            -[#000082,plain]-^  JdbcRunnerRetryTest
H2RunnerTest                                 -[#000082,plain]-^  JdbcRunnerTest
H2SchedulerScheduleTest                      -[#595959,dashed]->  JdbcScheduler                               : "create"
H2SchedulerScheduleTest                      -[#000082,plain]-^  SchedulerScheduleTest
H2ServiceInstanceRepository                  -[#000082,plain]-^  AbstractJdbcServiceInstanceRepository
H2ServiceInstanceRepository                  -[#999900,dotted]-  H2RepositoryEnabled
H2ServiceInstanceRepositoryTest              -[#000082,plain]-^  AbstractJdbcServiceInstanceRepositoryTest
H2ServiceLivenessCoordinatorTest             -[#000082,plain]-^  JdbcServiceLivenessCoordinatorTest
H2SettingRepository                          -[#000082,plain]-^  AbstractJdbcSettingRepository
H2SettingRepository                          -[#999900,dotted]-  H2RepositoryEnabled
H2SettingRepositoryTest                      -[#000082,plain]-^  AbstractJdbcSettingRepositoryTest
H2SubflowExecutionStorage                    -[#000082,plain]-^  AbstractJdbcSubflowExecutionStorage
H2SubflowExecutionStorage                    -[#999900,dotted]-  H2QueueEnabled
H2SubflowExecutionStorageTest                -[#000082,plain]-^  AbstractSubflowExecutionTest
H2TemplateRepository                         -[#000082,plain]-^  AbstractJdbcTemplateRepository
H2TemplateRepository                         -[#999900,dotted]-  H2RepositoryEnabled
H2TemplateRepository                         -[#999900,dotted]-  TemplateEnabled
H2TemplateRepositoryTest                     -[#000082,plain]-^  AbstractJdbcTemplateRepositoryTest
H2TemplateRunnerTest                         -[#000082,plain]-^  JdbcTemplateRunnerTest
H2TriggerRepository                          -[#000082,plain]-^  AbstractJdbcTriggerRepository
H2TriggerRepository                          -[#999900,dotted]-  H2RepositoryEnabled
H2TriggerRepositoryTest                      -[#000082,plain]-^  AbstractJdbcTriggerRepositoryTest
H2WorkerJobQueue                            "1" *-[#595959,plain]-> "jdbcWorkerJobQueueService\n1" JdbcWorkerJobQueueService
H2WorkerJobQueue                             -[#008200,dashed]-^  WorkerJobQueueInterface
H2WorkerJobRunningRepository                 -[#000082,plain]-^  AbstractJdbcWorkerJobRunningRepository
H2WorkerJobRunningRepository                 -[#999900,dotted]-  H2RepositoryEnabled
H2WorkerTriggerResultQueue                   -[#000082,plain]-^  H2Queue
H2WorkerTriggerResultQueue                  "1" *-[#595959,plain]-> "jdbcWorkerTriggerResultQueueService\n1" JdbcWorkerTriggerResultQueueService
H2WorkerTriggerResultQueue                   -[#008200,dashed]-^  WorkerTriggerResultQueueInterface
HasRetryAttemptCondition                     -[#000082,plain]-^  Condition
HasRetryAttemptCondition                     -[#595959,dashed]->  Example                                     : "create"
HasRetryAttemptCondition                     -[#595959,dashed]->  IllegalConditionEvaluation                  : "create"
HasRetryAttemptCondition                     -[#999900,dotted]-  Plugin
HasRetryAttemptConditionTest                "1" *-[#595959,plain]-> "conditionService\n1" ConditionService
HasRetryAttemptConditionTest                 -[#999900,dotted]-  KestraTest
HasRetryAttemptConditionTest                 -[#595959,dashed]->  State                                       : "create"
If                                           -[#595959,dashed]->  Example                                     : "create"
If                                           -[#008200,dashed]-^  FlowableTask
If                                           -[#595959,dashed]->  GraphCluster                                : "create"
If                                           -[#999900,dotted]-  Plugin
If                                           -[#000082,plain]-^  Task
If                                          "1" *-[#595959,plain]-> "then\n*" Task
IfTest                                       -[#000082,plain]-^  AbstractMemoryRunnerTest
IllegalConditionEvaluation                   -[#000082,plain]-^  InternalException
IllegalVariableEvaluationException           -[#000082,plain]-^  InternalException
ImageFileRender                              -[#000082,plain]-^  Base64Render
IndentFilter                                 -[#000082,plain]-^  AbstractIndent
IndentFilterTest                             -[#999900,dotted]-  KestraTest
IndentFilterTest                            "1" *-[#595959,plain]-> "variableRenderer\n1" VariableRenderer
Indexer                                     "1" *-[#595959,plain]-> "executionRepository\n1" ExecutionRepositoryInterface
Indexer                                      -[#008200,dashed]-^  IndexerInterface
Indexer                                     "1" *-[#595959,plain]-> "logRepository\n1" LogRepositoryInterface
Indexer                                     "1" *-[#595959,plain]-> "metricRegistry\n1" MetricRegistry
Indexer                                     "1" *-[#595959,plain]-> "metricRepository\n1" MetricRepositoryInterface
Indexer                                     "1" *-[#595959,plain]-> "executionQueue\n1" QueueInterface
Indexer                                      -[#595959,dashed]->  ServiceStateChangeEvent                     : "create"
IndexerCommand                               -[#000082,plain]-^  AbstractServerCommand
IndexerInterface                             -[#008200,plain]-^  Service
Input                                        -[#008200,dashed]-^  Data
Input                                       "1" *-[#595959,plain]-> "dependsOn\n1" DependsOn
Input                                       "1" *-[#595959,plain]-> "type\n1" Type
InputAndValue                               "1" *-[#595959,plain]-> "input\n1" Input
InputTest                                    -[#999900,dotted]-  KestraTest
InputTest                                   "1" *-[#595959,plain]-> "modelValidator\n1" ModelValidator
InputsTest                                   -[#000082,plain]-^  AbstractMemoryRunnerTest
InputsTest                                  "1" *-[#595959,plain]-> "flowIO\n1" FlowInputOutput
InputsTest                                  "1" *-[#595959,plain]-> "flowRepository\n1" FlowRepositoryInterface
InputsTest                                  "1" *-[#595959,plain]-> "storageInterface\n1" StorageInterface
InstanceService                             "1" *-[#595959,plain]-> "instanceIdSetting\n1" Setting
InstanceService                             "1" *-[#595959,plain]-> "settingRepository\n1" SettingRepositoryInterface
IntInput                                     -[#000082,plain]-^  Input
InternalKVStore                              -[#008200,dashed]-^  KVStore
InternalKVStore                              -[#595959,dashed]->  KVStoreException                            : "create"
InternalKVStore                              -[#595959,dashed]->  KVValue                                     : "create"
InternalKVStore                              -[#595959,dashed]->  ResourceExpiredException                    : "create"
InternalKVStore                             "1" *-[#595959,plain]-> "storage\n1" StorageInterface
InternalKVStore                              -[#595959,dashed]->  StorageObject                               : "create"
InternalKVStoreTest                          -[#595959,dashed]->  InternalKVStore                             : "create"
InternalKVStoreTest                          -[#595959,dashed]->  KVMetadata                                  : "create"
InternalKVStoreTest                          -[#595959,dashed]->  KVValue                                     : "create"
InternalKVStoreTest                          -[#595959,dashed]->  KVValueAndMetadata                          : "create"
InternalKVStoreTest                         "1" *-[#595959,plain]-> "storageInterface\n1" LocalStorage
InternalKVStoreTest                          -[#595959,dashed]->  LocalStorage                                : "create"
InternalNamespace                            -[#008200,dashed]-^  Namespace
InternalNamespace                            -[#595959,dashed]->  NamespaceFile                               : "create"
InternalNamespace                           "1" *-[#595959,plain]-> "storage\n1" StorageInterface
InternalNamespaceTest                        -[#595959,dashed]->  InternalNamespace                           : "create"
InternalNamespaceTest                       "1" *-[#595959,plain]-> "storageInterface\n1" LocalStorage
InternalNamespaceTest                        -[#595959,dashed]->  LocalStorage                                : "create"
InternalStorage                             "1" *-[#595959,plain]-> "flowService\n1" FlowService
InternalStorage                              -[#595959,dashed]->  InternalNamespace                           : "create"
InternalStorage                              -[#008200,dashed]-^  Storage
InternalStorage                             "1" *-[#595959,plain]-> "context\n1" StorageContext
InternalStorage                             "1" *-[#595959,plain]-> "storage\n1" StorageInterface
InvalidException                             -[#000082,plain]-^  KestraRuntimeException
IonFactory                                   -[#595959,dashed]->  IonGenerator                                : "create"
IonFactory                                   -[#595959,dashed]->  IonParser                                   : "create"
IonFileRender                                -[#000082,plain]-^  FileRender
IonFileRenderTest                            -[#595959,dashed]->  IonFileRender                               : "create"
JacksonMapper                                -[#595959,dashed]->  IonFactory                                  : "create"
JacksonMapper                                -[#595959,dashed]->  IonModule                                   : "create"
JacksonMapper                                -[#595959,dashed]->  PluginModule                                : "create"
JacksonMapper                                -[#595959,dashed]->  RunContextModule                            : "create"
JdbcCleaner                                  -[#999900,dotted]-  JdbcRunnerEnabled
JdbcCleaner                                 "1" *-[#595959,plain]-> "dslContextWrapper\n1" JooqDSLContextWrapper
JdbcExecutor                                "1" *-[#595959,plain]-> "executionDelayStorage\n1" AbstractJdbcExecutionDelayStorage
JdbcExecutor                                "1" *-[#595959,plain]-> "executionQueuedStorage\n1" AbstractJdbcExecutionQueuedStorage
JdbcExecutor                                "1" *-[#595959,plain]-> "executionRepository\n1" AbstractJdbcExecutionRepository
JdbcExecutor                                "1" *-[#595959,plain]-> "executorStateStorage\n1" AbstractJdbcExecutorStateStorage
JdbcExecutor                                "1" *-[#595959,plain]-> "flowTopologyRepository\n1" AbstractJdbcFlowTopologyRepository
JdbcExecutor                                "1" *-[#595959,plain]-> "subflowExecutionStorage\n1" AbstractJdbcSubflowExecutionStorage
JdbcExecutor                                "1" *-[#595959,plain]-> "workerJobRunningRepository\n1" AbstractJdbcWorkerJobRunningRepository
JdbcExecutor                                "1" *-[#595959,plain]-> "conditionService\n1" ConditionService
JdbcExecutor                                "1" *-[#595959,plain]-> "executionService\n1" ExecutionService
JdbcExecutor                                 -[#595959,dashed]->  Executor                                    : "create"
JdbcExecutor                                 -[#008200,dashed]-^  ExecutorInterface
JdbcExecutor                                "1" *-[#595959,plain]-> "executorService\n1" ExecutorService
JdbcExecutor                                "1" *-[#595959,plain]-> "allFlows\n*" Flow
JdbcExecutor                                 -[#595959,dashed]->  Flow                                        : "create"
JdbcExecutor                                "1" *-[#595959,plain]-> "flowListeners\n1" FlowListenersInterface
JdbcExecutor                                "1" *-[#595959,plain]-> "flowRepository\n1" FlowRepositoryInterface
JdbcExecutor                                "1" *-[#595959,plain]-> "flowTopologyService\n1" FlowTopologyService
JdbcExecutor                                "1" *-[#595959,plain]-> "flowTriggerService\n1" FlowTriggerService
JdbcExecutor                                 -[#999900,dotted]-  JdbcRunnerEnabled
JdbcExecutor                                "1" *-[#595959,plain]-> "serviceLivenessCoordinator\n1" JdbcServiceLivenessCoordinator
JdbcExecutor                                "1" *-[#595959,plain]-> "logService\n1" LogService
JdbcExecutor                                "1" *-[#595959,plain]-> "metricRegistry\n1" MetricRegistry
JdbcExecutor                                "1" *-[#595959,plain]-> "multipleConditionStorage\n1" MultipleConditionStorageInterface
JdbcExecutor                                "1" *-[#595959,plain]-> "pluginDefaultService\n1" PluginDefaultService
JdbcExecutor                                "1" *-[#595959,plain]-> "executionQueue\n1" QueueInterface
JdbcExecutor                                "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
JdbcExecutor                                 -[#008200,dashed]-^  Service
JdbcExecutor                                 -[#595959,dashed]->  ServiceStateChangeEvent                     : "create"
JdbcExecutor                                "1" *-[#595959,plain]-> "skipExecutionService\n1" SkipExecutionService
JdbcExecutor                                 -[#595959,dashed]->  State                                       : "create"
JdbcExecutor                                "1" *-[#595959,plain]-> "workerGroupService\n1" WorkerGroupService
JdbcExecutor                                 -[#595959,dashed]->  WorkerTaskResult                            : "create"
JdbcH2ControllerTest                        "1" *-[#595959,plain]-> "jdbcTestUtils\n1" JdbcTestUtils
JdbcH2ControllerTest                         -[#999900,dotted]-  KestraTest
JdbcH2ControllerTest                        "1" *-[#595959,plain]-> "repositoryLoader\n1" LocalFlowRepositoryLoader
JdbcH2ControllerTest                        "1" *-[#595959,plain]-> "runnerUtils\n1" RunnerUtils
JdbcH2ControllerTest                        "1" *-[#595959,plain]-> "runner\n1" StandAloneRunner
JdbcIndexer                                  -[#008200,dashed]-^  IndexerInterface
JdbcIndexer                                  -[#999900,dotted]-  JdbcRunnerEnabled
JdbcQueue                                    -[#595959,dashed]->  DeserializationException                    : "create"
JdbcQueue                                   "1" *-[#595959,plain]-> "jdbcQueueIndexer\n1" JdbcQueueIndexer
JdbcQueue                                   "1" *-[#595959,plain]-> "dslContextWrapper\n1" JooqDSLContextWrapper
JdbcQueue                                   "1" *-[#595959,plain]-> "messageProtectionConfiguration\n1" MessageProtectionConfiguration
JdbcQueue                                    -[#595959,dashed]->  MessageTooBigException                      : "create"
JdbcQueue                                    -[#595959,dashed]->  QueueException                              : "create"
JdbcQueue                                    -[#008200,dashed]-^  QueueInterface
JdbcQueue                                   "1" *-[#595959,plain]-> "queueService\n1" QueueService
JdbcQueueIndexer                            "1" *-[#595959,plain]-> "repositories\n*" JdbcIndexerInterface
JdbcQueueIndexer                            "1" *-[#595959,plain]-> "metricRegistry\n1" MetricRegistry
JdbcQueueTest                               "1" *-[#595959,plain]-> "jdbcTestUtils\n1" JdbcTestUtils
JdbcQueueTest                                -[#999900,dotted]-  KestraTest
JdbcQueueTest                               "1" *-[#595959,plain]-> "flowQueue\n1" QueueInterface
JdbcRunnerRetryTest                         "1" *-[#595959,plain]-> "jdbcTestUtils\n1" JdbcTestUtils
JdbcRunnerRetryTest                          -[#999900,dotted]-  KestraTest
JdbcRunnerRetryTest                         "1" *-[#595959,plain]-> "repositoryLoader\n1" LocalFlowRepositoryLoader
JdbcRunnerRetryTest                         "1" *-[#595959,plain]-> "retryCaseTest\n1" RetryCaseTest
JdbcRunnerRetryTest                         "1" *-[#595959,plain]-> "runnerUtils\n1" RunnerUtils
JdbcRunnerRetryTest                         "1" *-[#595959,plain]-> "runner\n1" StandAloneRunner
JdbcRunnerTest                              "1" *-[#595959,plain]-> "flowCaseTest\n1" FlowCaseTest
JdbcRunnerTest                              "1" *-[#595959,plain]-> "flowConcurrencyCaseTest\n1" FlowConcurrencyCaseTest
JdbcRunnerTest                              "1" *-[#595959,plain]-> "flowIO\n1" FlowInputOutput
JdbcRunnerTest                              "1" *-[#595959,plain]-> "flowTriggerCaseTest\n1" FlowTriggerCaseTest
JdbcRunnerTest                              "1" *-[#595959,plain]-> "forEachItemCaseTest\n1" ForEachItemCaseTest
JdbcRunnerTest                              "1" *-[#595959,plain]-> "jdbcTestUtils\n1" JdbcTestUtils
JdbcRunnerTest                               -[#999900,dotted]-  KestraTest
JdbcRunnerTest                              "1" *-[#595959,plain]-> "repositoryLoader\n1" LocalFlowRepositoryLoader
JdbcRunnerTest                              "1" *-[#595959,plain]-> "multipleConditionTriggerCaseTest\n1" MultipleConditionTriggerCaseTest
JdbcRunnerTest                              "1" *-[#595959,plain]-> "pluginDefaultsCaseTest\n1" PluginDefaultsCaseTest
JdbcRunnerTest                              "1" *-[#595959,plain]-> "logsQueue\n1" QueueInterface
JdbcRunnerTest                              "1" *-[#595959,plain]-> "restartCaseTest\n1" RestartCaseTest
JdbcRunnerTest                              "1" *-[#595959,plain]-> "runnerUtils\n1" RunnerUtils
JdbcRunnerTest                              "1" *-[#595959,plain]-> "scheduleDateCaseTest\n1" ScheduleDateCaseTest
JdbcRunnerTest                              "1" *-[#595959,plain]-> "skipExecutionCaseTest\n1" SkipExecutionCaseTest
JdbcRunnerTest                              "1" *-[#595959,plain]-> "runner\n1" StandAloneRunner
JdbcRunnerTest                              "1" *-[#595959,plain]-> "waitForTestCaseTest\n1" WaitForCaseTest
JdbcScheduler                                -[#000082,plain]-^  AbstractScheduler
JdbcScheduler                               "1" *-[#595959,plain]-> "conditionService\n1" ConditionService
JdbcScheduler                               "1" *-[#595959,plain]-> "flowRepository\n1" FlowRepositoryInterface
JdbcScheduler                                -[#999900,dotted]-  JdbcRunnerEnabled
JdbcScheduler                                -[#595959,dashed]->  JdbcSchedulerContext                        : "create"
JdbcScheduler                               "1" *-[#595959,plain]-> "dslContextWrapper\n1" JooqDSLContextWrapper
JdbcScheduler                               "1" *-[#595959,plain]-> "executionQueue\n1" QueueInterface
JdbcScheduler                               "1" *-[#595959,plain]-> "triggerRepository\n1" TriggerRepositoryInterface
JdbcSchedulerContext                        "1" *-[#595959,plain]-> "dslContextWrapper\n1" JooqDSLContextWrapper
JdbcSchedulerContext                         -[#008200,dashed]-^  ScheduleContextInterface
JdbcSchedulerTriggerState                   "1" *-[#595959,plain]-> "triggerRepository\n1" AbstractJdbcTriggerRepository
JdbcSchedulerTriggerState                    -[#999900,dotted]-  JdbcRunnerEnabled
JdbcSchedulerTriggerState                    -[#008200,dashed]-^  SchedulerTriggerStateInterface
JdbcServiceLivenessCoordinator              "1" *-[#595959,plain]-> "serviceInstanceRepository\n1" AbstractJdbcServiceInstanceRepository
JdbcServiceLivenessCoordinator               -[#000082,plain]-^  AbstractServiceLivenessCoordinator
JdbcServiceLivenessCoordinator               -[#999900,dotted]-  JdbcRunnerEnabled
JdbcServiceLivenessCoordinatorTest          "1" *-[#595959,plain]-> "jdbcServiceLivenessHandler\n1" JdbcServiceLivenessCoordinator
JdbcServiceLivenessCoordinatorTest          "1" *-[#595959,plain]-> "jdbcTestUtils\n1" JdbcTestUtils
JdbcServiceLivenessCoordinatorTest           -[#999900,dotted]-  KestraTest
JdbcServiceLivenessCoordinatorTest          "1" *-[#595959,plain]-> "repositoryLoader\n1" LocalFlowRepositoryLoader
JdbcServiceLivenessCoordinatorTest          "1" *-[#595959,plain]-> "workerJobQueue\n1" QueueInterface
JdbcServiceLivenessCoordinatorTest          "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
JdbcServiceLivenessCoordinatorTest          "1" *-[#595959,plain]-> "skipExecutionService\n1" SkipExecutionService
JdbcServiceLivenessCoordinatorTest          "1" *-[#595959,plain]-> "runner\n1" StandAloneRunner
JdbcServiceLivenessManager                   -[#999900,dotted]-  JdbcRepositoryEnabled
JdbcServiceLivenessManager                   -[#999900,dotted]-  JdbcRunnerEnabled
JdbcServiceLivenessManager                   -[#000082,plain]-^  ServiceLivenessManager
JdbcServiceLivenessManagerTest              "1" *-[#595959,plain]-> "serviceLivenessManager\n1" JdbcServiceLivenessManager
JdbcServiceLivenessManagerTest               -[#595959,dashed]->  JdbcServiceLivenessManager                  : "create"
JdbcServiceLivenessManagerTest              "1" *-[#595959,plain]-> "context\n1" KestraContext
JdbcServiceLivenessManagerTest               -[#595959,dashed]->  LocalServiceStateFactory                    : "create"
JdbcServiceLivenessManagerTest               -[#595959,dashed]->  ServerConfig                                : "create"
JdbcServiceLivenessManagerTest               -[#595959,dashed]->  ServerInstanceFactory                       : "create"
JdbcServiceLivenessManagerTest              "1" *-[#595959,plain]-> "repository\n1" ServiceInstanceRepositoryInterface
JdbcServiceLivenessManagerTest               -[#595959,dashed]->  ServiceRegistry                             : "create"
JdbcTableConfigs                            "1" *-[#595959,plain]-> "tableConfigs\n*" JdbcTableConfig
JdbcTemplateRunnerTest                      "1" *-[#595959,plain]-> "flowIO\n1" FlowInputOutput
JdbcTemplateRunnerTest                      "1" *-[#595959,plain]-> "jdbcTestUtils\n1" JdbcTestUtils
JdbcTemplateRunnerTest                       -[#999900,dotted]-  KestraTest
JdbcTemplateRunnerTest                      "1" *-[#595959,plain]-> "repositoryLoader\n1" LocalFlowRepositoryLoader
JdbcTemplateRunnerTest                      "1" *-[#595959,plain]-> "logsQueue\n1" QueueInterface
JdbcTemplateRunnerTest                      "1" *-[#595959,plain]-> "runnerUtils\n1" RunnerUtils
JdbcTemplateRunnerTest                      "1" *-[#595959,plain]-> "runner\n1" StandAloneRunner
JdbcTemplateRunnerTest                      "1" *-[#595959,plain]-> "templateRepository\n1" TemplateRepositoryInterface
JdbcTestUtils                               "1" *-[#595959,plain]-> "tableConfigs\n1" JdbcTableConfigs
JdbcTestUtils                               "1" *-[#595959,plain]-> "dslContextWrapper\n1" JooqDSLContextWrapper
JdbcWorkerJobQueueService                   "1" *-[#595959,plain]-> "jdbcWorkerJobRunningRepository\n1" AbstractJdbcWorkerJobRunningRepository
JdbcWorkerJobQueueService                   "1" *-[#595959,plain]-> "workerTaskQueue\n1" JdbcQueue
JdbcWorkerJobQueueService                   "1" *-[#595959,plain]-> "serviceRegistry\n1" ServiceRegistry
JdbcWorkerTriggerResultQueueService         "1" *-[#595959,plain]-> "jdbcWorkerJobRunningRepository\n1" AbstractJdbcWorkerJobRunningRepository
JdbcWorkerTriggerResultQueueService         "1" *-[#595959,plain]-> "workerTriggerResultQueue\n1" JdbcQueue
JooqDSLContextWrapper                       "1" *-[#595959,plain]-> "retryUtils\n1" RetryUtils
JqFilterTest                                 -[#999900,dotted]-  KestraTest
JqFilterTest                                "1" *-[#595959,plain]-> "variableRenderer\n1" VariableRenderer
JsonFilter                                   -[#000082,plain]-^  ToJsonFilter
JsonFunction                                 -[#000082,plain]-^  FromJsonFunction
JsonInput                                    -[#000082,plain]-^  Input
JsonSchemaGenerator                         "1" *-[#595959,plain]-> "pluginRegistry\n1" PluginRegistry
JsonSchemaGeneratorTest                     "1" *-[#595959,plain]-> "jsonSchemaGenerator\n1" JsonSchemaGenerator
JsonSchemaGeneratorTest                      -[#999900,dotted]-  KestraTest
JsonSchemaGeneratorTest                     "1" *-[#595959,plain]-> "pluginRegistry\n1" PluginRegistry
JsonStringTest                               -[#999900,dotted]-  KestraTest
JsonStringTest                              "1" *-[#595959,plain]-> "modelValidator\n1" ModelValidator
JsonWriter                                   -[#000082,plain]-^  OutputWriter
KVController                                 -[#595959,dashed]->  InternalKVStore                             : "create"
KVController                                 -[#595959,dashed]->  KVMetadata                                  : "create"
KVController                                 -[#595959,dashed]->  KVValueAndMetadata                          : "create"
KVController                                "1" *-[#595959,plain]-> "storageInterface\n1" StorageInterface
KVController                                "1" *-[#595959,plain]-> "tenantService\n1" TenantService
KVControllerTest                             -[#595959,dashed]->  InternalKVStore                             : "create"
KVControllerTest                             -[#000082,plain]-^  JdbcH2ControllerTest
KVControllerTest                             -[#999900,dotted]-  KestraTest
KVControllerTest                            "1" *-[#595959,plain]-> "storageInterface\n1" StorageInterface
KVControllerTest                             -[#595959,dashed]->  StorageObject                               : "create"
KVEntry                                      -[#595959,dashed]->  KVMetadata                                  : "create"
KVStoreException                             -[#000082,plain]-^  KestraRuntimeException
KVStoreService                              "1" *-[#595959,plain]-> "flowService\n1" FlowService
KVStoreService                               -[#595959,dashed]->  InternalKVStore                             : "create"
KVStoreService                               -[#595959,dashed]->  KVStoreException                            : "create"
KVStoreService                              "1" *-[#595959,plain]-> "namespaceService\n1" NamespaceService
KVStoreService                              "1" *-[#595959,plain]-> "storageInterface\n1" StorageInterface
KVStoreServiceTest                          "1" *-[#595959,plain]-> "flowRepository\n1" FlowRepositoryInterface
KVStoreServiceTest                          "1" *-[#595959,plain]-> "storeService\n1" KVStoreService
KVStoreServiceTest                           -[#999900,dotted]-  KestraTest
KVValueAndMetadata                           -[#595959,dashed]->  KVMetadata                                  : "create"
KVValueAndMetadata                          "1" *-[#595959,plain]-> "metadata\n1" KVMetadata
KestraBeansFactory                           -[#595959,dashed]->  KestraRuntimeException                      : "create"
KeysFilterTest                               -[#999900,dotted]-  KestraTest
KeysFilterTest                              "1" *-[#595959,plain]-> "variableRenderer\n1" VariableRenderer
KvCommand                                    -[#000082,plain]-^  AbstractCommand
KvFunction                                  "1" *-[#595959,plain]-> "flowService\n1" FlowService
KvFunction                                  "1" *-[#595959,plain]-> "kvStoreService\n1" KVStoreService
KvFunctionTest                               -[#000082,plain]-^  AbstractMemoryRunnerTest
KvFunctionTest                               -[#595959,dashed]->  InternalKVStore                             : "create"
KvFunctionTest                               -[#595959,dashed]->  KVValueAndMetadata                          : "create"
KvFunctionTest                               -[#999900,dotted]-  KestraTest
KvFunctionTest                              "1" *-[#595959,plain]-> "logQueue\n1" QueueInterface
KvFunctionTest                              "1" *-[#595959,plain]-> "runnerUtils\n1" RunnerUtils
KvFunctionTest                              "1" *-[#595959,plain]-> "storageInterface\n1" StorageInterface
KvUpdateCommand                              -[#000082,plain]-^  AbstractApiCommand
KvUpdateCommandTest                          -[#595959,dashed]->  KVValue                                     : "create"
Labels                                       -[#595959,dashed]->  Example                                     : "create"
Labels                                       -[#008200,dashed]-^  ExecutionUpdatableTask
Labels                                       -[#595959,dashed]->  IllegalVariableEvaluationException          : "create"
Labels                                       -[#595959,dashed]->  Label                                       : "create"
Labels                                       -[#999900,dotted]-  Plugin
Labels                                       -[#000082,plain]-^  Task
ListOrMapOfLabelDeserializer                 -[#595959,dashed]->  Label                                       : "create"
Listener                                    "1" *-[#595959,plain]-> "conditions\n*" Condition
Listener                                    "1" *-[#595959,plain]-> "tasks\n*" Task
ListenersTest                                -[#000082,plain]-^  AbstractMemoryRunnerTest
ListenersTestTask                            -[#008200,dashed]-^  RunnableTask
ListenersTestTask                            -[#000082,plain]-^  Task
LocalCommand                                 -[#000082,plain]-^  StandAloneCommand
LocalFileAttributes                          -[#008200,dashed]-^  FileAttributes
LocalFiles                                   -[#595959,dashed]->  Example                                     : "create"
LocalFiles                                   -[#999900,dotted]-  Plugin
LocalFiles                                   -[#008200,dashed]-^  RunnableTask
LocalFiles                                   -[#000082,plain]-^  Task
LocalFilesTest                               -[#999900,dotted]-  KestraTest
LocalFilesTest                              "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
LocalFilesTest                              "1" *-[#595959,plain]-> "storageInterface\n1" StorageInterface
LocalFlowRepositoryLoader                   "1" *-[#595959,plain]-> "flowRepository\n1" FlowRepositoryInterface
LocalFlowRepositoryLoader                   "1" *-[#595959,plain]-> "modelValidator\n1" ModelValidator
LocalFlowRepositoryLoader                   "1" *-[#595959,plain]-> "pluginDefaultService\n1" PluginDefaultService
LocalFlowRepositoryLoader                   "1" *-[#595959,plain]-> "yamlFlowParser\n1" YamlFlowParser
LocalServiceState                           "1" *-[#595959,plain]-> "service\n1" Service
LocalServiceStateFactory                     -[#595959,dashed]->  LocalServiceState                           : "create"
LocalServiceStateFactory                    "1" *-[#595959,plain]-> "serverConfig\n1" ServerConfig
LocalServiceStateFactory                    "1" *-[#595959,plain]-> "serverInstanceFactory\n1" ServerInstanceFactory
LocalStorage                                 -[#999900,dotted]-  Plugin
LocalStorage                                 -[#008200,dashed]-^  StorageInterface
LocalStorage                                 -[#595959,dashed]->  StorageObject                               : "create"
LocalStorageTest                             -[#000082,plain]-^  StorageTestSuite
LocalWorkingDir                              -[#008200,dashed]-^  WorkingDir
LocalWorkingDirTest                          -[#595959,dashed]->  LocalWorkingDir                             : "create"
LocalWorkingDirTest                          -[#595959,dashed]->  TestWorkingDir                              : "create"
Log                                          -[#595959,dashed]->  Example                                     : "create"
Log                                          -[#999900,dotted]-  Plugin
Log                                          -[#008200,dashed]-^  RunnableTask
Log                                          -[#000082,plain]-^  Task
LogConsumerTest                              -[#595959,dashed]->  CommandsWrapper                             : "create"
LogConsumerTest                              -[#999900,dotted]-  KestraTest
LogConsumerTest                             "1" *-[#595959,plain]-> "logQueue\n1" QueueInterface
LogConsumerTest                             "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
LogConsumerTest                             "1" *-[#595959,plain]-> "TASK\n1" Task
LogController                               "1" *-[#595959,plain]-> "logRepository\n1" LogRepositoryInterface
LogController                               "1" *-[#595959,plain]-> "logQueue\n1" QueueInterface
LogController                               "1" *-[#595959,plain]-> "tenantService\n1" TenantService
LogControllerTest                            -[#000082,plain]-^  JdbcH2ControllerTest
LogControllerTest                           "1" *-[#595959,plain]-> "logRepository\n1" LogRepositoryInterface
LogEntry                                     -[#008200,dashed]-^  DeletedInterface
LogEntry                                     -[#008200,dashed]-^  TenantInterface
LogRepositoryInterface                       -[#008200,plain]-^  SaveRepositoryInterface
LogService                                  "1" *-[#595959,plain]-> "logRepository\n1" LogRepositoryInterface
LogServiceTest                               -[#999900,dotted]-  KestraTest
LogServiceTest                              "1" *-[#595959,plain]-> "logService\n1" LogService
LogToFileTest                                -[#000082,plain]-^  AbstractMemoryRunnerTest
LogToFileTest                               "1" *-[#595959,plain]-> "storage\n1" StorageInterface
ManualConstraintViolation                    -[#595959,dashed]->  ManualPath                                  : "create"
ManualConstraintViolation                    -[#595959,dashed]->  ManualPropertyNode                          : "create"
MemoryRepositoryTest                        "1" *-[#595959,plain]-> "flowRepositoryInterface\n1" FlowRepositoryInterface
MemoryRepositoryTest                         -[#999900,dotted]-  KestraTest
MemoryRepositoryTest                        "1" *-[#595959,plain]-> "yamlFlowParser\n1" YamlFlowParser
MessageTooBigException                       -[#000082,plain]-^  QueueException
MetricAggregations                          "1" *-[#595959,plain]-> "aggregations\n*" MetricAggregation
MetricController                            "1" *-[#595959,plain]-> "metricsRepository\n1" MetricRepositoryInterface
MetricController                            "1" *-[#595959,plain]-> "metricQueue\n1" QueueInterface
MetricController                            "1" *-[#595959,plain]-> "tenantService\n1" TenantService
MetricControllerTest                        "1" *-[#595959,plain]-> "jdbcMetricRepository\n1" AbstractJdbcMetricRepository
MetricControllerTest                         -[#000082,plain]-^  JdbcH2ControllerTest
MetricEntry                                  -[#008200,dashed]-^  DeletedInterface
MetricEntry                                  -[#008200,dashed]-^  TenantInterface
MetricRegistry                              "1" *-[#595959,plain]-> "metricConfig\n1" MetricConfig
MetricRepositoryInterface                    -[#008200,plain]-^  SaveRepositoryInterface
MiscController                              "1" *-[#595959,plain]-> "basicAuthService\n1" BasicAuthService
MiscController                              "1" *-[#595959,plain]-> "collectorService\n1" CollectorService
MiscController                              "1" *-[#595959,plain]-> "executionRepository\n1" ExecutionRepositoryInterface
MiscController                              "1" *-[#595959,plain]-> "instanceService\n1" InstanceService
MiscController                              "1" *-[#595959,plain]-> "tenantService\n1" TenantService
MiscController                              "1" *-[#595959,plain]-> "versionProvider\n1" VersionProvider
MiscControllerSecuredTest                    -[#999900,dotted]-  KestraTest
MiscControllerTest                          "1" *-[#595959,plain]-> "basicAuthService\n1" BasicAuthService
MiscControllerTest                           -[#000082,plain]-^  JdbcH2ControllerTest
MultipleCondition                            -[#000082,plain]-^  Condition
MultipleCondition                           "1" *-[#595959,plain]-> "conditions\n*" Condition
MultipleCondition                            -[#595959,dashed]->  Example                                     : "create"
MultipleCondition                            -[#999900,dotted]-  Plugin
MultipleConditionTest                       "1" *-[#595959,plain]-> "conditionService\n1" ConditionService
MultipleConditionTest                        -[#999900,dotted]-  KestraTest
MultipleConditionTest                       "1" *-[#595959,plain]-> "multipleConditionStorage\n1" MultipleConditionStorageInterface
MultipleConditionTriggerCaseTest            "1" *-[#595959,plain]-> "flowRepository\n1" FlowRepositoryInterface
MultipleConditionTriggerCaseTest            "1" *-[#595959,plain]-> "executionQueue\n1" QueueInterface
MultipleConditionTriggerCaseTest            "1" *-[#595959,plain]-> "runnerUtils\n1" RunnerUtils
MultiselectInput                             -[#000082,plain]-^  Input
MultiselectInput                             -[#008200,dashed]-^  ItemTypeInterface
MultiselectInput                             -[#008200,dashed]-^  RenderableInput
MultiselectInput                            "1" *-[#595959,plain]-> "itemType\n1" Type
MultiselectInputTest                         -[#999900,dotted]-  KestraTest
MultiselectInputTest                        "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
MySqlJdbcDeserializationIssuesTest           -[#000082,plain]-^  AbstractJdbcDeserializationIssuesTest
MysqlExecutionDelayStorage                   -[#000082,plain]-^  AbstractJdbcExecutionDelayStorage
MysqlExecutionDelayStorage                   -[#999900,dotted]-  MysqlQueueEnabled
MysqlExecutionQueuedStorage                  -[#000082,plain]-^  AbstractJdbcExecutionQueuedStorage
MysqlExecutionQueuedStorage                  -[#999900,dotted]-  MysqlQueueEnabled
MysqlExecutionRepository                     -[#000082,plain]-^  AbstractJdbcExecutionRepository
MysqlExecutionRepository                     -[#999900,dotted]-  MysqlRepositoryEnabled
MysqlExecutionRepositoryTest                 -[#000082,plain]-^  AbstractJdbcExecutionRepositoryTest
MysqlExecutionServiceTest                    -[#000082,plain]-^  AbstractExecutionServiceTest
MysqlExecutionServiceTest                   "1" *-[#595959,plain]-> "jdbcTestUtils\n1" JdbcTestUtils
MysqlExecutorStateStorage                    -[#000082,plain]-^  AbstractJdbcExecutorStateStorage
MysqlExecutorStateStorage                    -[#999900,dotted]-  MysqlQueueEnabled
MysqlFlowListenersTest                      "1" *-[#595959,plain]-> "flowListenersService\n1" FlowListeners
MysqlFlowListenersTest                       -[#000082,plain]-^  FlowListenersTest
MysqlFlowListenersTest                      "1" *-[#595959,plain]-> "jdbcTestUtils\n1" JdbcTestUtils
MysqlFlowRepository                          -[#000082,plain]-^  AbstractJdbcFlowRepository
MysqlFlowRepository                          -[#999900,dotted]-  MysqlRepositoryEnabled
MysqlFlowRepositoryTest                      -[#000082,plain]-^  AbstractJdbcFlowRepositoryTest
MysqlFlowTopologyRepository                  -[#000082,plain]-^  AbstractJdbcFlowTopologyRepository
MysqlFlowTopologyRepository                  -[#999900,dotted]-  MysqlRepositoryEnabled
MysqlFlowTopologyRepositoryTest              -[#000082,plain]-^  AbstractJdbcFlowTopologyRepositoryTest
MysqlLogRepository                           -[#000082,plain]-^  AbstractJdbcLogRepository
MysqlLogRepository                           -[#999900,dotted]-  MysqlRepositoryEnabled
MysqlLogRepositoryTest                       -[#000082,plain]-^  AbstractJdbcLogRepositoryTest
MysqlMetricRepository                        -[#000082,plain]-^  AbstractJdbcMetricRepository
MysqlMetricRepository                        -[#999900,dotted]-  MysqlRepositoryEnabled
MysqlMetricRepositoryTest                    -[#000082,plain]-^  AbstractJdbcMetricRepositoryTest
MysqlMultipleConditionStorage                -[#000082,plain]-^  AbstractJdbcMultipleConditionStorage
MysqlMultipleConditionStorage                -[#999900,dotted]-  MysqlQueueEnabled
MysqlMultipleConditionStorageTest            -[#000082,plain]-^  AbstractMultipleConditionStorageTest
MysqlMultipleConditionStorageTest           "1" *-[#595959,plain]-> "jdbcTestUtils\n1" JdbcTestUtils
MysqlMultipleConditionStorageTest            -[#595959,dashed]->  MysqlMultipleConditionStorage               : "create"
MysqlMultipleConditionStorageTest           "1" *-[#595959,plain]-> "repository\n1" MysqlRepository
MysqlQueue                                   -[#000082,plain]-^  JdbcQueue
MysqlQueueFactory                            -[#595959,dashed]->  MysqlQueue                                  : "create"
MysqlQueueFactory                            -[#999900,dotted]-  MysqlQueueEnabled
MysqlQueueFactory                            -[#595959,dashed]->  MysqlWorkerJobQueue                         : "create"
MysqlQueueFactory                            -[#595959,dashed]->  MysqlWorkerTriggerResultQueue               : "create"
MysqlQueueFactory                            -[#008200,dashed]-^  QueueFactoryInterface
MysqlQueueTest                               -[#000082,plain]-^  JdbcQueueTest
MysqlRepository                              -[#000082,plain]-^  AbstractJdbcRepository
MysqlRepository                              -[#595959,dashed]->  ArrayListTotal                              : "create"
MysqlRepository                              -[#999900,dotted]-  MysqlRepositoryEnabled
MysqlRunnerRetryTest                         -[#000082,plain]-^  JdbcRunnerRetryTest
MysqlRunnerTest                              -[#000082,plain]-^  JdbcRunnerTest
MysqlSchedulerScheduleTest                   -[#595959,dashed]->  JdbcScheduler                               : "create"
MysqlSchedulerScheduleTest                   -[#000082,plain]-^  SchedulerScheduleTest
MysqlServiceInstanceRepository               -[#000082,plain]-^  AbstractJdbcServiceInstanceRepository
MysqlServiceInstanceRepository               -[#999900,dotted]-  MysqlRepositoryEnabled
MysqlServiceInstanceRepositoryTest           -[#000082,plain]-^  AbstractJdbcServiceInstanceRepositoryTest
MysqlServiceLivenessCoordinatorTest          -[#000082,plain]-^  JdbcServiceLivenessCoordinatorTest
MysqlSettingRepository                       -[#000082,plain]-^  AbstractJdbcSettingRepository
MysqlSettingRepository                       -[#999900,dotted]-  MysqlRepositoryEnabled
MysqlSettingRepositoryTest                   -[#000082,plain]-^  AbstractJdbcSettingRepositoryTest
MysqlSubflowExecutionStorage                 -[#000082,plain]-^  AbstractJdbcSubflowExecutionStorage
MysqlSubflowExecutionStorage                 -[#999900,dotted]-  MysqlQueueEnabled
MysqlSubflowExecutionStorageTest             -[#000082,plain]-^  AbstractSubflowExecutionTest
MysqlTemplateRepository                      -[#000082,plain]-^  AbstractJdbcTemplateRepository
MysqlTemplateRepository                      -[#999900,dotted]-  MysqlRepositoryEnabled
MysqlTemplateRepository                      -[#999900,dotted]-  TemplateEnabled
MysqlTemplateRepositoryTest                  -[#000082,plain]-^  AbstractJdbcTemplateRepositoryTest
MysqlTemplateRunnerTest                      -[#000082,plain]-^  JdbcTemplateRunnerTest
MysqlTriggerRepository                       -[#000082,plain]-^  AbstractJdbcTriggerRepository
MysqlTriggerRepository                       -[#999900,dotted]-  MysqlRepositoryEnabled
MysqlTriggerRepositoryTest                   -[#000082,plain]-^  AbstractJdbcTriggerRepositoryTest
MysqlWorkerJobQueue                         "1" *-[#595959,plain]-> "jdbcworkerjobQueueService\n1" JdbcWorkerJobQueueService
MysqlWorkerJobQueue                          -[#008200,dashed]-^  WorkerJobQueueInterface
MysqlWorkerJobRunningRepository              -[#000082,plain]-^  AbstractJdbcWorkerJobRunningRepository
MysqlWorkerJobRunningRepository              -[#999900,dotted]-  MysqlRepositoryEnabled
MysqlWorkerTriggerResultQueue               "1" *-[#595959,plain]-> "jdbcWorkerTriggerResultQueueService\n1" JdbcWorkerTriggerResultQueueService
MysqlWorkerTriggerResultQueue                -[#000082,plain]-^  MysqlQueue
MysqlWorkerTriggerResultQueue                -[#008200,dashed]-^  WorkerTriggerResultQueueInterface
Namespace                                    -[#008200,dashed]-^  NamespaceInterface
NamespaceCommand                             -[#000082,plain]-^  AbstractCommand
NamespaceController                          -[#595959,dashed]->  ArrayListTotal                              : "create"
NamespaceController                         "1" *-[#595959,plain]-> "flowRepository\n1" FlowRepositoryInterface
NamespaceController                         "1" *-[#595959,plain]-> "flowTopologyService\n1" FlowTopologyService
NamespaceController                          -[#008200,dashed]-^  NamespaceControllerInterface
NamespaceController                         "1" *-[#595959,plain]-> "namespaceUtils\n1" NamespaceUtils
NamespaceController                         "1" *-[#595959,plain]-> "tenantService\n1" TenantService
NamespaceControllerInterface                 -[#595959,dashed]->  DisabledInterface
NamespaceControllerInterface                 -[#595959,dashed]->  NamespaceInterface
NamespaceControllerTest                     "1" *-[#595959,plain]-> "flowRepository\n1" FlowRepositoryInterface
NamespaceControllerTest                     "1" *-[#595959,plain]-> "flowTopologyRepository\n1" FlowTopologyRepositoryInterface
NamespaceControllerTest                      -[#999900,dotted]-  KestraTest
NamespaceFileController                     "1" *-[#595959,plain]-> "flowService\n1" FlowService
NamespaceFileController                     "1" *-[#595959,plain]-> "storageInterface\n1" StorageInterface
NamespaceFileController                     "1" *-[#595959,plain]-> "tenantService\n1" TenantService
NamespaceFileControllerTest                 "1" *-[#595959,plain]-> "flowRepository\n1" FlowRepositoryInterface
NamespaceFileControllerTest                  -[#000082,plain]-^  JdbcH2ControllerTest
NamespaceFileControllerTest                  -[#999900,dotted]-  KestraTest
NamespaceFileControllerTest                 "1" *-[#595959,plain]-> "storageInterface\n1" StorageInterface
NamespaceFileTest                            -[#595959,dashed]->  NamespaceFile                               : "create"
NamespaceFilesCommand                        -[#000082,plain]-^  AbstractCommand
NamespaceFilesUpdateCommand                  -[#000082,plain]-^  AbstractApiCommand
NamespaceFilesUpdateCommand                  -[#595959,dashed]->  KestraIgnore                                : "create"
NamespaceInterface                           -[#008200,plain]-^  DeletedInterface
NamespaceWithDisabled                        -[#008200,dashed]-^  DisabledInterface
NamespaceWithDisabled                        -[#000082,plain]-^  Namespace
NextTaskRun                                 "1" *-[#595959,plain]-> "task\n1" Task
NextTaskRun                                 "1" *-[#595959,plain]-> "taskRun\n1" TaskRun
NindentFilter                                -[#000082,plain]-^  AbstractIndent
NindentFilterTest                            -[#999900,dotted]-  KestraTest
NindentFilterTest                           "1" *-[#595959,plain]-> "variableRenderer\n1" VariableRenderer
NoEncryptionConfiguredTest                   -[#000082,plain]-^  AbstractMemoryRunnerTest
NoEncryptionConfiguredTest                  "1" *-[#595959,plain]-> "flowIO\n1" FlowInputOutput
NoEncryptionConfiguredTest                  "1" *-[#595959,plain]-> "flowRepository\n1" FlowRepositoryInterface
NoEncryptionConfiguredTest                   -[#999900,dotted]-  KestraTest
NoOpStartupHook                              -[#008200,dashed]-^  StartupHookInterface
NotCondition                                 -[#000082,plain]-^  Condition
NotCondition                                "1" *-[#595959,plain]-> "conditions\n*" Condition
NotCondition                                 -[#595959,dashed]->  Example                                     : "create"
NotCondition                                 -[#999900,dotted]-  Plugin
NotCondition                                 -[#008200,dashed]-^  ScheduleCondition
NotConditionTest                            "1" *-[#595959,plain]-> "conditionService\n1" ConditionService
NotConditionTest                             -[#999900,dotted]-  KestraTest
NowFunction                                  -[#000082,plain]-^  AbstractDate
NullCoalescingExpressionTest                 -[#999900,dotted]-  KestraTest
NullCoalescingExpressionTest                "1" *-[#595959,plain]-> "variableRenderer\n1" VariableRenderer
NumberFilterTest                             -[#999900,dotted]-  KestraTest
NumberFilterTest                            "1" *-[#595959,plain]-> "variableRenderer\n1" VariableRenderer
ObjectMapperFactory                          -[#595959,dashed]->  PluginModule                                : "create"
ObjectMapperFactoryTest                      -[#999900,dotted]-  KestraTest
OrCondition                                  -[#000082,plain]-^  Condition
OrCondition                                 "1" *-[#595959,plain]-> "conditions\n*" Condition
OrCondition                                  -[#595959,dashed]->  Example                                     : "create"
OrCondition                                  -[#999900,dotted]-  Plugin
OrCondition                                  -[#008200,dashed]-^  ScheduleCondition
OrConditionTest                             "1" *-[#595959,plain]-> "conditionService\n1" ConditionService
OrConditionTest                              -[#999900,dotted]-  KestraTest
OssAuthEvent                                 -[#000082,plain]-^  Event
Output                                       -[#008200,dashed]-^  Data
Output                                      "1" *-[#595959,plain]-> "type\n1" Type
OutputValues                                 -[#595959,dashed]->  Example                                     : "create"
OutputValues                                 -[#999900,dotted]-  Plugin
OutputValues                                 -[#008200,dashed]-^  RunnableTask
OutputValues                                 -[#000082,plain]-^  Task
OutputValuesTest                             -[#000082,plain]-^  AbstractMemoryRunnerTest
OutputValuesTest                            "1" *-[#595959,plain]-> "flowRepository\n1" FlowRepositoryInterface
OverrideRetryInterceptorTest                 -[#999900,dotted]-  KestraTest
PagedResults                                "1" *-[#595959,plain]-> "results\n1" ArrayListTotal
Parallel                                     -[#595959,dashed]->  Example                                     : "create"
Parallel                                     -[#008200,dashed]-^  FlowableTask
Parallel                                     -[#595959,dashed]->  GraphCluster                                : "create"
Parallel                                     -[#999900,dotted]-  Plugin
Parallel                                     -[#000082,plain]-^  Task
Parallel                                    "1" *-[#595959,plain]-> "tasks\n*" Task
ParallelTest                                 -[#000082,plain]-^  AbstractMemoryRunnerTest
Pause                                        -[#595959,dashed]->  Example                                     : "create"
Pause                                        -[#008200,dashed]-^  FlowableTask
Pause                                        -[#595959,dashed]->  GraphCluster                                : "create"
Pause                                        -[#595959,dashed]->  GraphTask                                   : "create"
Pause                                       "1" *-[#595959,plain]-> "onResume\n*" Input
Pause                                        -[#999900,dotted]-  Plugin
Pause                                        -[#000082,plain]-^  Task
Pause                                       "1" *-[#595959,plain]-> "errors\n*" Task
PauseTest                                    -[#000082,plain]-^  AbstractMemoryRunnerTest
PdfFileRender                                -[#000082,plain]-^  Base64Render
PebbleVariableRendererTest                   -[#999900,dotted]-  KestraTest
PebbleVariableRendererTest                  "1" *-[#595959,plain]-> "variableRenderer\n1" VariableRenderer
PluginCommand                                -[#000082,plain]-^  AbstractCommand
PluginConfigurationTest                      -[#999900,dotted]-  KestraTest
PluginConfigurationTest                     "1" *-[#595959,plain]-> "configurations\n*" PluginConfiguration
PluginConfigurationTest                      -[#595959,dashed]->  PluginConfiguration                         : "create"
PluginConfigurations                        "1" *-[#595959,plain]-> "configurations\n*" PluginConfiguration
PluginConfigurationsTest                     -[#595959,dashed]->  PluginConfiguration                         : "create"
PluginConfigurationsTest                     -[#595959,dashed]->  PluginConfigurations                        : "create"
PluginConfigurationsTest                     -[#595959,dashed]->  TaskWithAlias                               : "create"
PluginController                             -[#595959,dashed]->  DocumentationWithSchema                     : "create"
PluginController                             -[#595959,dashed]->  InputType                                   : "create"
PluginController                            "1" *-[#595959,plain]-> "jsonSchemaGenerator\n1" JsonSchemaGenerator
PluginController                             -[#595959,dashed]->  PluginIcon                                  : "create"
PluginController                            "1" *-[#595959,plain]-> "pluginRegistry\n1" PluginRegistry
PluginController                             -[#595959,dashed]->  Schema                                      : "create"
PluginDefault                                -[#999900,dotted]-  PluginDefaultValidation
PluginDefaultService                        "1" *-[#595959,plain]-> "pluginGlobalDefault\n1" PluginGlobalDefaultConfiguration
PluginDefaultService                        "1" *-[#595959,plain]-> "pluginRegistry\n1" PluginRegistry
PluginDefaultService                        "1" *-[#595959,plain]-> "logQueue\n1" QueueInterface
PluginDefaultService                        "1" *-[#595959,plain]-> "taskGlobalDefault\n1" TaskGlobalDefaultConfiguration
PluginDefaultService                        "1" *-[#595959,plain]-> "yamlFlowParser\n1" YamlFlowParser
PluginDefaultServiceTest                     -[#999900,dotted]-  KestraTest
PluginDefaultServiceTest                     -[#595959,dashed]->  PluginDefault                               : "create"
PluginDefaultServiceTest                    "1" *-[#595959,plain]-> "pluginDefaultService\n1" PluginDefaultService
PluginDefaultServiceTest                     -[#595959,dashed]->  PluginGlobalDefaultConfiguration            : "create"
PluginDefaultValidationTest                  -[#999900,dotted]-  KestraTest
PluginDefaultValidationTest                 "1" *-[#595959,plain]-> "modelValidator\n1" ModelValidator
PluginDefaultsCaseTest                      "1" *-[#595959,plain]-> "runnerUtils\n1" RunnerUtils
PluginDeserializer                           -[#595959,dashed]->  Plugin
PluginDeserializer                          "1" *-[#595959,plain]-> "pluginRegistry\n1" PluginRegistry
PluginDeserializerTest                       -[#595959,dashed]->  PluginDeserializer                          : "create"
PluginDeserializerTest                      "1" *-[#595959,plain]-> "registry\n1" PluginRegistry
PluginDocCommand                             -[#000082,plain]-^  AbstractCommand
PluginDownloader                            "1" *-[#595959,plain]-> "repositoryConfigs\n*" RepositoryConfig
PluginGlobalDefaultConfiguration            "1" *-[#595959,plain]-> "defaults\n*" PluginDefault
PluginInstallCommand                         -[#000082,plain]-^  AbstractCommand
PluginInstallCommand                        "1" *-[#595959,plain]-> "pluginDownloader\n1" PluginDownloader
PluginListCommand                            -[#000082,plain]-^  AbstractCommand
PluginModule                                 -[#595959,dashed]->  PluginDeserializer                          : "create"
PluginResolver                               -[#595959,dashed]->  ExternalPlugin                              : "create"
PluginScanner                                -[#595959,dashed]->  PluginResolver                              : "create"
PluginScannerTest                            -[#595959,dashed]->  PluginScanner                               : "create"
PluginUtilsService                           -[#595959,dashed]->  IllegalVariableEvaluationException          : "create"
PluginUtilsServiceTest                       -[#999900,dotted]-  KestraTest
PluginUtilsServiceTest                      "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
PollingTrigger                               -[#000082,plain]-^  AbstractTrigger
PollingTrigger                               -[#008200,dashed]-^  PollingTriggerInterface
PollingTriggerInterface                      -[#008200,plain]-^  WorkerTriggerInterface
PostgresExecutionDelayStorage                -[#000082,plain]-^  AbstractJdbcExecutionDelayStorage
PostgresExecutionDelayStorage                -[#999900,dotted]-  PostgresQueueEnabled
PostgresExecutionQueuedStorage               -[#000082,plain]-^  AbstractJdbcExecutionQueuedStorage
PostgresExecutionQueuedStorage               -[#999900,dotted]-  PostgresQueueEnabled
PostgresExecutionRepository                  -[#000082,plain]-^  AbstractJdbcExecutionRepository
PostgresExecutionRepository                  -[#999900,dotted]-  PostgresRepositoryEnabled
PostgresExecutionRepositoryTest              -[#000082,plain]-^  AbstractJdbcExecutionRepositoryTest
PostgresExecutionServiceTest                 -[#000082,plain]-^  AbstractExecutionServiceTest
PostgresExecutionServiceTest                "1" *-[#595959,plain]-> "jdbcTestUtils\n1" JdbcTestUtils
PostgresExecutorStateStorage                 -[#000082,plain]-^  AbstractJdbcExecutorStateStorage
PostgresExecutorStateStorage                 -[#999900,dotted]-  PostgresQueueEnabled
PostgresFlowListenersTest                   "1" *-[#595959,plain]-> "flowListenersService\n1" FlowListeners
PostgresFlowListenersTest                    -[#000082,plain]-^  FlowListenersTest
PostgresFlowListenersTest                   "1" *-[#595959,plain]-> "jdbcTestUtils\n1" JdbcTestUtils
PostgresFlowRepository                       -[#000082,plain]-^  AbstractJdbcFlowRepository
PostgresFlowRepository                       -[#999900,dotted]-  PostgresRepositoryEnabled
PostgresFlowRepositoryTest                   -[#000082,plain]-^  AbstractJdbcFlowRepositoryTest
PostgresFlowTopologyRepository               -[#000082,plain]-^  AbstractJdbcFlowTopologyRepository
PostgresFlowTopologyRepository               -[#999900,dotted]-  PostgresRepositoryEnabled
PostgresFlowTopologyRepositoryTest           -[#000082,plain]-^  AbstractJdbcFlowTopologyRepositoryTest
PostgresJdbcDeserializationIssuesTest        -[#000082,plain]-^  AbstractJdbcDeserializationIssuesTest
PostgresLogRepository                        -[#000082,plain]-^  AbstractJdbcLogRepository
PostgresLogRepository                        -[#999900,dotted]-  PostgresRepositoryEnabled
PostgresLogRepositoryTest                    -[#000082,plain]-^  AbstractJdbcLogRepositoryTest
PostgresMetricRepository                     -[#000082,plain]-^  AbstractJdbcMetricRepository
PostgresMetricRepository                     -[#999900,dotted]-  PostgresRepositoryEnabled
PostgresMetricRepositoryTest                 -[#000082,plain]-^  AbstractJdbcMetricRepositoryTest
PostgresMultipleConditionStorage             -[#000082,plain]-^  AbstractJdbcMultipleConditionStorage
PostgresMultipleConditionStorage             -[#999900,dotted]-  PostgresQueueEnabled
PostgresMultipleConditionStorageTest         -[#000082,plain]-^  AbstractMultipleConditionStorageTest
PostgresMultipleConditionStorageTest        "1" *-[#595959,plain]-> "jdbcTestUtils\n1" JdbcTestUtils
PostgresMultipleConditionStorageTest         -[#595959,dashed]->  PostgresMultipleConditionStorage            : "create"
PostgresMultipleConditionStorageTest        "1" *-[#595959,plain]-> "repository\n1" PostgresRepository
PostgresQueue                                -[#595959,dashed]->  DeserializationException                    : "create"
PostgresQueue                                -[#000082,plain]-^  JdbcQueue
PostgresQueueFactory                         -[#595959,dashed]->  PostgresQueue                               : "create"
PostgresQueueFactory                         -[#999900,dotted]-  PostgresQueueEnabled
PostgresQueueFactory                         -[#595959,dashed]->  PostgresWorkerJobQueue                      : "create"
PostgresQueueFactory                         -[#595959,dashed]->  PostgresWorkerTriggerResultQueue            : "create"
PostgresQueueFactory                         -[#008200,dashed]-^  QueueFactoryInterface
PostgresQueueTest                            -[#000082,plain]-^  JdbcQueueTest
PostgresRepository                           -[#000082,plain]-^  AbstractJdbcRepository
PostgresRepository                           -[#595959,dashed]->  ArrayListTotal                              : "create"
PostgresRepository                           -[#999900,dotted]-  PostgresRepositoryEnabled
PostgresRunnerRetryTest                      -[#000082,plain]-^  JdbcRunnerRetryTest
PostgresRunnerTest                           -[#000082,plain]-^  JdbcRunnerTest
PostgresSchedulerScheduleTest                -[#595959,dashed]->  JdbcScheduler                               : "create"
PostgresSchedulerScheduleTest                -[#000082,plain]-^  SchedulerScheduleTest
PostgresServiceInstanceRepository            -[#000082,plain]-^  AbstractJdbcServiceInstanceRepository
PostgresServiceInstanceRepository            -[#999900,dotted]-  PostgresRepositoryEnabled
PostgresServiceInstanceRepositoryTest        -[#000082,plain]-^  AbstractJdbcServiceInstanceRepositoryTest
PostgresServiceLivenessCoordinatorTest       -[#000082,plain]-^  JdbcServiceLivenessCoordinatorTest
PostgresSettingRepository                    -[#000082,plain]-^  AbstractJdbcSettingRepository
PostgresSettingRepository                    -[#999900,dotted]-  PostgresRepositoryEnabled
PostgresSettingRepositoryTest                -[#000082,plain]-^  AbstractJdbcSettingRepositoryTest
PostgresSubflowExecutionStorage              -[#000082,plain]-^  AbstractJdbcSubflowExecutionStorage
PostgresSubflowExecutionStorage              -[#999900,dotted]-  PostgresQueueEnabled
PostgresSubflowExecutionStorageTest          -[#000082,plain]-^  AbstractSubflowExecutionTest
PostgresTemplateRepository                   -[#000082,plain]-^  AbstractJdbcTemplateRepository
PostgresTemplateRepository                   -[#999900,dotted]-  PostgresRepositoryEnabled
PostgresTemplateRepository                   -[#999900,dotted]-  TemplateEnabled
PostgresTemplateRepositoryTest               -[#000082,plain]-^  AbstractJdbcTemplateRepositoryTest
PostgresTemplateRunnerTest                   -[#000082,plain]-^  JdbcTemplateRunnerTest
PostgresTriggerRepository                    -[#000082,plain]-^  AbstractJdbcTriggerRepository
PostgresTriggerRepository                    -[#999900,dotted]-  PostgresRepositoryEnabled
PostgresTriggerRepositoryTest                -[#000082,plain]-^  AbstractJdbcTriggerRepositoryTest
PostgresWorkerJobQueue                      "1" *-[#595959,plain]-> "jdbcWorkerJobQueueService\n1" JdbcWorkerJobQueueService
PostgresWorkerJobQueue                       -[#008200,dashed]-^  WorkerJobQueueInterface
PostgresWorkerJobRunningRepository           -[#000082,plain]-^  AbstractJdbcWorkerJobRunningRepository
PostgresWorkerJobRunningRepository           -[#999900,dotted]-  PostgresRepositoryEnabled
PostgresWorkerTriggerResultQueue            "1" *-[#595959,plain]-> "jdbcWorkerTriggerResultQueueService\n1" JdbcWorkerTriggerResultQueueService
PostgresWorkerTriggerResultQueue             -[#000082,plain]-^  PostgresQueue
PostgresWorkerTriggerResultQueue             -[#008200,dashed]-^  WorkerTriggerResultQueueInterface
PrintContextFunctionTest                     -[#999900,dotted]-  KestraTest
PrintContextFunctionTest                    "1" *-[#595959,plain]-> "variableRenderer\n1" VariableRenderer
Process                                      -[#595959,dashed]->  Example                                     : "create"
Process                                      -[#999900,dotted]-  Plugin
Process                                      -[#595959,dashed]->  RunnerResult                                : "create"
Process                                      -[#595959,dashed]->  TaskException                               : "create"
Process                                      -[#000082,plain]-^  TaskRunner
ProcessTest                                  -[#000082,plain]-^  AbstractTaskRunnerTest
ProcessTest                                  -[#595959,dashed]->  Process                                     : "create"
Property                                     -[#595959,dashed]->  IllegalVariableEvaluationException          : "create"
PropertyTest                                 -[#999900,dotted]-  KestraTest
PropertyTest                                 -[#595959,dashed]->  Property                                    : "create"
PropertyTest                                "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
PropertyTest                                "1" *-[#595959,plain]-> "storage\n1" StorageInterface
PublicHolidayCondition                       -[#000082,plain]-^  Condition
PublicHolidayCondition                       -[#595959,dashed]->  Example                                     : "create"
PublicHolidayCondition                       -[#999900,dotted]-  Plugin
PublicHolidayCondition                       -[#008200,dashed]-^  ScheduleCondition
PublicHolidayConditionTest                  "1" *-[#595959,plain]-> "conditionService\n1" ConditionService
PublicHolidayConditionTest                   -[#999900,dotted]-  KestraTest
PurgeCurrentExecutionFiles                   -[#595959,dashed]->  Example                                     : "create"
PurgeCurrentExecutionFiles                   -[#999900,dotted]-  Plugin
PurgeCurrentExecutionFiles                   -[#008200,dashed]-^  RunnableTask
PurgeCurrentExecutionFiles                   -[#000082,plain]-^  Task
PurgeCurrentExecutionFilesTest               -[#999900,dotted]-  KestraTest
PurgeCurrentExecutionFilesTest              "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
PurgeExecutions                              -[#595959,dashed]->  Example                                     : "create"
PurgeExecutions                              -[#999900,dotted]-  Plugin
PurgeExecutions                              -[#008200,dashed]-^  RunnableTask
PurgeExecutions                              -[#000082,plain]-^  Task
PurgeExecutionsTest                         "1" *-[#595959,plain]-> "executionRepository\n1" ExecutionRepositoryInterface
PurgeExecutionsTest                          -[#999900,dotted]-  KestraTest
PurgeExecutionsTest                         "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
PurgeExecutionsTest                          -[#595959,dashed]->  State                                       : "create"
PurgeLogs                                    -[#595959,dashed]->  Example                                     : "create"
PurgeLogs                                    -[#999900,dotted]-  Plugin
PurgeLogs                                    -[#008200,dashed]-^  RunnableTask
PurgeLogs                                    -[#000082,plain]-^  Task
PurgeLogsTest                                -[#999900,dotted]-  KestraTest
PurgeLogsTest                               "1" *-[#595959,plain]-> "logRepository\n1" LogRepositoryInterface
PurgeLogsTest                               "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
Random                                       -[#000082,plain]-^  AbstractRetry
Read                                         -[#008200,dashed]-^  RunnableTask
Read                                         -[#000082,plain]-^  Task
ReadFileFunction                            "1" *-[#595959,plain]-> "storageInterface\n1" StorageInterface
ReadFileFunctionTest                         -[#999900,dotted]-  KestraTest
ReadFileFunctionTest                        "1" *-[#595959,plain]-> "storageInterface\n1" StorageInterface
ReadFileFunctionTest                        "1" *-[#595959,plain]-> "variableRenderer\n1" VariableRenderer
RealtimeTriggerInterface                     -[#008200,plain]-^  WorkerTriggerInterface
RecursivePebbleVariableRendererTest          -[#999900,dotted]-  KestraTest
RecursivePebbleVariableRendererTest         "1" *-[#595959,plain]-> "variableRenderer\n1" VariableRenderer
RegexTest                                    -[#999900,dotted]-  KestraTest
RegexTest                                   "1" *-[#595959,plain]-> "modelValidator\n1" ModelValidator
RegisteredPlugin                            "1" *-[#595959,plain]-> "externalPlugin\n1" ExternalPlugin
ReindexCommand                               -[#000082,plain]-^  AbstractCommand
Relation                                    "1" *-[#595959,plain]-> "relationType\n1" RelationType
RenderFunctionTest                           -[#999900,dotted]-  KestraTest
RenderFunctionTest                          "1" *-[#595959,plain]-> "variableRenderer\n1" VariableRenderer
RenderOnceFunction                           -[#000082,plain]-^  RenderFunction
RenderOncerFunctionTest                      -[#999900,dotted]-  KestraTest
RenderOncerFunctionTest                     "1" *-[#595959,plain]-> "variableRenderer\n1" VariableRenderer
ReplaceFilterTest                            -[#999900,dotted]-  KestraTest
ReplaceFilterTest                           "1" *-[#595959,plain]-> "variableRenderer\n1" VariableRenderer
Request                                      -[#000082,plain]-^  AbstractHttp
Request                                      -[#595959,dashed]->  Example                                     : "create"
Request                                      -[#999900,dotted]-  Plugin
Request                                      -[#008200,dashed]-^  RunnableTask
RequestTest                                  -[#999900,dotted]-  KestraTest
RequestTest                                 "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
RequestTest                                 "1" *-[#595959,plain]-> "storageInterface\n1" StorageInterface
ResolvedTask                                 -[#595959,dashed]->  NextTaskRun                                 : "create"
ResolvedTask                                "1" *-[#595959,plain]-> "task\n1" Task
RestartCaseTest                             "1" *-[#595959,plain]-> "executionService\n1" ExecutionService
RestartCaseTest                             "1" *-[#595959,plain]-> "flowRepository\n1" FlowRepositoryInterface
RestartCaseTest                             "1" *-[#595959,plain]-> "executionQueue\n1" QueueInterface
RestartCaseTest                             "1" *-[#595959,plain]-> "runnerUtils\n1" RunnerUtils
RestartTest                                  -[#000082,plain]-^  AbstractMemoryRunnerTest
RestartTest                                 "1" *-[#595959,plain]-> "restartCaseTest\n1" RestartCaseTest
Resume                                       -[#595959,dashed]->  Example                                     : "create"
Resume                                       -[#999900,dotted]-  Plugin
Resume                                       -[#008200,dashed]-^  RunnableTask
Resume                                       -[#000082,plain]-^  Task
ResumeTest                                   -[#000082,plain]-^  AbstractMemoryRunnerTest
RetryCaseTest                               "1" *-[#595959,plain]-> "executionQueue\n1" QueueInterface
RetryCaseTest                               "1" *-[#595959,plain]-> "runnerUtils\n1" RunnerUtils
RetryUtilsTest                               -[#999900,dotted]-  KestraTest
RetryUtilsTest                              "1" *-[#595959,plain]-> "retryUtils\n1" RetryUtils
Return                                       -[#595959,dashed]->  Example                                     : "create"
Return                                       -[#595959,dashed]->  Metric                                      : "create"
Return                                       -[#999900,dotted]-  Plugin
Return                                       -[#008200,dashed]-^  RunnableTask
Return                                       -[#000082,plain]-^  Task
Reverse                                      -[#595959,dashed]->  Example                                     : "create"
Reverse                                      -[#999900,dotted]-  Plugin
Reverse                                      -[#008200,dashed]-^  RunnableTask
Reverse                                      -[#000082,plain]-^  Task
ReverseTest                                  -[#999900,dotted]-  KestraTest
ReverseTest                                 "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
ReverseTest                                 "1" *-[#595959,plain]-> "storageInterface\n1" StorageInterface
RunContext                                   -[#595959,dashed]->  StateStore                                  : "create"
RunContextFactory                           "1" *-[#595959,plain]-> "flowService\n1" FlowService
RunContextFactory                            -[#595959,dashed]->  InternalStorage                             : "create"
RunContextFactory                           "1" *-[#595959,plain]-> "kvStoreService\n1" KVStoreService
RunContextFactory                           "1" *-[#595959,plain]-> "metricRegistry\n1" MetricRegistry
RunContextFactory                           "1" *-[#595959,plain]-> "pluginConfigurations\n1" PluginConfigurations
RunContextFactory                           "1" *-[#595959,plain]-> "runContextCache\n1" RunContextCache
RunContextFactory                            -[#595959,dashed]->  RunContextLogger                            : "create"
RunContextFactory                           "1" *-[#595959,plain]-> "runContextLoggerFactory\n1" RunContextLoggerFactory
RunContextFactory                           "1" *-[#595959,plain]-> "storageInterface\n1" StorageInterface
RunContextFactory                           "1" *-[#595959,plain]-> "variableRenderer\n1" VariableRenderer
RunContextFactory                           "1" *-[#595959,plain]-> "workingDirFactory\n1" WorkingDirFactory
RunContextInitializer                       "1" *-[#595959,plain]-> "flowService\n1" FlowService
RunContextInitializer                        -[#595959,dashed]->  InternalStorage                             : "create"
RunContextInitializer                       "1" *-[#595959,plain]-> "pluginConfigurations\n1" PluginConfigurations
RunContextInitializer                       "1" *-[#595959,plain]-> "contextLoggerFactory\n1" RunContextLoggerFactory
RunContextInitializer                        -[#595959,dashed]->  Secret                                      : "create"
RunContextInitializer                       "1" *-[#595959,plain]-> "storageInterface\n1" StorageInterface
RunContextLogger                            "1" *-[#595959,plain]-> "logEntry\n1" LogEntry
RunContextLogger                            "1" *-[#595959,plain]-> "logQueue\n1" QueueInterface
RunContextLoggerFactory                     "1" *-[#595959,plain]-> "logQueue\n1" QueueInterface
RunContextLoggerFactory                      -[#595959,dashed]->  RunContextLogger                            : "create"
RunContextLoggerTest                         -[#999900,dotted]-  KestraTest
RunContextLoggerTest                        "1" *-[#595959,plain]-> "logQueue\n1" QueueInterface
RunContextLoggerTest                        "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
RunContextLoggerTest                         -[#595959,dashed]->  RunContextLogger                            : "create"
RunContextTest                               -[#000082,plain]-^  AbstractMemoryRunnerTest
RunContextTest                              "1" *-[#595959,plain]-> "flowIO\n1" FlowInputOutput
RunContextTest                               -[#595959,dashed]->  Label                                       : "create"
RunContextTest                              "1" *-[#595959,plain]-> "metricRegistry\n1" MetricRegistry
RunContextTest                              "1" *-[#595959,plain]-> "pluginDefaultsCaseTest\n1" PluginDefaultsCaseTest
RunContextTest                              "1" *-[#595959,plain]-> "workerTaskLogQueue\n1" QueueInterface
RunContextTest                              "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
RunContextTest                              "1" *-[#595959,plain]-> "runContextInitializer\n1" RunContextInitializer
RunContextTest                               -[#595959,dashed]->  State                                       : "create"
RunContextTest                              "1" *-[#595959,plain]-> "storageInterface\n1" StorageInterface
RunVariablesTest                             -[#595959,dashed]->  RunContextLogger                            : "create"
RunnableTask                                 -[#595959,dashed]->  Output
RunnableTask                                 -[#008200,plain]-^  Plugin
RunnableTask                                 -[#008200,plain]-^  WorkerJobLifecycle
RunnerResult                                "1" *-[#595959,plain]-> "logConsumer\n1" AbstractLogConsumer
RunnerUtils                                 "1" *-[#595959,plain]-> "conditionService\n1" ConditionService
RunnerUtils                                 "1" *-[#595959,plain]-> "flowRepository\n1" FlowRepositoryInterface
RunnerUtils                                 "1" *-[#595959,plain]-> "executionQueue\n1" QueueInterface
RuntimeLabelsTest                            -[#000082,plain]-^  AbstractMemoryRunnerTest
RuntimeLabelsTest                            -[#595959,dashed]->  Label                                       : "create"
Schedulable                                  -[#008200,plain]-^  PollingTriggerInterface
Schedule                                     -[#000082,plain]-^  AbstractTrigger
Schedule                                     -[#595959,dashed]->  Example                                     : "create"
Schedule                                     -[#595959,dashed]->  Label                                       : "create"
Schedule                                     -[#999900,dotted]-  Plugin
Schedule                                    "1" *-[#595959,plain]-> "recoverMissedSchedules\n1" RecoverMissedSchedules
Schedule                                     -[#008200,dashed]-^  Schedulable
Schedule                                    "1" *-[#595959,plain]-> "scheduleConditions\n*" ScheduleCondition
Schedule                                     -[#999900,dotted]-  ScheduleValidation
Schedule                                     -[#595959,dashed]->  State                                       : "create"
Schedule                                     -[#008200,dashed]-^  TriggerOutput
ScheduleDateCaseTest                        "1" *-[#595959,plain]-> "flowRepository\n1" FlowRepositoryInterface
ScheduleDateCaseTest                        "1" *-[#595959,plain]-> "executionQueue\n1" QueueInterface
ScheduleOnDates                              -[#000082,plain]-^  AbstractTrigger
ScheduleOnDates                              -[#595959,dashed]->  Label                                       : "create"
ScheduleOnDates                              -[#999900,dotted]-  Plugin
ScheduleOnDates                             "1" *-[#595959,plain]-> "dates\n1" Property
ScheduleOnDates                             "1" *-[#595959,plain]-> "recoverMissedSchedules\n1" RecoverMissedSchedules
ScheduleOnDates                              -[#008200,dashed]-^  Schedulable
ScheduleOnDates                              -[#008200,dashed]-^  TriggerOutput
ScheduleOnDatesTest                          -[#999900,dotted]-  KestraTest
ScheduleOnDatesTest                          -[#595959,dashed]->  Label                                       : "create"
ScheduleOnDatesTest                         "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
ScheduleOnDatesTest                         "1" *-[#595959,plain]-> "runContextInitializer\n1" RunContextInitializer
ScheduleTest                                 -[#999900,dotted]-  KestraTest
ScheduleTest                                 -[#595959,dashed]->  Label                                       : "create"
ScheduleTest                                "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
ScheduleTest                                "1" *-[#595959,plain]-> "runContextInitializer\n1" RunContextInitializer
ScheduleValidationTest                       -[#999900,dotted]-  KestraTest
ScheduleValidationTest                      "1" *-[#595959,plain]-> "modelValidator\n1" ModelValidator
SchedulerCommand                             -[#000082,plain]-^  AbstractServerCommand
SchedulerConditionTest                       -[#000082,plain]-^  AbstractSchedulerTest
SchedulerConditionTest                      "1" *-[#595959,plain]-> "flowListenersService\n1" FlowListeners
SchedulerConditionTest                       -[#595959,dashed]->  JdbcScheduler                               : "create"
SchedulerConditionTest                      "1" *-[#595959,plain]-> "triggerState\n1" SchedulerTriggerStateInterface
SchedulerEndpoint                           "1" *-[#595959,plain]-> "scheduler\n1" AbstractScheduler
SchedulerExecutionWithTrigger               "1" *-[#595959,plain]-> "execution\n1" Execution
SchedulerExecutionWithTrigger               "1" *-[#595959,plain]-> "triggerContext\n1" TriggerContext
SchedulerPollingTriggerTest                  -[#000082,plain]-^  AbstractSchedulerTest
SchedulerPollingTriggerTest                 "1" *-[#595959,plain]-> "flowListenersService\n1" FlowListeners
SchedulerPollingTriggerTest                  -[#595959,dashed]->  JdbcScheduler                               : "create"
SchedulerPollingTriggerTest                 "1" *-[#595959,plain]-> "triggerState\n1" SchedulerTriggerStateInterface
SchedulerScheduleOnDatesTest                 -[#000082,plain]-^  AbstractSchedulerTest
SchedulerScheduleOnDatesTest                "1" *-[#595959,plain]-> "flowListenersService\n1" FlowListeners
SchedulerScheduleOnDatesTest                 -[#595959,dashed]->  JdbcScheduler                               : "create"
SchedulerScheduleOnDatesTest                "1" *-[#595959,plain]-> "triggerState\n1" SchedulerTriggerStateInterface
SchedulerScheduleTest                        -[#000082,plain]-^  AbstractSchedulerTest
SchedulerScheduleTest                       "1" *-[#595959,plain]-> "flowListenersService\n1" FlowListeners
SchedulerScheduleTest                        -[#595959,dashed]->  JdbcScheduler                               : "create"
SchedulerScheduleTest                       "1" *-[#595959,plain]-> "logQueue\n1" QueueInterface
SchedulerScheduleTest                       "1" *-[#595959,plain]-> "triggerState\n1" SchedulerTriggerStateInterface
SchedulerStreamingTest                       -[#000082,plain]-^  AbstractSchedulerTest
SchedulerStreamingTest                      "1" *-[#595959,plain]-> "flowListenersService\n1" FlowListeners
SchedulerStreamingTest                       -[#595959,dashed]->  JdbcScheduler                               : "create"
SchedulerStreamingTest                      "1" *-[#595959,plain]-> "triggerState\n1" SchedulerTriggerStateInterface
SchedulerThreadTest                          -[#000082,plain]-^  AbstractSchedulerTest
SchedulerThreadTest                         "1" *-[#595959,plain]-> "flowListenersService\n1" FlowListeners
SchedulerThreadTest                          -[#595959,dashed]->  JdbcScheduler                               : "create"
SchedulerThreadTest                          -[#595959,dashed]->  Label                                       : "create"
SchedulerThreadTest                         "1" *-[#595959,plain]-> "triggerState\n1" SchedulerTriggerStateInterface
SchedulerTriggerChangeTest                   -[#000082,plain]-^  AbstractSchedulerTest
SchedulerTriggerChangeTest                  "1" *-[#595959,plain]-> "flowListenersService\n1" FlowListeners
SchedulerTriggerChangeTest                   -[#595959,dashed]->  JdbcScheduler                               : "create"
SchedulerTriggerChangeTest                  "1" *-[#595959,plain]-> "flowQueue\n1" QueueInterface
SchedulerTriggerChangeTest                  "1" *-[#595959,plain]-> "triggerState\n1" SchedulerTriggerStateInterface
SchedulerTriggerStateInterfaceTest           -[#999900,dotted]-  KestraTest
SchedulerTriggerStateInterfaceTest          "1" *-[#595959,plain]-> "triggerState\n1" SchedulerTriggerStateInterface
ScriptOutput                                 -[#008200,dashed]-^  Output
ScriptOutputFormat                          "1" *-[#595959,plain]-> "metrics\n*" AbstractMetricEntry
ScriptServiceTest                            -[#999900,dotted]-  KestraTest
ScriptServiceTest                           "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
ScriptServiceTest                            -[#595959,dashed]->  State                                       : "create"
SecretFunction                              "1" *-[#595959,plain]-> "secretService\n1" SecretService
SecretFunctionTest                           -[#000082,plain]-^  AbstractMemoryRunnerTest
SecretFunctionTest                           -[#999900,dotted]-  KestraTest
SecretFunctionTest                          "1" *-[#595959,plain]-> "logQueue\n1" QueueInterface
SecretFunctionTest                          "1" *-[#595959,plain]-> "runnerUtils\n1" RunnerUtils
SecretFunctionTest                          "1" *-[#595959,plain]-> "secretService\n1" SecretService
SecretInput                                  -[#000082,plain]-^  Input
SecretNotFoundException                      -[#000082,plain]-^  KestraRuntimeException
SecretPluginInterface                        -[#999900,dotted]-  Plugin
SecretPluginInterface                        -[#008200,plain]-^  Plugin
SelectInput                                  -[#000082,plain]-^  Input
SelectInput                                  -[#008200,dashed]-^  RenderableInput
SelectInputTest                              -[#999900,dotted]-  KestraTest
SelectInputTest                             "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
Sequential                                   -[#595959,dashed]->  Example                                     : "create"
Sequential                                   -[#008200,dashed]-^  FlowableTask
Sequential                                   -[#595959,dashed]->  GraphCluster                                : "create"
Sequential                                   -[#999900,dotted]-  Plugin
Sequential                                   -[#000082,plain]-^  Task
Sequential                                  "1" *-[#595959,plain]-> "errors\n*" Task
SequentialTest                               -[#000082,plain]-^  AbstractMemoryRunnerTest
ServerCommand                                -[#000082,plain]-^  AbstractCommand
ServerConfigTest                             -[#999900,dotted]-  KestraTest
ServerConfigTest                            "1" *-[#595959,plain]-> "config\n1" ServerConfig
ServerInstanceFactory                       "1" *-[#595959,plain]-> "context\n1" KestraContext
ServerInstanceFactory                        -[#595959,dashed]->  ServerInstance                              : "create"
ServiceInstanceTest                          -[#595959,dashed]->  ServerConfig                                : "create"
ServiceInstanceTest                         "1" *-[#595959,plain]-> "CONFIG\n1" ServerConfig
ServiceInstanceTest                          -[#595959,dashed]->  ServiceInstance                             : "create"
ServiceLivenessManager                       -[#000082,plain]-^  AbstractServiceLivenessTask
ServiceLivenessManager                       -[#595959,dashed]->  LocalServiceState                           : "create"
ServiceLivenessManager                      "1" *-[#595959,plain]-> "localServiceStateFactory\n1" LocalServiceStateFactory
ServiceLivenessManager                      "1" *-[#595959,plain]-> "serverInstanceFactory\n1" ServerInstanceFactory
ServiceLivenessManager                      "1" *-[#595959,plain]-> "serviceRepository\n1" ServiceInstanceRepositoryInterface
ServiceLivenessManager                      "1" *-[#595959,plain]-> "serviceRegistry\n1" ServiceRegistry
ServiceLivenessManagerTest                   -[#595959,dashed]->  LocalServiceStateFactory                    : "create"
ServiceLivenessManagerTest                   -[#595959,dashed]->  ServerConfig                                : "create"
ServiceLivenessManagerTest                   -[#595959,dashed]->  ServerInstance                              : "create"
ServiceLivenessManagerTest                   -[#595959,dashed]->  ServerInstanceFactory                       : "create"
ServiceLivenessManagerTest                   -[#595959,dashed]->  ServiceInstance                             : "create"
ServiceLivenessManagerTest                  "1" *-[#595959,plain]-> "repository\n1" ServiceInstanceRepositoryInterface
ServiceLivenessManagerTest                  "1" *-[#595959,plain]-> "serviceLivenessManager\n1" ServiceLivenessManager
ServiceLivenessManagerTest                   -[#595959,dashed]->  ServiceLivenessManager                      : "create"
ServiceLivenessManagerTest                   -[#595959,dashed]->  ServiceRegistry                             : "create"
ServiceLivenessManagerTest                   -[#595959,dashed]->  ServiceStateChangeEvent                     : "create"
ServiceRegistry                             "1" *-[#595959,plain]-> "services\n*" LocalServiceState
Set                                          -[#000082,plain]-^  AbstractState
Set                                          -[#595959,dashed]->  Example                                     : "create"
Set                                          -[#595959,dashed]->  Example                                     : "create"
Set                                          -[#595959,dashed]->  KVMetadata                                  : "create"
Set                                         "1" *-[#595959,plain]-> "kvType\n1" KVType
Set                                          -[#595959,dashed]->  KVValueAndMetadata                          : "create"
Set                                          -[#999900,dotted]-  Plugin
Set                                          -[#999900,dotted]-  Plugin
Set                                          -[#008200,dashed]-^  RunnableTask
Set                                          -[#008200,dashed]-^  RunnableTask
Set                                          -[#000082,plain]-^  Task
SetTest                                      -[#595959,dashed]->  KVValue                                     : "create"
SetTest                                      -[#999900,dotted]-  KestraTest
SetTest                                     "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
SetTest                                     "1" *-[#595959,plain]-> "storageInterface\n1" StorageInterface
Size                                         -[#595959,dashed]->  Example                                     : "create"
Size                                         -[#999900,dotted]-  Plugin
Size                                         -[#008200,dashed]-^  RunnableTask
Size                                         -[#000082,plain]-^  Task
SizeTest                                     -[#999900,dotted]-  KestraTest
SizeTest                                    "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
SizeTest                                    "1" *-[#595959,plain]-> "storageInterface\n1" StorageInterface
SkipExecutionCaseTest                       "1" *-[#595959,plain]-> "executionRepository\n1" ExecutionRepositoryInterface
SkipExecutionCaseTest                       "1" *-[#595959,plain]-> "executionQueue\n1" QueueInterface
SkipExecutionCaseTest                       "1" *-[#595959,plain]-> "runnerUtils\n1" RunnerUtils
SkipExecutionCaseTest                       "1" *-[#595959,plain]-> "skipExecutionService\n1" SkipExecutionService
SkipExecutionServiceTest                     -[#999900,dotted]-  KestraTest
SkipExecutionServiceTest                    "1" *-[#595959,plain]-> "skipExecutionService\n1" SkipExecutionService
Sleep                                        -[#008200,dashed]-^  RunnableTask
Sleep                                        -[#000082,plain]-^  Task
SleepTrigger                                 -[#000082,plain]-^  AbstractTrigger
SleepTrigger                                 -[#008200,dashed]-^  PollingTriggerInterface
SlugifyFilter                                -[#000082,plain]-^  AbstractDate
SlugifyFilterTest                            -[#999900,dotted]-  KestraTest
SlugifyFilterTest                           "1" *-[#595959,plain]-> "variableRenderer\n1" VariableRenderer
Split                                        -[#595959,dashed]->  Example                                     : "create"
Split                                        -[#999900,dotted]-  Plugin
Split                                        -[#008200,dashed]-^  RunnableTask
Split                                        -[#008200,dashed]-^  StorageSplitInterface
Split                                        -[#000082,plain]-^  Task
SplitTest                                    -[#999900,dotted]-  KestraTest
SplitTest                                   "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
SplitTest                                   "1" *-[#595959,plain]-> "storageInterface\n1" StorageInterface
StandAloneCommand                            -[#000082,plain]-^  AbstractServerCommand
StandAloneCommand                           "1" *-[#595959,plain]-> "skipExecutionService\n1" SkipExecutionService
StandAloneCommand                           "1" *-[#595959,plain]-> "startExecutorService\n1" StartExecutorService
StandAloneRunner                            "1" *-[#595959,plain]-> "executorsUtils\n1" ExecutorsUtils
StandAloneRunner                             -[#008200,dashed]-^  RunnerInterface
StandAloneRunner                            "1" *-[#595959,plain]-> "servers\n*" Service
StartExecutorServiceTest                     -[#999900,dotted]-  KestraTest
StartExecutorServiceTest                    "1" *-[#595959,plain]-> "startExecutorService\n1" StartExecutorService
StartsWithFilterTest                         -[#999900,dotted]-  KestraTest
StartsWithFilterTest                        "1" *-[#595959,plain]-> "variableRenderer\n1" VariableRenderer
StateNamespaceTest                           -[#999900,dotted]-  KestraTest
StateNamespaceTest                          "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
StateStore                                   -[#595959,dashed]->  KVValueAndMetadata                          : "create"
StateStore                                   -[#595959,dashed]->  MigrationRequiredException                  : "create"
StateStore                                  "1" *-[#595959,plain]-> "runContext\n1" RunContext
StateStoreCommand                            -[#000082,plain]-^  AbstractCommand
StateStoreMigrateCommand                     -[#000082,plain]-^  AbstractCommand
StateStoreMigrateCommand                     -[#595959,dashed]->  StateStore                                  : "create"
StateStoreMigrateCommandTest                 -[#595959,dashed]->  StateStore                                  : "create"
StateStoreTest                              "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
StateTest                                    -[#000082,plain]-^  AbstractMemoryRunnerTest
StateTest                                    -[#999900,dotted]-  KestraTest
StateTest                                   "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
StatsController                             "1" *-[#595959,plain]-> "executionRepository\n1" ExecutionRepositoryInterface
StatsController                             "1" *-[#595959,plain]-> "flowRepositoryInterface\n1" FlowRepositoryInterface
StatsController                             "1" *-[#595959,plain]-> "logRepositoryInterface\n1" LogRepositoryInterface
StatsController                              -[#595959,dashed]->  SummaryStatistics                           : "create"
StatsController                             "1" *-[#595959,plain]-> "tenantService\n1" TenantService
StatsController                             "1" *-[#595959,plain]-> "triggerRepositoryInterface\n1" TriggerRepositoryInterface
StatsControllerTest                          -[#000082,plain]-^  JdbcH2ControllerTest
StorageInterface                             -[#008200,plain]-^  Plugin
StorageInterface                             -[#595959,dashed]->  StorageObject                               : "create"
StorageInterfaceFactory                      -[#595959,dashed]->  KestraRuntimeException                      : "create"
StorageInterfaceFactoryTest                 "1" *-[#595959,plain]-> "registry\n1" DefaultPluginRegistry
StorageInterfaceFactoryTest                  -[#999900,dotted]-  KestraTest
StorageTestSuite                             -[#999900,dotted]-  KestraTest
StorageTestSuite                            "1" *-[#595959,plain]-> "storageInterface\n1" StorageInterface
StorageTestSuite                             -[#595959,dashed]->  StorageObject                               : "create"
StringInput                                  -[#000082,plain]-^  Input
Subflow                                      -[#008200,dashed]-^  ChildFlowInterface
Subflow                                      -[#595959,dashed]->  Example                                     : "create"
Subflow                                      -[#008200,dashed]-^  ExecutableTask
Subflow                                      -[#595959,dashed]->  Label                                       : "create"
Subflow                                      -[#999900,dotted]-  Plugin
Subflow                                     "1" *-[#595959,plain]-> "scheduleDate\n1" Property
Subflow                                      -[#595959,dashed]->  State                                       : "create"
Subflow                                      -[#000082,plain]-^  Task
SubflowExecution                             -[#595959,dashed]->  ExecutableTask
SubflowExecution                            "1" *-[#595959,plain]-> "execution\n1" Execution
SubflowExecution                             -[#595959,dashed]->  Task
SubflowExecution                            "1" *-[#595959,plain]-> "parentTaskRun\n1" TaskRun
SubflowExecutionResult                      "1" *-[#595959,plain]-> "parentTaskRun\n1" TaskRun
SubflowGraphCluster                          -[#000082,plain]-^  GraphCluster
SubflowGraphCluster                          -[#595959,dashed]->  Relation                                    : "create"
SubflowGraphTask                             -[#000082,plain]-^  AbstractGraphTask
SubflowTest                                 "1" *-[#595959,plain]-> "runContext\n1" DefaultRunContext
SubflowTest                                 "1" *-[#595959,plain]-> "DEFAULT_SUCCESS_STATE\n1" State
SubflowTest                                  -[#595959,dashed]->  Subflow                                     : "create"
SubmitQueuedCommand                          -[#000082,plain]-^  AbstractCommand
SubmitQueuedCommand                         "1" *-[#595959,plain]-> "executionQueue\n1" QueueInterface
SubstringFilterTest                          -[#999900,dotted]-  KestraTest
SubstringFilterTest                         "1" *-[#595959,plain]-> "variableRenderer\n1" VariableRenderer
SuperclassTask                               -[#008200,dashed]-^  RunnableTask
SuperclassTask                               -[#000082,plain]-^  Task
Switch                                       -[#595959,dashed]->  Example                                     : "create"
Switch                                       -[#008200,dashed]-^  FlowableTask
Switch                                       -[#595959,dashed]->  GraphCluster                                : "create"
Switch                                       -[#999900,dotted]-  Plugin
Switch                                       -[#999900,dotted]-  SwitchTaskValidation
Switch                                       -[#000082,plain]-^  Task
Switch                                      "1" *-[#595959,plain]-> "defaults\n*" Task
SwitchTest                                   -[#000082,plain]-^  AbstractMemoryRunnerTest
SysCommand                                   -[#000082,plain]-^  AbstractCommand
Task                                        "1" *-[#595959,plain]-> "retry\n1" AbstractRetry
Task                                         -[#999900,dotted]-  Plugin
Task                                         -[#008200,dashed]-^  TaskInterface
Task                                        "1" *-[#595959,plain]-> "workerGroup\n1" WorkerGroup
TaskForExecution                            "1" *-[#595959,plain]-> "inputs\n*" Input
TaskForExecution                             -[#008200,dashed]-^  TaskInterface
TaskGlobalDefaultConfiguration              "1" *-[#595959,plain]-> "defaults\n*" PluginDefault
TaskGlobalDefaultConfigurationTest           -[#999900,dotted]-  KestraTest
TaskInterface                                -[#008200,plain]-^  Plugin
TaskResult                                  "1" *-[#595959,plain]-> "state\n1" State
TaskRun                                      -[#595959,dashed]->  State                                       : "create"
TaskRun                                     "1" *-[#595959,plain]-> "state\n1" State
TaskRun                                     "1" *-[#595959,plain]-> "attempts\n*" TaskRunAttempt
TaskRun                                      -[#008200,dashed]-^  TenantInterface
TaskRunAttempt                              "1" *-[#595959,plain]-> "state\n1" State
TaskRunController                           "1" *-[#595959,plain]-> "executionRepository\n1" ExecutionRepositoryInterface
TaskRunController                           "1" *-[#595959,plain]-> "tenantService\n1" TenantService
TaskRunControllerTest                        -[#000082,plain]-^  JdbcH2ControllerTest
TaskRunTest                                  -[#595959,dashed]->  State                                       : "create"
TaskRunner                                   -[#999900,dotted]-  Plugin
TaskRunner                                   -[#008200,dashed]-^  Plugin
TaskRunner                                   -[#008200,dashed]-^  WorkerJobLifecycle
TaskRunnerTest                               -[#999900,dotted]-  KestraTest
TaskRunnerTest                              "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
TaskWithAlias                                -[#999900,dotted]-  Plugin
TaskWithAlias                                -[#008200,dashed]-^  RunnableTask
TaskWithAlias                                -[#000082,plain]-^  Task
TaskWithAllowFailureTest                     -[#000082,plain]-^  AbstractMemoryRunnerTest
TaskWithAllowFailureTest                    "1" *-[#595959,plain]-> "flowIO\n1" FlowInputOutput
TaskWithAllowFailureTest                    "1" *-[#595959,plain]-> "storageInterface\n1" StorageInterface
Template                                     -[#008200,dashed]-^  DeletedInterface
Template                                     -[#595959,dashed]->  DeserializationException                    : "create"
Template                                     -[#595959,dashed]->  Example                                     : "create"
Template                                     -[#008200,dashed]-^  FlowableTask
Template                                     -[#595959,dashed]->  GraphCluster                                : "create"
Template                                     -[#595959,dashed]->  IllegalVariableEvaluationException          : "create"
Template                                     -[#595959,dashed]->  InternalException                           : "create"
Template                                     -[#999900,dotted]-  Plugin
Template                                     -[#000082,plain]-^  Task
Template                                    "1" *-[#595959,plain]-> "errors\n*" Task
Template                                    "1" *-[#595959,plain]-> "tasks\n*" Task
Template                                     -[#999900,dotted]-  TemplateEnabled
Template                                     -[#008200,dashed]-^  TenantInterface
TemplateCommand                              -[#000082,plain]-^  AbstractCommand
TemplateCommand                              -[#999900,dotted]-  TemplateEnabled
TemplateController                          "1" *-[#595959,plain]-> "modelValidator\n1" ModelValidator
TemplateController                           -[#999900,dotted]-  TemplateEnabled
TemplateController                          "1" *-[#595959,plain]-> "templateRepository\n1" TemplateRepositoryInterface
TemplateController                          "1" *-[#595959,plain]-> "tenantService\n1" TenantService
TemplateController                           -[#595959,dashed]->  YamlFlowParser                              : "create"
TemplateControllerTest                      "1" *-[#595959,plain]-> "templateRepository\n1" AbstractJdbcTemplateRepository
TemplateControllerTest                       -[#595959,dashed]->  IdWithNamespace                             : "create"
TemplateControllerTest                       -[#000082,plain]-^  JdbcH2ControllerTest
TemplateExportCommand                        -[#000082,plain]-^  AbstractApiCommand
TemplateExportCommand                        -[#999900,dotted]-  TemplateEnabled
TemplateNamespaceCommand                     -[#000082,plain]-^  AbstractCommand
TemplateNamespaceCommand                     -[#999900,dotted]-  TemplateEnabled
TemplateNamespaceUpdateCommand               -[#000082,plain]-^  AbstractServiceNamespaceUpdateCommand
TemplateNamespaceUpdateCommand               -[#999900,dotted]-  TemplateEnabled
TemplateNamespaceUpdateCommand              "1" *-[#595959,plain]-> "yamlFlowParser\n1" YamlFlowParser
TemplateSource                               -[#000082,plain]-^  Template
TemplateTest                                 -[#000082,plain]-^  AbstractMemoryRunnerTest
TemplateTest                                "1" *-[#595959,plain]-> "flowIO\n1" FlowInputOutput
TemplateTest                                "1" *-[#595959,plain]-> "logQueue\n1" QueueInterface
TemplateTest                                "1" *-[#595959,plain]-> "TEMPLATE_1\n1" Template
TemplateTest                                "1" *-[#595959,plain]-> "templateRepository\n1" TemplateRepositoryInterface
TemplateValidateCommand                      -[#000082,plain]-^  AbstractValidateCommand
TemplateValidateCommand                     "1" *-[#595959,plain]-> "modelValidator\n1" ModelValidator
TemplateValidateCommand                      -[#999900,dotted]-  TemplateEnabled
TemplateValidateCommand                     "1" *-[#595959,plain]-> "yamlFlowParser\n1" YamlFlowParser
TemplatedTask                                -[#595959,dashed]->  Example                                     : "create"
TemplatedTask                                -[#595959,dashed]->  IllegalVariableEvaluationException          : "create"
TemplatedTask                                -[#999900,dotted]-  Plugin
TemplatedTask                                -[#008200,dashed]-^  RunnableTask
TemplatedTask                                -[#000082,plain]-^  Task
TemplatedTaskTest                            -[#999900,dotted]-  KestraTest
TemplatedTaskTest                           "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
TenantServiceTest                            -[#999900,dotted]-  KestraTest
TenantServiceTest                           "1" *-[#595959,plain]-> "tenantService\n1" TenantService
TestMethodScopedWorker                       -[#000082,plain]-^  Worker
TestWorkingDir                               -[#595959,dashed]->  LocalWorkingDir                             : "create"
TestWorkingDir                               -[#008200,dashed]-^  WorkingDir
TestWorkingDir                              "1" *-[#595959,plain]-> "delegate\n1" WorkingDir
TestsUtils                                   -[#595959,dashed]->  State                                       : "create"
TimeBetweenCondition                         -[#000082,plain]-^  Condition
TimeBetweenCondition                         -[#595959,dashed]->  Example                                     : "create"
TimeBetweenCondition                         -[#595959,dashed]->  IllegalConditionEvaluation                  : "create"
TimeBetweenCondition                         -[#999900,dotted]-  Plugin
TimeBetweenCondition                         -[#008200,dashed]-^  ScheduleCondition
TimeBetweenConditionTest                    "1" *-[#595959,plain]-> "conditionService\n1" ConditionService
TimeBetweenConditionTest                     -[#999900,dotted]-  KestraTest
TimeInput                                    -[#000082,plain]-^  Input
TimeoutTest                                  -[#000082,plain]-^  AbstractMemoryRunnerTest
TimeoutTest                                 "1" *-[#595959,plain]-> "flowRepository\n1" FlowRepositoryInterface
TimeoutTest                                 "1" *-[#595959,plain]-> "pluginDefaultService\n1" PluginDefaultService
TimeoutTest                                 "1" *-[#595959,plain]-> "workerTaskLogQueue\n1" QueueInterface
Timer                                        -[#000082,plain]-^  AbstractMetricEntry
TimestampFilter                              -[#000082,plain]-^  AbstractDate
TimestampMicroFilter                         -[#000082,plain]-^  AbstractDate
TimestampNanoFilter                          -[#000082,plain]-^  AbstractDate
TimezoneIdTest                               -[#999900,dotted]-  KestraTest
TimezoneIdTest                              "1" *-[#595959,plain]-> "modelValidator\n1" ModelValidator
ToIonFilterTest                              -[#999900,dotted]-  KestraTest
ToIonFilterTest                             "1" *-[#595959,plain]-> "variableRenderer\n1" VariableRenderer
ToJsonFilterTest                             -[#999900,dotted]-  KestraTest
ToJsonFilterTest                            "1" *-[#595959,plain]-> "variableRenderer\n1" VariableRenderer
Toggle                                       -[#595959,dashed]->  Example                                     : "create"
Toggle                                       -[#999900,dotted]-  Plugin
Toggle                                       -[#008200,dashed]-^  RunnableTask
Toggle                                       -[#000082,plain]-^  Task
ToggleTest                                   -[#000082,plain]-^  AbstractMemoryRunnerTest
ToggleTest                                  "1" *-[#595959,plain]-> "scheduler\n1" AbstractScheduler
ToggleTest                                  "1" *-[#595959,plain]-> "triggerQueue\n1" QueueInterface
ToggleTest                                  "1" *-[#595959,plain]-> "triggerRepository\n1" TriggerRepositoryInterface
Trigger                                      -[#000082,plain]-^  AbstractTrigger
Trigger                                      -[#595959,dashed]->  Example                                     : "create"
Trigger                                      -[#008200,dashed]-^  HttpInterface
Trigger                                      -[#999900,dotted]-  Plugin
Trigger                                      -[#008200,dashed]-^  PollingTriggerInterface
Trigger                                      -[#000082,plain]-^  TriggerContext
Trigger                                      -[#008200,dashed]-^  TriggerOutput
TriggerContext                              "1" *-[#595959,plain]-> "backfill\n1" Backfill
TriggerController                            -[#595959,dashed]->  ArrayListTotal                              : "create"
TriggerController                           "1" *-[#595959,plain]-> "conditionService\n1" ConditionService
TriggerController                           "1" *-[#595959,plain]-> "flowRepository\n1" FlowRepositoryInterface
TriggerController                           "1" *-[#595959,plain]-> "triggerQueue\n1" QueueInterface
TriggerController                           "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
TriggerController                           "1" *-[#595959,plain]-> "tenantService\n1" TenantService
TriggerController                           "1" *-[#595959,plain]-> "triggerRepository\n1" TriggerRepositoryInterface
TriggerControllerTest                       "1" *-[#595959,plain]-> "jdbcFlowRepository\n1" AbstractJdbcFlowRepository
TriggerControllerTest                       "1" *-[#595959,plain]-> "jdbcTriggerRepository\n1" AbstractJdbcTriggerRepository
TriggerControllerTest                        -[#000082,plain]-^  JdbcH2ControllerTest
TriggerControllerTest                       "1" *-[#595959,plain]-> "jdbcTestUtils\n1" JdbcTestUtils
TriggerInterface                             -[#008200,plain]-^  Plugin
TriggerOutput                                -[#595959,dashed]->  Output
TriggerService                               -[#595959,dashed]->  State                                       : "create"
TriggerTest                                 "1" *-[#595959,plain]-> "flowListenersService\n1" FlowListenersInterface
TriggerTest                                  -[#595959,dashed]->  JdbcScheduler                               : "create"
TriggerTest                                  -[#999900,dotted]-  KestraTest
TriggerTest                                 "1" *-[#595959,plain]-> "repositoryLoader\n1" LocalFlowRepositoryLoader
TriggerTest                                 "1" *-[#595959,plain]-> "executionQueue\n1" QueueInterface
TriggerTest                                 "1" *-[#595959,plain]-> "triggerState\n1" SchedulerTriggerStateInterface
TriggerWithAlias                             -[#000082,plain]-^  AbstractTrigger
TriggerWithAlias                             -[#999900,dotted]-  Plugin
TriggerWithAlias                             -[#008200,dashed]-^  PollingTriggerInterface
TypedObjectWriter                            -[#000082,plain]-^  OutputWriter
TypedObjectWriterTest                        -[#595959,dashed]->  TypedObjectWriter                           : "create"
URIInput                                     -[#000082,plain]-^  Input
UndefinedCoalescingExpressionTest            -[#999900,dotted]-  KestraTest
UndefinedCoalescingExpressionTest           "1" *-[#595959,plain]-> "variableRenderer\n1" VariableRenderer
UploadFiles                                  -[#595959,dashed]->  Example                                     : "create"
UploadFiles                                  -[#999900,dotted]-  Plugin
UploadFiles                                  -[#008200,dashed]-^  RunnableTask
UploadFiles                                  -[#000082,plain]-^  Task
UploadFilesTest                              -[#999900,dotted]-  KestraTest
UploadFilesTest                             "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
UploadFilesTest                             "1" *-[#595959,plain]-> "storageInterface\n1" StorageInterface
UriProviderTest                              -[#999900,dotted]-  KestraTest
UriProviderTest                             "1" *-[#595959,plain]-> "uriProvider\n1" UriProvider
UrlDecodeFilter                              -[#999900,dotted]-  KestraTest
UrlDecodeFilter                             "1" *-[#595959,plain]-> "variableRenderer\n1" VariableRenderer
Usage                                       "1" *-[#595959,plain]-> "configurations\n1" ConfigurationUsage
Usage                                       "1" *-[#595959,plain]-> "executions\n1" ExecutionUsage
Usage                                       "1" *-[#595959,plain]-> "flows\n1" FlowUsage
Usage                                       "1" *-[#595959,plain]-> "host\n1" HostUsage
Usage                                       "1" *-[#595959,plain]-> "plugins\n*" PluginUsage
Usage                                       "1" *-[#595959,plain]-> "serverType\n1" ServerType
ValuesFilterTest                             -[#999900,dotted]-  KestraTest
ValuesFilterTest                            "1" *-[#595959,plain]-> "variableRenderer\n1" VariableRenderer
VariableRenderer                             -[#595959,dashed]->  IllegalVariableEvaluationException          : "create"
VariableRenderer                             -[#595959,dashed]->  JsonWriter                                  : "create"
VariableRenderer                             -[#595959,dashed]->  PebbleLruCache                              : "create"
VariableRenderer                             -[#595959,dashed]->  TypedObjectWriter                           : "create"
VariableRendererTest                         -[#999900,dotted]-  KestraTest
VariableRendererTest                        "1" *-[#595959,plain]-> "variableRenderer\n1" VariableRenderer
VariablesTest                                -[#000082,plain]-^  AbstractMemoryRunnerTest
VariablesTest                               "1" *-[#595959,plain]-> "workerTaskLogQueue\n1" QueueInterface
VersionEndpoint                              -[#595959,dashed]->  ServerInfo                                  : "create"
VersionEndpoint                             "1" *-[#595959,plain]-> "version\n1" VersionProvider
VersionProvider                             "1" *-[#595959,plain]-> "versionProvider\n1" VersionProvider
VoidOutput                                   -[#008200,dashed]-^  Output
WaitFor                                      -[#595959,dashed]->  Example                                     : "create"
WaitFor                                      -[#008200,dashed]-^  FlowableTask
WaitFor                                      -[#595959,dashed]->  GraphCluster                                : "create"
WaitFor                                      -[#999900,dotted]-  Plugin
WaitFor                                      -[#000082,plain]-^  Task
WaitFor                                     "1" *-[#595959,plain]-> "errors\n*" Task
WaitForCaseTest                             "1" *-[#595959,plain]-> "flowRepository\n1" FlowRepositoryInterface
WaitForCaseTest                             "1" *-[#595959,plain]-> "runnerUtils\n1" RunnerUtils
WebServerCommand                             -[#000082,plain]-^  AbstractServerCommand
Webhook                                      -[#000082,plain]-^  AbstractTrigger
Webhook                                      -[#595959,dashed]->  Example                                     : "create"
Webhook                                      -[#999900,dotted]-  Plugin
Webhook                                      -[#595959,dashed]->  State                                       : "create"
Webhook                                      -[#008200,dashed]-^  TriggerOutput
Webhook                                      -[#999900,dotted]-  WebhookValidation
WebhookTest                                  -[#999900,dotted]-  KestraTest
WebhookTest                                 "1" *-[#595959,plain]-> "modelValidator\n1" ModelValidator
WebserverService                             -[#008200,dashed]-^  Service
WebserverService                             -[#595959,dashed]->  ServiceStateChangeEvent                     : "create"
WeekendCondition                             -[#000082,plain]-^  Condition
WeekendCondition                             -[#595959,dashed]->  Example                                     : "create"
WeekendCondition                             -[#999900,dotted]-  Plugin
WeekendCondition                             -[#008200,dashed]-^  ScheduleCondition
WeekendConditionTest                        "1" *-[#595959,plain]-> "conditionService\n1" ConditionService
WeekendConditionTest                         -[#999900,dotted]-  KestraTest
Worker                                      "1" *-[#595959,plain]-> "workerThreadReferences\n*" AbstractWorkerThread
Worker                                      "1" *-[#595959,plain]-> "logService\n1" LogService
Worker                                      "1" *-[#595959,plain]-> "metricRegistry\n1" MetricRegistry
Worker                                      "1" *-[#595959,plain]-> "workerTaskResultQueue\n1" QueueInterface
Worker                                      "1" *-[#595959,plain]-> "runContextInitializer\n1" RunContextInitializer
Worker                                      "1" *-[#595959,plain]-> "runContextLoggerFactory\n1" RunContextLoggerFactory
Worker                                      "1" *-[#595959,plain]-> "serverConfig\n1" ServerConfig
Worker                                       -[#008200,dashed]-^  Service
Worker                                       -[#595959,dashed]->  ServiceStateChangeEvent                     : "create"
Worker                                       -[#595959,dashed]->  State                                       : "create"
Worker                                      "1" *-[#595959,plain]-> "workerJobQueue\n1" WorkerJobQueueInterface
Worker                                       -[#595959,dashed]->  WorkerTaskResult                            : "create"
Worker                                       -[#595959,dashed]->  WorkerTaskThread                            : "create"
Worker                                       -[#595959,dashed]->  WorkerTriggerRealtimeThread                 : "create"
Worker                                       -[#595959,dashed]->  WorkerTriggerThread                         : "create"
WorkerCommand                                -[#000082,plain]-^  AbstractServerCommand
WorkerEndpoint                              "1" *-[#595959,plain]-> "worker\n1" Worker
WorkerGroup                                  -[#999900,dotted]-  WorkerGroupValidation
WorkerJobRunning                            "1" *-[#595959,plain]-> "workerInstance\n1" WorkerInstance
WorkerTask                                  "1" *-[#595959,plain]-> "runContext\n1" RunContext
WorkerTask                                  "1" *-[#595959,plain]-> "task\n1" Task
WorkerTask                                  "1" *-[#595959,plain]-> "taskRun\n1" TaskRun
WorkerTask                                   -[#000082,plain]-^  WorkerJob
WorkerTaskResult                            "1" *-[#595959,plain]-> "dynamicTaskRuns\n*" TaskRun
WorkerTaskResultTooLarge                     -[#999900,dotted]-  Plugin
WorkerTaskResultTooLarge                     -[#008200,dashed]-^  RunnableTask
WorkerTaskResultTooLarge                     -[#000082,plain]-^  Task
WorkerTaskRunning                           "1" *-[#595959,plain]-> "runContext\n1" RunContext
WorkerTaskRunning                           "1" *-[#595959,plain]-> "task\n1" Task
WorkerTaskRunning                           "1" *-[#595959,plain]-> "taskRun\n1" TaskRun
WorkerTaskRunning                            -[#000082,plain]-^  WorkerJobRunning
WorkerTaskThread                             -[#000082,plain]-^  AbstractWorkerThread
WorkerTaskThread                            "1" *-[#595959,plain]-> "metricRegistry\n1" MetricRegistry
WorkerTaskThread                            "1" *-[#595959,plain]-> "taskOutput\n1" Output
WorkerTaskThread                            "1" *-[#595959,plain]-> "task\n1" RunnableTask
WorkerTaskThread                             -[#595959,dashed]->  TimeoutExceededException                    : "create"
WorkerTaskThread                            "1" *-[#595959,plain]-> "workerTask\n1" WorkerTask
WorkerTest                                   -[#999900,dotted]-  KestraTest
WorkerTest                                  "1" *-[#595959,plain]-> "workerTaskQueue\n1" QueueInterface
WorkerTest                                  "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
WorkerTrigger                               "1" *-[#595959,plain]-> "trigger\n1" AbstractTrigger
WorkerTrigger                               "1" *-[#595959,plain]-> "conditionContext\n1" ConditionContext
WorkerTrigger                               "1" *-[#595959,plain]-> "triggerContext\n1" Trigger
WorkerTrigger                                -[#000082,plain]-^  WorkerJob
WorkerTriggerInterface                       -[#008200,plain]-^  WorkerJobLifecycle
WorkerTriggerRealtimeThread                  -[#000082,plain]-^  AbstractWorkerTriggerThread
WorkerTriggerRealtimeThread                 "1" *-[#595959,plain]-> "streamingTrigger\n1" RealtimeTriggerInterface
WorkerTriggerResult                         "1" *-[#595959,plain]-> "trigger\n1" AbstractTrigger
WorkerTriggerResult                         "1" *-[#595959,plain]-> "triggerContext\n1" TriggerContext
WorkerTriggerRunning                        "1" *-[#595959,plain]-> "trigger\n1" AbstractTrigger
WorkerTriggerRunning                        "1" *-[#595959,plain]-> "conditionContext\n1" ConditionContext
WorkerTriggerRunning                        "1" *-[#595959,plain]-> "triggerContext\n1" Trigger
WorkerTriggerRunning                         -[#000082,plain]-^  WorkerJobRunning
WorkerTriggerThread                          -[#000082,plain]-^  AbstractWorkerTriggerThread
WorkerTriggerThread                         "1" *-[#595959,plain]-> "pollingTrigger\n1" PollingTriggerInterface
WorkingDirFactory                            -[#595959,dashed]->  LocalWorkingDir                             : "create"
WorkingDirFactoryTest                       "1" *-[#595959,plain]-> "workingDirFactory\n1" WorkingDirFactory
WorkingDirectory                             -[#595959,dashed]->  Example                                     : "create"
WorkingDirectory                             -[#008200,dashed]-^  InputFilesInterface
WorkingDirectory                            "1" *-[#595959,plain]-> "namespaceFiles\n1" NamespaceFiles
WorkingDirectory                             -[#008200,dashed]-^  NamespaceFilesInterface
WorkingDirectory                             -[#008200,dashed]-^  OutputFilesInterface
WorkingDirectory                             -[#999900,dotted]-  Plugin
WorkingDirectory                             -[#000082,plain]-^  Sequential
WorkingDirectory                             -[#595959,dashed]->  State                                       : "create"
WorkingDirectory                             -[#999900,dotted]-  WorkingDirectoryTaskValidation
WorkingDirectoryTest                         -[#000082,plain]-^  AbstractMemoryRunnerTest
WorkingDirectoryTest                         -[#999900,dotted]-  KestraTest
WorkingDirectoryTest                        "1" *-[#595959,plain]-> "modelValidator\n1" ModelValidator
WorkingDirectoryTest                        "1" *-[#595959,plain]-> "runContextFactory\n1" RunContextFactory
WorkingDirectoryTest                         -[#595959,dashed]->  WorkerGroup                                 : "create"
YamlFilterTest                               -[#999900,dotted]-  KestraTest
YamlFilterTest                              "1" *-[#595959,plain]-> "variableRenderer\n1" VariableRenderer
YamlFlowParserTest                           -[#999900,dotted]-  KestraTest
YamlFlowParserTest                          "1" *-[#595959,plain]-> "modelValidator\n1" ModelValidator
YamlFlowParserTest                          "1" *-[#595959,plain]-> "yamlFlowParser\n1" YamlFlowParser
YamlFunctionTest                             -[#999900,dotted]-  KestraTest
YamlFunctionTest                            "1" *-[#595959,plain]-> "variableRenderer\n1" VariableRenderer
YamlInput                                    -[#000082,plain]-^  Input
@enduml
